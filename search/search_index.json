{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To Learn Engine Dev Welcome to a tutorial for creating a simple game engine from scratch! The tech stack will consist of the following: C++ 14 OpenGL 3.3 SDL2 SDL2_mixer (audio) Python 3.7 (embedded for scripting)","title":"Introduction"},{"location":"#welcome-to-learn-engine-dev","text":"Welcome to a tutorial for creating a simple game engine from scratch! The tech stack will consist of the following: C++ 14 OpenGL 3.3 SDL2 SDL2_mixer (audio) Python 3.7 (embedded for scripting)","title":"Welcome To Learn Engine Dev"},{"location":"getting_started/embedding_python/","text":"Embedding Python Hello Python For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. The python37.dll should be included in the root directory of the project. Build For building the application we will be using make . To make the paths for dependencies configurable we'll set environment variables. PYTHON_HOME should be set to the path of the python 3.7 installation on your system. The Makefile should look like the following: CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I\"${PYTHON_HOME}/include\" L_FLAGS := -lmingw32 -lpython37 -static-libgcc -static-libstdc++ C_FLAGS := -w -std=c++14 -Wfatal-errors LIBRARIES := -L\"${PYTHON_HOME}/libs\" PROJECT_NAME := learn_engine_dev BUILD_OBJECT := $(PROJECT_NAME).exe SRC = $(wildcard *.cpp) OBJ = $(SRC:.cpp=.o) # MAIN .PHONY: all build clean all: clean format build # Compiles if .o is missing %.o: %.cpp @echo \"Compiling \" $< \" into \" $@ @$(CXX) -c $(C_FLAGS) $< -o $@ $(I_FLAGS) build: $(OBJ) $(OBJ_C) @echo \"Linking \" $@ @$(CXX) -o $(BUILD_OBJECT) $^ $(I_FLAGS) $(L_FLAGS) $(LIBRARIES) format: astyle -n --style=google --recursive src/*.cpp src/*.h clean: ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") del $(BUILD_OBJECT) endif $(foreach object, $(OBJ) $(OBJ_C), @del $(subst /,\\, $(object));) run: ./$(BUILD_OBJECT) One other thing to note is that astyle is used for formatting c++ code. Hello World Embedded Python Edition It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation from python for embedding can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main(int argv, char** args) { Py_SetProgramName(L\"learn_engine_dev\"); Py_Initialize(); PyRun_SimpleString(\"print('hello world (from python)')\"); Py_Finalize(); return 0; } This should print out 'hello world (from python)' . There's a few things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print('hello world (from python)') Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better. You can check you code by looking at the source here . We will want to execute scripts and functions from our engine and also be able to call functions within our engine from a python script. We will get to that soon, but next we will create a helper class to help make embedding python easier. PyHelper Class Coming soon. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public: CPyInstance() { Py_SetProgramName(L\"learn_engine_dev\"); Py_Initialize(); } ~CPyInstance() { Py_Finalize(); } }; class CPyObject { private: PyObject* pyObj; public: CPyObject(): pyObj(nullptr) {} CPyObject(PyObject* p) : pyObj(p) {} ~CPyObject() { Release(); } PyObject* GetObj() { return pyObj; } PyObject* SetObj(PyObject* p) { return (pyObj=p); } PyObject* AddRef() { if(pyObj) { Py_INCREF(pyObj); } return pyObj; } void Release() { if(pyObj) { Py_DECREF(pyObj); } pyObj = nullptr; } PyObject* operator->() { return pyObj; } bool Is() const { return pyObj ? true : false; } operator PyObject*() { return pyObj; } PyObject* operator=(PyObject* p) { pyObj = p; return pyObj; } }; #endif //PYHELPER_HPP","title":"Embedding Python"},{"location":"getting_started/embedding_python/#embedding-python","text":"","title":"Embedding Python"},{"location":"getting_started/embedding_python/#hello-python","text":"For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. The python37.dll should be included in the root directory of the project.","title":"Hello Python"},{"location":"getting_started/embedding_python/#build","text":"For building the application we will be using make . To make the paths for dependencies configurable we'll set environment variables. PYTHON_HOME should be set to the path of the python 3.7 installation on your system. The Makefile should look like the following: CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I\"${PYTHON_HOME}/include\" L_FLAGS := -lmingw32 -lpython37 -static-libgcc -static-libstdc++ C_FLAGS := -w -std=c++14 -Wfatal-errors LIBRARIES := -L\"${PYTHON_HOME}/libs\" PROJECT_NAME := learn_engine_dev BUILD_OBJECT := $(PROJECT_NAME).exe SRC = $(wildcard *.cpp) OBJ = $(SRC:.cpp=.o) # MAIN .PHONY: all build clean all: clean format build # Compiles if .o is missing %.o: %.cpp @echo \"Compiling \" $< \" into \" $@ @$(CXX) -c $(C_FLAGS) $< -o $@ $(I_FLAGS) build: $(OBJ) $(OBJ_C) @echo \"Linking \" $@ @$(CXX) -o $(BUILD_OBJECT) $^ $(I_FLAGS) $(L_FLAGS) $(LIBRARIES) format: astyle -n --style=google --recursive src/*.cpp src/*.h clean: ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") del $(BUILD_OBJECT) endif $(foreach object, $(OBJ) $(OBJ_C), @del $(subst /,\\, $(object));) run: ./$(BUILD_OBJECT) One other thing to note is that astyle is used for formatting c++ code.","title":"Build"},{"location":"getting_started/embedding_python/#hello-world-embedded-python-edition","text":"It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation from python for embedding can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main(int argv, char** args) { Py_SetProgramName(L\"learn_engine_dev\"); Py_Initialize(); PyRun_SimpleString(\"print('hello world (from python)')\"); Py_Finalize(); return 0; } This should print out 'hello world (from python)' . There's a few things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print('hello world (from python)') Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better. You can check you code by looking at the source here . We will want to execute scripts and functions from our engine and also be able to call functions within our engine from a python script. We will get to that soon, but next we will create a helper class to help make embedding python easier.","title":"Hello World Embedded Python Edition"},{"location":"getting_started/embedding_python/#pyhelper-class","text":"Coming soon. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public: CPyInstance() { Py_SetProgramName(L\"learn_engine_dev\"); Py_Initialize(); } ~CPyInstance() { Py_Finalize(); } }; class CPyObject { private: PyObject* pyObj; public: CPyObject(): pyObj(nullptr) {} CPyObject(PyObject* p) : pyObj(p) {} ~CPyObject() { Release(); } PyObject* GetObj() { return pyObj; } PyObject* SetObj(PyObject* p) { return (pyObj=p); } PyObject* AddRef() { if(pyObj) { Py_INCREF(pyObj); } return pyObj; } void Release() { if(pyObj) { Py_DECREF(pyObj); } pyObj = nullptr; } PyObject* operator->() { return pyObj; } bool Is() const { return pyObj ? true : false; } operator PyObject*() { return pyObj; } PyObject* operator=(PyObject* p) { pyObj = p; return pyObj; } }; #endif //PYHELPER_HPP","title":"PyHelper Class"},{"location":"source_code/source_code/","text":"Source Code The full source code of the tutorials are on github and can be found here .","title":"Source Code"},{"location":"source_code/source_code/#source-code","text":"The full source code of the tutorials are on github and can be found here .","title":"Source Code"}]}