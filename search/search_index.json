{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To Learn Engine Dev About Welcome to a tutorial series for creating a simple game engine from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future. Prerequisites Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL. Structure Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Tech Stack The engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic","title":"Introduction"},{"location":"#welcome-to-learn-engine-dev","text":"","title":"Welcome To Learn Engine Dev"},{"location":"#about","text":"Welcome to a tutorial series for creating a simple game engine from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future.","title":"About"},{"location":"#prerequisites","text":"Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL.","title":"Prerequisites"},{"location":"#structure","text":"Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo .","title":"Structure"},{"location":"#tech-stack","text":"The engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic","title":"Tech Stack"},{"location":"embedding_python/embedding_further/","text":"Embedding Further PyHelper Class So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { private : PyObject * pyObj ; public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here . Creating A Python Instance in C++ We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid foundation for python scripting it's time to take a dip in the world of rendering with OpenGL.","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#embedding-further","text":"","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#pyhelper-class","text":"So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { private : PyObject * pyObj ; public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here .","title":"PyHelper Class"},{"location":"embedding_python/embedding_further/#creating-a-python-instance-in-c","text":"We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid foundation for python scripting it's time to take a dip in the world of rendering with OpenGL.","title":"Creating A Python Instance in C++"},{"location":"embedding_python/hello_python/","text":"Hello Python Dependencies For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the learn_engine_dev executable. Build For building the engine in a cross platform way we will be using make . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := learn_engine_dev # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" C_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard *.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( C_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif $( foreach object, $( OBJ ) , @ $( DELETE_CMD ) $( subst /, \\, $( object )) ; ) run : ./ $( BUILD_OBJECT ) Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55. Hello World It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better. You view the code by looking at the source here . We will want to execute scripts and python functions from our engine and also be able to call c++ functions from a python script. Let's work on that next! Execute A Python Function From C++ Executing python statements with PyRun_SimpleString is simple but it won't scale well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in c++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into our engine and create classes to generalize some of our usages of the Python API.","title":"Hello Python"},{"location":"embedding_python/hello_python/#hello-python","text":"","title":"Hello Python"},{"location":"embedding_python/hello_python/#dependencies","text":"For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the learn_engine_dev executable.","title":"Dependencies"},{"location":"embedding_python/hello_python/#build","text":"For building the engine in a cross platform way we will be using make . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := learn_engine_dev # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" C_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard *.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( C_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif $( foreach object, $( OBJ ) , @ $( DELETE_CMD ) $( subst /, \\, $( object )) ; ) run : ./ $( BUILD_OBJECT ) Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55.","title":"Build"},{"location":"embedding_python/hello_python/#hello-world","text":"It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better. You view the code by looking at the source here . We will want to execute scripts and python functions from our engine and also be able to call c++ functions from a python script. Let's work on that next!","title":"Hello World"},{"location":"embedding_python/hello_python/#execute-a-python-function-from-c","text":"Executing python statements with PyRun_SimpleString is simple but it won't scale well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in c++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into our engine and create classes to generalize some of our usages of the Python API.","title":"Execute A Python Function From C++"},{"location":"entity_component_system/building_an_ecs/","text":"Building An ECS Coming soon.","title":"Building An ECS"},{"location":"entity_component_system/building_an_ecs/#building-an-ecs","text":"Coming soon.","title":"Building An ECS"},{"location":"implementing_audio/using_sdl_mixer/","text":"Using SDL_mixer Coming soon.","title":"Using SDL_mixer"},{"location":"implementing_audio/using_sdl_mixer/#using-sdl_mixer","text":"Coming soon.","title":"Using SDL_mixer"},{"location":"opengl_rendering/creating_a_renderer/","text":"Getting Started Coming soon.","title":"Creating A Renderer"},{"location":"opengl_rendering/creating_a_renderer/#getting-started","text":"Coming soon.","title":"Getting Started"},{"location":"serializing_with_json/parsing_json/","text":"Parsing JSON Coming soon.","title":"Parsing JSON"},{"location":"serializing_with_json/parsing_json/#parsing-json","text":"Coming soon.","title":"Parsing JSON"},{"location":"source_code/source_code/","text":"Source Code The full source code of the tutorials are on github and can be found here .","title":"Source Code"},{"location":"source_code/source_code/#source-code","text":"The full source code of the tutorials are on github and can be found here .","title":"Source Code"}]}