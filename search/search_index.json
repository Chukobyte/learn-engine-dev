{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To Learn Engine Dev About Welcome to a tutorial series for creating a simple game engine, named Red Engine , from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future. Purpose The purpose of this tutorial series is to provide a step-by-step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with Red Engine to test it out! Prerequisites Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL. Structure There are a total of three parts to this tutorial series which are split in multiple chapters. Each chapter is further broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Code will need to be shared between each project folder and a game library will be created in include/re . Typically, code that is created within a chapter is moved into the game library once it's implementation is completed within the sections. Tech Stack Red Engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code Features Red Engine will have the following features: Sprite rendering Font rendering Keyboard, mouse, and joystick input management Python scripting Entity Component System Scene management Json serialization of project properties and scene data Work In Progress This tutorial series is not yet complete so expect incomplete chapters and sections. The source code for each chapter will come first followed by more detailed descriptions and information for each section. Also builds for windows are typically done first before linux, so expect delays in updating the Makefiles for linux in later chapters. Feedback Feedback is greatly appreciated! One way to submit feedback is to open up an issue in github and apply an appropriate label. If you like what this project is doing consider starring the Learn Engine Dev github repo .","title":"Introduction"},{"location":"#welcome-to-learn-engine-dev","text":"","title":"Welcome To Learn Engine Dev"},{"location":"#about","text":"Welcome to a tutorial series for creating a simple game engine, named Red Engine , from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future.","title":"About"},{"location":"#purpose","text":"The purpose of this tutorial series is to provide a step-by-step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with Red Engine to test it out!","title":"Purpose"},{"location":"#prerequisites","text":"Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL.","title":"Prerequisites"},{"location":"#structure","text":"There are a total of three parts to this tutorial series which are split in multiple chapters. Each chapter is further broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Code will need to be shared between each project folder and a game library will be created in include/re . Typically, code that is created within a chapter is moved into the game library once it's implementation is completed within the sections.","title":"Structure"},{"location":"#tech-stack","text":"Red Engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code","title":"Tech Stack"},{"location":"#features","text":"Red Engine will have the following features: Sprite rendering Font rendering Keyboard, mouse, and joystick input management Python scripting Entity Component System Scene management Json serialization of project properties and scene data","title":"Features"},{"location":"#work-in-progress","text":"This tutorial series is not yet complete so expect incomplete chapters and sections. The source code for each chapter will come first followed by more detailed descriptions and information for each section. Also builds for windows are typically done first before linux, so expect delays in updating the Makefiles for linux in later chapters.","title":"Work In Progress"},{"location":"#feedback","text":"Feedback is greatly appreciated! One way to submit feedback is to open up an issue in github and apply an appropriate label. If you like what this project is doing consider starring the Learn Engine Dev github repo .","title":"Feedback"},{"location":"1.foundation/1.embedding_python/custom_python_module/","text":"Custom Python Module Creating a Game Library There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/re . With that being said we will move our python code (including from the previous section) into ./include/re/python . Python Modules Class We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining the api for Red Engine . To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents the version of Red Engine . Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./re/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Custom Python Module"},{"location":"1.foundation/1.embedding_python/custom_python_module/#custom-python-module","text":"","title":"Custom Python Module"},{"location":"1.foundation/1.embedding_python/custom_python_module/#creating-a-game-library","text":"There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/re . With that being said we will move our python code (including from the previous section) into ./include/re/python .","title":"Creating a Game Library"},{"location":"1.foundation/1.embedding_python/custom_python_module/#python-modules-class","text":"We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining the api for Red Engine . To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents the version of Red Engine . Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./re/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Python Modules Class"},{"location":"1.foundation/1.embedding_python/embedding_further/","text":"Embedding Further PyHelper Class So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } private : PyObject * pyObj ; }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here . Creating A Python Instance in C++ We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call the Red Engine api from within python scripts.","title":"Embedding Further"},{"location":"1.foundation/1.embedding_python/embedding_further/#embedding-further","text":"","title":"Embedding Further"},{"location":"1.foundation/1.embedding_python/embedding_further/#pyhelper-class","text":"So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } private : PyObject * pyObj ; }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here .","title":"PyHelper Class"},{"location":"1.foundation/1.embedding_python/embedding_further/#creating-a-python-instance-in-c","text":"We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call the Red Engine api from within python scripts.","title":"Creating A Python Instance in C++"},{"location":"1.foundation/1.embedding_python/hello_python/","text":"Hello Python Dependencies For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the red_engine executable. Build For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := red_engine # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : @./ $( BUILD_OBJECT ) format : @astyle -n --style = google --recursive src/*.cpp # Adds debug symbols for debugger debug-build : C_FLAGS += - g debug-build : build Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55. Hello World It's time to finally write python code within Red Engine ! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from Red Engine and also be able to call C++ functions from a python script. Let's work on that next! Execute A Python Function From C++ Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into Red Engine and create classes to generalize some of our usages of the Python API.","title":"Hello Python"},{"location":"1.foundation/1.embedding_python/hello_python/#hello-python","text":"","title":"Hello Python"},{"location":"1.foundation/1.embedding_python/hello_python/#dependencies","text":"For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the red_engine executable.","title":"Dependencies"},{"location":"1.foundation/1.embedding_python/hello_python/#build","text":"For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := red_engine # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : @./ $( BUILD_OBJECT ) format : @astyle -n --style = google --recursive src/*.cpp # Adds debug symbols for debugger debug-build : C_FLAGS += - g debug-build : build Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55.","title":"Build"},{"location":"1.foundation/1.embedding_python/hello_python/#hello-world","text":"It's time to finally write python code within Red Engine ! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from Red Engine and also be able to call C++ functions from a python script. Let's work on that next!","title":"Hello World"},{"location":"1.foundation/1.embedding_python/hello_python/#execute-a-python-function-from-c","text":"Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into Red Engine and create classes to generalize some of our usages of the Python API.","title":"Execute A Python Function From C++"},{"location":"1.foundation/2.game_loop_and_sdl/game_loop_introduction/","text":"Game Loop Introduction Game Loop Before we start adding other systems to Red Engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so. Logger As we add more functionality and systems to the game it will be useful to make logging statements for debugging, error, etc... The Logger class will be used for this purpose throughout Red Engine . #ifndef LOGGER_H #define LOGGER_H #include <string> enum class LogLevel : unsigned int { DEBUG = 0 , WARN = 1 , INFO = 2 , ERROR = 3 , }; class Logger { public : LogLevel logLevel = LogLevel :: DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; private : Logger () = default ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel :: DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel :: WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel :: INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel :: ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs. Engine Context EngineContext will store engine related properties and state. There will be parts of Red Engine that need access to properties such as if the game engine is running or the engine's name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Red\" ; bool running = false ; GameEngineContext () = default ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Game Loop Introduction"},{"location":"1.foundation/2.game_loop_and_sdl/game_loop_introduction/#game-loop-introduction","text":"","title":"Game Loop Introduction"},{"location":"1.foundation/2.game_loop_and_sdl/game_loop_introduction/#game-loop","text":"Before we start adding other systems to Red Engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so.","title":"Game Loop"},{"location":"1.foundation/2.game_loop_and_sdl/game_loop_introduction/#logger","text":"As we add more functionality and systems to the game it will be useful to make logging statements for debugging, error, etc... The Logger class will be used for this purpose throughout Red Engine . #ifndef LOGGER_H #define LOGGER_H #include <string> enum class LogLevel : unsigned int { DEBUG = 0 , WARN = 1 , INFO = 2 , ERROR = 3 , }; class Logger { public : LogLevel logLevel = LogLevel :: DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; private : Logger () = default ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel :: DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel :: WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel :: INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel :: ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs.","title":"Logger"},{"location":"1.foundation/2.game_loop_and_sdl/game_loop_introduction/#engine-context","text":"EngineContext will store engine related properties and state. There will be parts of Red Engine that need access to properties such as if the game engine is running or the engine's name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Red\" ; bool running = false ; GameEngineContext () = default ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Engine Context"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/","text":"Initialize SDL GameEngine Class The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include \"fps_counter.h\" #include \"./re/utils/logger.h\" class GameEngine { public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; private : GameEngineContext * engineContext = nullptr ; FPSCounter * fpsCounter = nullptr ; Logger * logger = nullptr ; bool Initialize (); bool InitializeSDL (); }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } bool GameEngine :: Initialize () { if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); return true ; } bool GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return false ; } return true ; } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running. Main Loop Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Red Engine v0.1.0 [INFO] Red Engine has shut down! Measuring FPS Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes. Timer The Timer class is straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { public : Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop = false ); Timer ( float waitTimeInSeconds , bool doesLoop = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); void SetWaitTime ( float waitTimeInSeconds ); bool DoesLoop () const ; void SetLoop ( bool doesLoop ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; private : Uint32 waitTime ; bool loops ; Uint32 startTicks = 0 ; Uint32 pausedTicks = 0 ; bool isPaused = false ; bool hasStarted = false ; }; #endif //TIMER_H #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop ) : waitTime ( waitTimeInMilliseconds ), loops ( doesLoop ) {} Timer :: Timer ( float waitTimeInSeconds , bool doesLoop ) : Timer ( static_cast < Uint32 > ( waitTimeInSeconds * 1000 ), doesLoop ) {} Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } void Timer :: SetWaitTime ( float waitTimeInSeconds ) { SetWaitTime ( static_cast < Uint32 > ( waitTimeInSeconds * 1000 )); } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool doesLoop ) { loops = doesLoop ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next! FPS Counter #ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./re/utils/timer.h\" class FPSCounter { public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./re/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we run Red Engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"Initialize SDL"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#initialize-sdl","text":"","title":"Initialize SDL"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#gameengine-class","text":"The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include \"fps_counter.h\" #include \"./re/utils/logger.h\" class GameEngine { public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; private : GameEngineContext * engineContext = nullptr ; FPSCounter * fpsCounter = nullptr ; Logger * logger = nullptr ; bool Initialize (); bool InitializeSDL (); }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } bool GameEngine :: Initialize () { if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); return true ; } bool GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return false ; } return true ; } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running.","title":"GameEngine Class"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#main-loop","text":"Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Red Engine v0.1.0 [INFO] Red Engine has shut down!","title":"Main Loop"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#measuring-fps","text":"Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes.","title":"Measuring FPS"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#timer","text":"The Timer class is straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { public : Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop = false ); Timer ( float waitTimeInSeconds , bool doesLoop = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); void SetWaitTime ( float waitTimeInSeconds ); bool DoesLoop () const ; void SetLoop ( bool doesLoop ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; private : Uint32 waitTime ; bool loops ; Uint32 startTicks = 0 ; Uint32 pausedTicks = 0 ; bool isPaused = false ; bool hasStarted = false ; }; #endif //TIMER_H #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop ) : waitTime ( waitTimeInMilliseconds ), loops ( doesLoop ) {} Timer :: Timer ( float waitTimeInSeconds , bool doesLoop ) : Timer ( static_cast < Uint32 > ( waitTimeInSeconds * 1000 ), doesLoop ) {} Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } void Timer :: SetWaitTime ( float waitTimeInSeconds ) { SetWaitTime ( static_cast < Uint32 > ( waitTimeInSeconds * 1000 )); } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool doesLoop ) { loops = doesLoop ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next!","title":"Timer"},{"location":"1.foundation/2.game_loop_and_sdl/initialize_sdl/#fps-counter","text":"#ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./re/utils/timer.h\" class FPSCounter { public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./re/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we run Red Engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"FPS Counter"},{"location":"1.foundation/3.opengl_rendering/asset_management/","text":"Asset Management Textures Glad As you already know, we will be using the OpenGL graphics API for our renderer. Glad , which is an OpenGL loading library, will be used to by Red Engine to access OpenGL functions. We will modify the build of the engine by adding the generated glad.c file to Makefile. SRC_C = $( wildcard $( INCLUDE_DIR ) /glad/glad.c ) stb_image stb_image is an image loading library which is part of a larger library named stb . All functions from the stb_image library will have the prefix stbi_ . Texture Class Instances of the Texture class will be used to render sprites to the screen. #ifndef TEXTURE_H #define TEXTURE_H #include <glad/glad.h> #include \"../utils/logger.h\" class Texture { public : Texture ( const char * filePath , unsigned int wrapS = GL_CLAMP_TO_BORDER , unsigned int wrapT = GL_CLAMP_TO_BORDER , unsigned int filterMin = GL_NEAREST , unsigned int filterMag = GL_NEAREST ); Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ); ~ Texture (); void Bind () const ; std :: string GetFilePath () const ; int GetWidth () const ; int GetHeight () const ; unsigned int GetImageFormat () const ; unsigned char * GetData () const ; bool IsValid () const ; private : Logger * logger = nullptr ; std :: string fileName ; GLuint ID = 0 ; unsigned char * data = nullptr ; int width = 0 ; int height = 0 ; int nrChannels = 0 ; // format unsigned int internalFormat = GL_RGBA ; unsigned int imageFormat = GL_RGBA ; // configuration unsigned int wrapS = GL_CLAMP_TO_BORDER ; unsigned int wrapT = GL_CLAMP_TO_BORDER ; unsigned int filterMin = GL_NEAREST ; unsigned int filterMag = GL_NEAREST ; void Generate (); unsigned int GetWrapFromString ( const std :: string & wrap ) const ; unsigned int GetFilterFromString ( const std :: string & filter ) const ; }; #endif //TEXTURE_H #include \"texture.h\" #include <stb_image/stb_image.h> Texture :: Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ) : wrapS ( wrapS ), wrapT ( wrapT ), filterMin ( filterMin ), filterMag ( filterMag ), logger ( Logger :: GetInstance ()) { fileName = std :: string ( filePath ); // load image, create texture, and generate mipmaps stbi_set_flip_vertically_on_load ( false ); data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); if ( IsValid ()) { Generate (); } else { logger -> Error ( \"Texture failed to load at: %s\" , filePath ); } } Texture :: Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ) : Texture ( filePath , GetWrapFromString ( wrapS ), GetWrapFromString ( wrapT ), GetFilterFromString ( filterMin ), GetFilterFromString ( filterMag ) ) {} Texture ::~ Texture () { stbi_image_free ( data ); data = nullptr ; } void Texture :: Generate () { if ( nrChannels == 1 ) { imageFormat = GL_RED ; } else if ( nrChannels == 3 ) { imageFormat = GL_RGB ; } else if ( nrChannels == 4 ) { imageFormat = GL_RGBA ; } // Create texture glGenTextures ( 1 , & ID ); Bind (); glTexImage2D ( GL_TEXTURE_2D , 0 , internalFormat , width , height , 0 , imageFormat , GL_UNSIGNED_BYTE , data ); glGenerateMipmap ( GL_TEXTURE_2D ); // Wrap and filter modes glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , wrapS ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , wrapT ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , filterMin ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , filterMag ); // Unbind texture glBindTexture ( GL_TEXTURE_2D , 0 ); } unsigned int Texture :: GetWrapFromString ( const std :: string & wrap ) const { if ( wrap == \"clamp_to_border\" ) { return GL_CLAMP_TO_BORDER ; } else if ( wrap == \"clamp_to_edge\" ) { return GL_CLAMP_TO_EDGE ; } else if ( wrap == \"repeat\" ) { return GL_REPEAT ; } else if ( wrap == \"mirrored_repeat\" ) { return GL_MIRRORED_REPEAT ; } logger -> Error ( \"'%s' is an invalid wrap value!\" , wrap . c_str ()); return wrapS ; } unsigned int Texture :: GetFilterFromString ( const std :: string & filter ) const { if ( filter == \"nearest\" ) { return GL_NEAREST ; } else if ( filter == \"linear\" ) { return GL_LINEAR ; } logger -> Error ( \"'%s' is an invalid filter value!\" , filter . c_str ()); return filterMin ; } void Texture :: Bind () const { glBindTexture ( GL_TEXTURE_2D , ID ); } std :: string Texture :: GetFilePath () const { return fileName ; } int Texture :: GetWidth () const { return width ; } int Texture :: GetHeight () const { return height ; } unsigned int Texture :: GetImageFormat () const { return imageFormat ; } unsigned char * Texture :: GetData () const { return data ; } bool Texture :: IsValid () const { if ( data ) { return true ; } return false ; } The Texture class has quite a few member variables. fileName is just the file path of the texture file. data is the texture data in memory. width and height are self explanatory. nrChannels represent the number of color channels. internalFormat specifies the number of color components in the texture. imageFormat is set based on the number of color channels for the loaded texture. wrapS and wrapT refers to the texture wrapping mode applied to the S and T axis. Below are the 4 possible values: GL_REPEAT : The default behavior for textures. Repeats the texture image. GL_MIRRORED_REPEAT : Same as GL_REPEAT but mirrors the image with each repeat. GL_CLAMP_TO_EDGE : Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern. GL_CLAMP_TO_BORDER : Coordinates outside the range are now given a user-specified border color. filterMin and filterMag refers to the texture filtering mode. Below are the possible values: GL_NEAREST : OpenGL selects the texel that center is closest to the texture coordinate. Ideal for pixel art games. GL_LINEAR : OpenGL takes an interpolated value from the texture coordinate's neighboring texel. The Initialize function is called by both constructors. Texture data is loaded by stb_image library with the following line: data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); If the texture is loaded successfully, the Generate function is called. This function configures the texture for OpenGL. The only other function to point out is the Bind function which we'll get into once we start rendering textures. Asset Manager Now that we have the concept of a texture defined in Red Engine , we will need something to maintain textures as well as other assets. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" class AssetManager { public : static AssetManager * GetInstance (); void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; private : std :: unordered_map < std :: string , Texture *> textures ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H #include \"asset_manager.h\" #include <cassert> AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()) {} AssetManager * AssetManager :: GetInstance () { static AssetManager * instance = new AssetManager (); return instance ; } void AssetManager :: LoadTexture ( const std :: string & id , const std :: string & filePath ) { Texture * texture = new Texture ( filePath . c_str ()); assert ( texture -> IsValid () && \"Failed to load texture!\" ); if ( HasTexture ( id )) { logger -> Warn ( \"Already have texture, not loading...\" ); return ; } textures . emplace ( id , texture ); } Texture * AssetManager :: GetTexture ( const std :: string & id ) { assert ( HasTexture ( id ) && \"Failed to get texture!\" ); return textures [ id ]; } bool AssetManager :: HasTexture ( const std :: string & id ) const { return textures . count ( id ) > 0 ; } The AssetManager class is a singleton with 3 functions to pay attention to. LoadTexture loads a new instance of the Texture class and places it in the textures map. GetTexture just retrieves a texture by id from the map. And HasTexture checks to see if the texture is stored by AssetManager . Other assets will follow the same 3 function pattern as textures and will be discussed in a later section.","title":"Asset Management"},{"location":"1.foundation/3.opengl_rendering/asset_management/#asset-management","text":"","title":"Asset Management"},{"location":"1.foundation/3.opengl_rendering/asset_management/#textures","text":"","title":"Textures"},{"location":"1.foundation/3.opengl_rendering/asset_management/#glad","text":"As you already know, we will be using the OpenGL graphics API for our renderer. Glad , which is an OpenGL loading library, will be used to by Red Engine to access OpenGL functions. We will modify the build of the engine by adding the generated glad.c file to Makefile. SRC_C = $( wildcard $( INCLUDE_DIR ) /glad/glad.c )","title":"Glad"},{"location":"1.foundation/3.opengl_rendering/asset_management/#stb_image","text":"stb_image is an image loading library which is part of a larger library named stb . All functions from the stb_image library will have the prefix stbi_ .","title":"stb_image"},{"location":"1.foundation/3.opengl_rendering/asset_management/#texture-class","text":"Instances of the Texture class will be used to render sprites to the screen. #ifndef TEXTURE_H #define TEXTURE_H #include <glad/glad.h> #include \"../utils/logger.h\" class Texture { public : Texture ( const char * filePath , unsigned int wrapS = GL_CLAMP_TO_BORDER , unsigned int wrapT = GL_CLAMP_TO_BORDER , unsigned int filterMin = GL_NEAREST , unsigned int filterMag = GL_NEAREST ); Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ); ~ Texture (); void Bind () const ; std :: string GetFilePath () const ; int GetWidth () const ; int GetHeight () const ; unsigned int GetImageFormat () const ; unsigned char * GetData () const ; bool IsValid () const ; private : Logger * logger = nullptr ; std :: string fileName ; GLuint ID = 0 ; unsigned char * data = nullptr ; int width = 0 ; int height = 0 ; int nrChannels = 0 ; // format unsigned int internalFormat = GL_RGBA ; unsigned int imageFormat = GL_RGBA ; // configuration unsigned int wrapS = GL_CLAMP_TO_BORDER ; unsigned int wrapT = GL_CLAMP_TO_BORDER ; unsigned int filterMin = GL_NEAREST ; unsigned int filterMag = GL_NEAREST ; void Generate (); unsigned int GetWrapFromString ( const std :: string & wrap ) const ; unsigned int GetFilterFromString ( const std :: string & filter ) const ; }; #endif //TEXTURE_H #include \"texture.h\" #include <stb_image/stb_image.h> Texture :: Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ) : wrapS ( wrapS ), wrapT ( wrapT ), filterMin ( filterMin ), filterMag ( filterMag ), logger ( Logger :: GetInstance ()) { fileName = std :: string ( filePath ); // load image, create texture, and generate mipmaps stbi_set_flip_vertically_on_load ( false ); data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); if ( IsValid ()) { Generate (); } else { logger -> Error ( \"Texture failed to load at: %s\" , filePath ); } } Texture :: Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ) : Texture ( filePath , GetWrapFromString ( wrapS ), GetWrapFromString ( wrapT ), GetFilterFromString ( filterMin ), GetFilterFromString ( filterMag ) ) {} Texture ::~ Texture () { stbi_image_free ( data ); data = nullptr ; } void Texture :: Generate () { if ( nrChannels == 1 ) { imageFormat = GL_RED ; } else if ( nrChannels == 3 ) { imageFormat = GL_RGB ; } else if ( nrChannels == 4 ) { imageFormat = GL_RGBA ; } // Create texture glGenTextures ( 1 , & ID ); Bind (); glTexImage2D ( GL_TEXTURE_2D , 0 , internalFormat , width , height , 0 , imageFormat , GL_UNSIGNED_BYTE , data ); glGenerateMipmap ( GL_TEXTURE_2D ); // Wrap and filter modes glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , wrapS ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , wrapT ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , filterMin ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , filterMag ); // Unbind texture glBindTexture ( GL_TEXTURE_2D , 0 ); } unsigned int Texture :: GetWrapFromString ( const std :: string & wrap ) const { if ( wrap == \"clamp_to_border\" ) { return GL_CLAMP_TO_BORDER ; } else if ( wrap == \"clamp_to_edge\" ) { return GL_CLAMP_TO_EDGE ; } else if ( wrap == \"repeat\" ) { return GL_REPEAT ; } else if ( wrap == \"mirrored_repeat\" ) { return GL_MIRRORED_REPEAT ; } logger -> Error ( \"'%s' is an invalid wrap value!\" , wrap . c_str ()); return wrapS ; } unsigned int Texture :: GetFilterFromString ( const std :: string & filter ) const { if ( filter == \"nearest\" ) { return GL_NEAREST ; } else if ( filter == \"linear\" ) { return GL_LINEAR ; } logger -> Error ( \"'%s' is an invalid filter value!\" , filter . c_str ()); return filterMin ; } void Texture :: Bind () const { glBindTexture ( GL_TEXTURE_2D , ID ); } std :: string Texture :: GetFilePath () const { return fileName ; } int Texture :: GetWidth () const { return width ; } int Texture :: GetHeight () const { return height ; } unsigned int Texture :: GetImageFormat () const { return imageFormat ; } unsigned char * Texture :: GetData () const { return data ; } bool Texture :: IsValid () const { if ( data ) { return true ; } return false ; } The Texture class has quite a few member variables. fileName is just the file path of the texture file. data is the texture data in memory. width and height are self explanatory. nrChannels represent the number of color channels. internalFormat specifies the number of color components in the texture. imageFormat is set based on the number of color channels for the loaded texture. wrapS and wrapT refers to the texture wrapping mode applied to the S and T axis. Below are the 4 possible values: GL_REPEAT : The default behavior for textures. Repeats the texture image. GL_MIRRORED_REPEAT : Same as GL_REPEAT but mirrors the image with each repeat. GL_CLAMP_TO_EDGE : Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern. GL_CLAMP_TO_BORDER : Coordinates outside the range are now given a user-specified border color. filterMin and filterMag refers to the texture filtering mode. Below are the possible values: GL_NEAREST : OpenGL selects the texel that center is closest to the texture coordinate. Ideal for pixel art games. GL_LINEAR : OpenGL takes an interpolated value from the texture coordinate's neighboring texel. The Initialize function is called by both constructors. Texture data is loaded by stb_image library with the following line: data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); If the texture is loaded successfully, the Generate function is called. This function configures the texture for OpenGL. The only other function to point out is the Bind function which we'll get into once we start rendering textures.","title":"Texture Class"},{"location":"1.foundation/3.opengl_rendering/asset_management/#asset-manager","text":"Now that we have the concept of a texture defined in Red Engine , we will need something to maintain textures as well as other assets. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" class AssetManager { public : static AssetManager * GetInstance (); void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; private : std :: unordered_map < std :: string , Texture *> textures ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H #include \"asset_manager.h\" #include <cassert> AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()) {} AssetManager * AssetManager :: GetInstance () { static AssetManager * instance = new AssetManager (); return instance ; } void AssetManager :: LoadTexture ( const std :: string & id , const std :: string & filePath ) { Texture * texture = new Texture ( filePath . c_str ()); assert ( texture -> IsValid () && \"Failed to load texture!\" ); if ( HasTexture ( id )) { logger -> Warn ( \"Already have texture, not loading...\" ); return ; } textures . emplace ( id , texture ); } Texture * AssetManager :: GetTexture ( const std :: string & id ) { assert ( HasTexture ( id ) && \"Failed to get texture!\" ); return textures [ id ]; } bool AssetManager :: HasTexture ( const std :: string & id ) const { return textures . count ( id ) > 0 ; } The AssetManager class is a singleton with 3 functions to pay attention to. LoadTexture loads a new instance of the Texture class and places it in the textures map. GetTexture just retrieves a texture by id from the map. And HasTexture checks to see if the texture is stored by AssetManager . Other assets will follow the same 3 function pattern as textures and will be discussed in a later section.","title":"Asset Manager"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/","text":"Rendering Sprites Math Lib GLM GLM is a header only math library based on the OpenGL Shading Language (GLSL) specifications. Most things related to math such as vectors, matrices, etc... will be handled by GLM. Rectangle The Rectangle class will mostly be used for defining the bounds of a sprite's draw source and draw destination which we'll get to later. #ifndef RECTANGLE_H #define RECTANGLE_H #include <iostream> #include <glm/glm.hpp> class Rectangle { public : float x ; float y ; float w ; float h ; Rectangle () : x ( 0.0f ), y ( 0.0f ), w ( 0.0f ), h ( 0.0f ) {} Rectangle ( float x , float y , float w , float h ) : x ( x ), y ( y ), w ( w ), h ( h ) {} Rectangle ( float x , float y , glm :: vec2 size ) : x ( x ), y ( y ), w ( size . x ), h ( size . y ) {} Rectangle ( glm :: vec2 position , glm :: vec2 size ) : x ( position . x ), y ( position . y ), w ( size . x ), h ( size . y ) {} bool operator == ( const Rectangle & otherRect2 ) const { return this -> x == otherRect2 . x && this -> y == otherRect2 . y && this -> w == otherRect2 . w && this -> h == otherRect2 . h ; } bool operator != ( const Rectangle & otherRect2 ) const { return ! ( * this == otherRect2 ); } friend std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ); }; #endif //RECTANGLE_H #include \"rectangle.h\" std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ) { os << \"(\" << r . x << \", \" << r . y << \", \" << r . w << \", \" << r . h << \")\" ; return os ; } Custom Math Header Red Engine will use GLM, but we may want to use another math library or write our own in the future. To make this easier, will we define type aliases for math related classes. #ifndef MATH_H #define MATH_H #include \"rectangle.h\" using Vector2 = glm :: vec2 ; using IVector2 = glm :: ivec2 ; using Vector3 = glm :: vec3 ; using Matrix4 = glm :: mat4 ; using Rect2 = Rectangle ; #endif //MATH_H Color Not much to explain other than needing a concept of color within the engine. #ifndef COLOR_H #define COLOR_H #include <glad/glad.h> class Color { public : float r = 1.0f ; float g = 1.0f ; float b = 1.0f ; float a = 1.0f ; Color () {} Color ( GLfloat red , GLfloat green , GLfloat blue ) : r ( red ), g ( green ), b ( blue ), a ( 1.0f ) {} Color ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) : r ( red ), g ( green ), b ( blue ), a ( alpha ) {} Color operator * ( float value ) { return Color ( this -> r * value , this -> g * value , this -> b * value , this -> a ); } }; #endif //COLOR_H Renderer Batcher The RendererBatcher class will be used to take draw calls and batch them to be used during rendering. Typically, batching is done to limit draw calls for efficiency and performance reasons but for simplicity\u2019s sake this batcher will be designed to just defer and submit draw calls during the Render phase. #ifndef RENDERER_BATCHER_H #define RENDERER_BATCHER_H #include <vector> #include <map> #include <string> #include <functional> #include \"./re/rendering/color.h\" #include \"./re/rendering/texture.h\" #include \"./re/math/math.h\" struct SpriteBatchItem { Texture * texture2D = nullptr ; Rect2 sourceRectangle ; Rect2 destinationRectangle ; float rotation = 0.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); bool flipX = false ; bool flipY = false ; }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; }; using RenderFlushFunction = std :: function < void ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) > ; class RendererBatcher { public : void BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ); void Flush ( const RenderFlushFunction & renderFlushFunction ); private : std :: map < int , ZIndexDrawBatch > drawBatches ; }; #endif //RENDERER_BATCHER_H #include \"./renderer_batcher.h\" void RendererBatcher::BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. spriteDrawBatches . emplace_back ( spriteBatchItem ); } void RendererBatcher::Flush ( const RenderFlushFunction & renderFlushFunction ) { for ( const auto & pair : drawBatches ) { const int zIndex = pair . first ; const ZIndexDrawBatch & zIndexDrawBatch = pair . second ; renderFlushFunction ( zIndex , zIndexDrawBatch ); } drawBatches . clear (); } The first thing to point out is the SpriteBatchItem struct as this will be used to determine what to render for a sprite. Red Engine will group draw batches by their z indices. The ZIndexDrawBatch struct will represent a draw batch for a particular z index. We also define an alias RenderFlushFunction to be used as a lambda function to render flushed draw batches by the Renderer which we'll get to later. RendererBatcher class is currently simple as it has one map and two functions. The drawBatches map maintains the order of draw batches based on their z indices. BatchDrawSprite will submit a batch item to the batcher to draw during the render phase. The Flush function is called during the render phase to render batch items submitted and will clear them when completed. 2D Rendering Shaders What are shaders? They are simply GPU programs, in the case of OpenGL written in GLSL (OpenGL Shading Language). Before we write the renderer for Red Engine we'll first implement the Shader class which will compile shaders, install the shaders for use, and set uniform variables . A shader can be written for each of the shader stages , but we will only use vertex and fragment shaders in Red Engine . #ifndef SHADER_H #define SHADER_H #include <string> #include <fstream> #include <sstream> #include <iostream> #include <glad/glad.h> #include \"../math/math.h\" #include \"./color.h\" #include \"../utils/logger.h\" struct OpenGLShaderSourceCode { std :: string vertex ; std :: string fragment ; }; class Shader { public : Shader (); Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ); Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ); ~ Shader (); OpenGLShaderSourceCode GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ); void Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ); void Use (); void SetBool ( const std :: string & name , bool value ) const ; void SetInt ( const std :: string & name , int value ) const ; void SetFloat ( const std :: string & name , float value ) const ; void SetVec2Float ( const std :: string & name , float v1 , float v2 ) const ; void SetVec2Float ( const std :: string & name , const Vector2 & value ) const ; void SetVec3Float ( const std :: string & name , const Color & value ) const ; void SetVec3Float ( const std :: string & name , const Vector3 & value ) const ; void SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const ; void SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const ; void SetVec4Float ( const std :: string & name , const Color & value ) const ; void SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const ; private : unsigned int ID ; Logger * logger = nullptr ; bool IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ); void CheckCompileErrors ( unsigned int shader , const std :: string & type ); }; #endif //SHADER_H #include \"shader.h\" #include <cassert> #include <glm/gtc/type_ptr.hpp> #include \"../utils/file_helper.h\" Shader :: Shader () : logger ( Logger :: GetInstance ()) {} Shader :: Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ) : logger ( Logger :: GetInstance ()) { Compile ( GetOpenGLShaderSourceFromPaths ( vertexPath , fragmentPath )); } Shader :: Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ) : logger ( Logger :: GetInstance ()) { Compile ( openGlShaderSourceCode ); } Shader ::~ Shader () {} OpenGLShaderSourceCode Shader :: GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ) { OpenGLShaderSourceCode openGlShaderSourceCode ; if ( IsShaderFilesValid ( vertexPath , fragmentPath )) { std :: ifstream vertexShaderFile ; std :: ifstream fragmentShaderFile ; vertexShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); fragmentShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); try { vertexShaderFile . open ( vertexPath . c_str ()); fragmentShaderFile . open ( fragmentPath . c_str ()); std :: stringstream vertexShaderStream , fragmentShaderStream ; vertexShaderStream << vertexShaderFile . rdbuf (); fragmentShaderStream << fragmentShaderFile . rdbuf (); vertexShaderFile . close (); fragmentShaderFile . close (); openGlShaderSourceCode . vertex = vertexShaderStream . str (); openGlShaderSourceCode . fragment = fragmentShaderStream . str (); } catch ( std :: ifstream :: failure & e ) { logger -> Error ( \"Error reading shader files! \\n \" \"vertex path = '%s' \\n fragment path = '%s'!\" , vertexPath . c_str (), fragmentPath . c_str ()); } } return openGlShaderSourceCode ; } void Shader :: Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ) { unsigned int vertex , fragment ; const char * vertexSource = openGlShaderSourceCode . vertex . c_str (); const char * fragmentSource = openGlShaderSourceCode . fragment . c_str (); // vertex vertex = glCreateShader ( GL_VERTEX_SHADER ); glShaderSource ( vertex , 1 , & vertexSource , nullptr ); glCompileShader ( vertex ); CheckCompileErrors ( vertex , \"VERTEX\" ); // fragment fragment = glCreateShader ( GL_FRAGMENT_SHADER ); glShaderSource ( fragment , 1 , & fragmentSource , nullptr ); glCompileShader ( fragment ); CheckCompileErrors ( fragment , \"FRAGMENT\" ); // shader ID = glCreateProgram (); glAttachShader ( ID , vertex ); glAttachShader ( ID , fragment ); glLinkProgram ( ID ); CheckCompileErrors ( ID , \"PROGRAM\" ); glDeleteShader ( vertex ); glDeleteShader ( fragment ); } void Shader :: Use () { glUseProgram ( ID ); } void Shader :: SetBool ( const std :: string & name , bool value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), ( int ) value ); } void Shader :: SetInt ( const std :: string & name , int value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetFloat ( const std :: string & name , float value ) const { glUniform1f ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetVec2Float ( const std :: string & name , float v1 , float v2 ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 ); } void Shader :: SetVec2Float ( const std :: string & name , const Vector2 & value ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y ); } void Shader :: SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 ); } void Shader :: SetVec3Float ( const std :: string & name , const Color & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b ); } void Shader :: SetVec3Float ( const std :: string & name , const Vector3 & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y , value . z ); } void Shader :: SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 , v4 ); } void Shader :: SetVec4Float ( const std :: string & name , const Color & value ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b , value . a ); } void Shader :: SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const { glUniformMatrix4fv ( glGetUniformLocation ( this -> ID , name . c_str ()), 1 , GL_FALSE , glm :: value_ptr ( mat )); } bool Shader :: IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ) { bool isValid = true ; if ( ! FileHelper :: DoesFileExist ( vertexPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } if ( ! FileHelper :: DoesFileExist ( fragmentPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } return isValid ; } void Shader :: CheckCompileErrors ( unsigned int shader , const std :: string & type ) { int success ; char infoLog [ 1024 ]; if ( type == \"PROGRAM\" ) { glGetProgramiv ( shader , GL_LINK_STATUS , & success ); if ( ! success ) { glGetProgramInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' linking failed! \\n %s\" , type . c_str (), infoLog ); } } else { glGetShaderiv ( shader , GL_COMPILE_STATUS , & success ); if ( ! success ) { glGetShaderInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' compilation failed! \\n %s\" , type . c_str (), infoLog ); } } } First, the OpenGLShaderSourceCode struct is used to hold a string representation of the shader code. The Shader class has two constructors, one that accepts OpenGLShaderSourceCode and another that accepts the file paths of the vertex and fragment shaders file paths as parameters which we won't use for this tutorial series. The Compile function compiles the vertex and fragment shaders, attaches the shader objects to the shader program, and links the shader program. We will call the Use function whenever we need to install a shader for use which we'll see an example of later. Other than that, the last thing to mention is the multiple Set$TYPE functions. These are used to set uniform variables within the shaders and we will see how they are used in the next section. SpriteRenderer Shader Code The first thing to point out is the GLSL shader code for the vertex and fragment shaders. Vertex The vec4 variable vertex is a vertex attribute that contains data for the sprites position and texture coordinates. Next is the out variable for texCoord which we'll read from our vertex attribute and pass to the fragment shader. Next are the two uniform variables for the projection and model matrices. The main function simply set's the value for texCoord and set's the position of the vertex via gl_Position . #version 330 core layout ( location = 0 ) in vec4 vertex ; out vec2 texCoord uniform mat4 projection ; uniform mat4 model ; void main () { texCoord = vertex . zw ; gl_Position = projection * model * vec4 ( vertex . xy , 0.0 f , 1.0 f ); } Fragment The fragment shader is even simpler than the vertex as we're only setting the color of the fragment! We get the color of the texture with the texture function. We then take the color from the texture and blend it with the spriteColor passed in as a uniform variable. #version 330 core in vec2 texCoord ; out vec4 color ; uniform sampler2D sprite ; uniform vec4 spriteColor ; void main () { color = spriteColor * texture ( sprite , texCoord ); } SpriteRenderer Class The next thing to tackle it to write the renderer class for sprites! #ifndef SPRITE_RENDERER_H #define SPRITE_RENDERER_H #include <glad/glad.h> #include \"./re/rendering/shader.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/color.h\" #include \"./re/math/math.h\" #include \"project_properties.h\" static const std :: string & OPENGL_SHADER_SOURCE_VERTEX_SPRITE = \"#version 330 core \\n \" \" \\n \" \"layout (location = 0) in vec4 vertex; \\n \" \" \\n \" \"out vec2 texCoord; \\n \" \" \\n \" \"uniform mat4 projection; \\n \" \"uniform mat4 model; \\n \" \" \\n \" \"void main() { \\n \" \" texCoord = vertex.zw; \\n \" \" gl_Position = projection * model * vec4(vertex.xy, 0.0f, 1.0f); \\n \" \"} \\n \" \"\" ; static const std :: string & OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE = \"#version 330 core \\n \" \" \\n \" \"in vec2 texCoord; \\n \" \"out vec4 color; \\n \" \" \\n \" \"uniform sampler2D sprite; \\n \" \"uniform vec4 spriteColor; \\n \" \" \\n \" \"void main() { \\n \" \" color = spriteColor * texture(sprite, texCoord); \\n \" \"} \\n \" \"\" ; static const OpenGLShaderSourceCode OPENGL_SHADER_SOURCE_SPRITE = OpenGLShaderSourceCode { . vertex = OPENGL_SHADER_SOURCE_VERTEX_SPRITE , . fragment = OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE }; class SpriteRenderer { public : SpriteRenderer (); void Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ); private : Shader shader ; GLuint quadVAO ; GLuint quadVBO ; ProjectProperties * projectProperties = nullptr ; }; #endif //SPRITE_RENDERER_H #include \"sprite_renderer.h\" #include <glm/gtc/matrix_transform.hpp> SpriteRenderer :: SpriteRenderer () : projectProperties ( ProjectProperties :: GetInstance ()) { GLfloat vertices [] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; glGenVertexArrays ( 1 , & quadVAO ); glGenBuffers ( 1 , & quadVBO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( vertices ), vertices , GL_STATIC_DRAW ); glBindVertexArray ( quadVAO ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), ( void * ) nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); shader = Shader ( OPENGL_SHADER_SOURCE_SPRITE ); shader . Use (); shader . SetInt ( \"sprite\" , 0 ); Matrix4 projection = glm :: ortho ( 0.0f , static_cast < float > ( projectProperties -> GetWindowWidth ()), static_cast < float > ( projectProperties -> GetWindowHeight ()), 0.0f , -1.0f , 1.0f ); shader . SetMatrix4Float ( \"projection\" , projection ); } void SpriteRenderer :: Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ) { // 1. Translation Matrix4 model = glm :: mat4 ( 1.0f ); model = glm :: translate ( model , glm :: vec3 ( destinationRectangle . x , destinationRectangle . y , 0.0f )); // first translate (transformations are: scale happens first, then rotation, and then final translation happens; reversed order) // 2. Rotation model = glm :: translate ( model , Vector3 ( 0.5f * destinationRectangle . w , 0.5f * destinationRectangle . h , 0.0f )); // move origin of rotation to center of quad model = glm :: rotate ( model , glm :: radians ( rotation ), Vector3 ( 0.0f , 0.0f , 1.0f )); // then rotate model = glm :: translate ( model , Vector3 ( -0.5f * destinationRectangle . w , -0.5f * destinationRectangle . h , 0.0f )); // move origin back // 3. Scaling model = glm :: scale ( model , Vector3 ( destinationRectangle . w , destinationRectangle . h , 1.0f )); // last scale glBindVertexArray ( quadVAO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); shader . Use (); shader . SetMatrix4Float ( \"model\" , model ); shader . SetVec4Float ( \"spriteColor\" , color . r , color . g , color . b , color . a ); glActiveTexture ( GL_TEXTURE0 ); texture2D -> Bind (); // render subimage based on source rectangle glPixelStorei ( GL_UNPACK_ROW_LENGTH , texture2D -> GetWidth ()); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , sourceRectangle . x ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , sourceRectangle . y ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RGBA , sourceRectangle . w , sourceRectangle . h , 0 , texture2D -> GetImageFormat (), GL_UNSIGNED_BYTE , texture2D -> GetData ()); glPixelStorei ( GL_UNPACK_ROW_LENGTH , 0 ); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , 0 ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , 0 ); // Render Container GLfloat vertices [ 6 ][ 4 ] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; static const int VERT_X = 2 ; static const int VERT_Y = 3 ; if ( flipX ) { vertices [ 0 ][ VERT_X ] = 1.0f ; vertices [ 1 ][ VERT_X ] = 0.0f ; vertices [ 2 ][ VERT_X ] = 1.0f ; vertices [ 3 ][ VERT_X ] = 1.0f ; vertices [ 4 ][ VERT_X ] = 0.0f ; vertices [ 5 ][ VERT_X ] = 0.0f ; } if ( flipY ) { vertices [ 0 ][ VERT_Y ] = 0.0f ; vertices [ 1 ][ VERT_Y ] = 1.0f ; vertices [ 2 ][ VERT_Y ] = 1.0f ; vertices [ 3 ][ VERT_Y ] = 0.0f ; vertices [ 4 ][ VERT_Y ] = 0.0f ; vertices [ 5 ][ VERT_Y ] = 1.0f ; } glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( vertices ), vertices ); glDrawArrays ( GL_TRIANGLES , 0 , 6 ); glBindVertexArray ( 0 ); } Will explain soon... Renderer2D We have a SpriteRenderer and now it's time to define the top level 2d renderer class. #ifndef RENDERER_2D_H #define RENDERER_2D_H #include \"renderer_batcher.h\" #include \"sprite_renderer.h\" class Renderer2D { public : Renderer2D () = default ; ~ Renderer2D (); void Initialize (); void SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation = 0.0f , Color color = Color ( 1.0f , 1.0f , 1.0f ), bool flipX = false , bool flipY = false ); void FlushBatches (); private : RendererBatcher rendererBatcher ; SpriteRenderer * spriteRenderer = nullptr ; }; #endif //RENDERER_2D_H #include \"renderer_2d.h\" #include <cassert> #include <glad/glad.h> Renderer2D ::~ Renderer2D () { if ( spriteRenderer != nullptr ) { delete spriteRenderer ; } } void Renderer2D :: Initialize () { glEnable ( GL_BLEND ); glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ); spriteRenderer = new SpriteRenderer (); } void Renderer2D :: SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation , Color color , bool flipX , bool flipY ) { SpriteBatchItem spriteBatchItem = { texture2D , sourceRectangle , destinationRectangle , rotation , color , flipX , flipY }; rendererBatcher . BatchDrawSprite ( spriteBatchItem , zIndex ); } void Renderer2D :: FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } }; rendererBatcher . Flush ( renderFlushFunction ); } The Initialize function is straightforward as it initialized things for the renderer. SubmitSpriteBatchItem function will submit a sprite batch item to be rendered at a later time. Last but not least the FlushBatches will flush all queued draw batches and render them to the screen. Render Sprites Updating constructor to initialize member pointer variables. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } Implementing the private InitializeRendering function. bool GameEngine::InitializeRendering () { // OpenGL attributes SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); renderContext -> window = SDL_CreateWindow ( projectProperties -> GetGameTitle (). c_str (), SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , projectProperties -> GetWindowWidth (), projectProperties -> GetWindowHeight (), renderContext -> windowFlags ); renderContext -> glContext = SDL_GL_CreateContext ( renderContext -> window ); renderContext -> currentWindowWidth = projectProperties -> GetWindowWidth (); renderContext -> currentWindowHeight = projectProperties -> GetWindowHeight (); if ( ! gladLoadGLLoader (( GLADloadproc ) SDL_GL_GetProcAddress )) { logger -> Error ( \"Couldn't initialize glad\" ); return false ; } renderer2D . Initialize (); // Temp Load Assets assetManager -> LoadTexture ( \"assets/images/melissa_walk_animation.png\" , \"assets/images/melissa_walk_animation.png\" ); return true ; } Now we will implement the Render function. void GameEngine::Render () { glClearColor ( projectProperties -> backgroundClearColor . r , projectProperties -> backgroundClearColor . g , projectProperties -> backgroundClearColor . b , projectProperties -> backgroundClearColor . a ); glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT ); // Render Sprites static Texture * mellisaWalkTexture = assetManager -> GetTexture ( \"assets/images/melissa_walk_animation.png\" ); static Rect2 drawSourceRect = Rect2 ( 0 , 0 , 32 , 32 ); static Rect2 drawDestinationRect = Rect2 ( windowCenter . x , windowCenter . y , drawSourceRect . w , drawSourceRect . h ); renderer2D . SubmitSpriteBatchItem ( mellisaWalkTexture , drawSourceRect , drawDestinationRect , 0 ); // Flush renderer2D . FlushBatches (); SDL_GL_SwapWindow ( renderContext -> window ); } Lastly we are going to process input by checking if an SDL_QUIT event type was triggered. If we click the 'X' in the top right part of the window, we will now close the window and shutdown the engine. void GameEngine::ProcessInput () { SDL_Event event ; while ( SDL_PollEvent ( & event )) { switch ( event . type ) { case SDL_QUIT : engineContext -> SetRunning ( false ); break ; case SDL_WINDOWEVENT : switch ( event . window . event ) { case SDL_WINDOWEVENT_RESIZED : renderContext -> currentWindowWidth = event . window . data1 ; renderContext -> currentWindowHeight = event . window . data2 ; glViewport ( 0 , 0 , renderContext -> currentWindowWidth , renderContext -> currentWindowHeight ); break ; } break ; } } } After executing the code, this will be rendered to the screen: The source code for this section can be found here . Now that we have rendered a sprite it's now time to render font.","title":"Rendering Sprites"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#rendering-sprites","text":"","title":"Rendering Sprites"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#math-lib","text":"","title":"Math Lib"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#glm","text":"GLM is a header only math library based on the OpenGL Shading Language (GLSL) specifications. Most things related to math such as vectors, matrices, etc... will be handled by GLM.","title":"GLM"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#rectangle","text":"The Rectangle class will mostly be used for defining the bounds of a sprite's draw source and draw destination which we'll get to later. #ifndef RECTANGLE_H #define RECTANGLE_H #include <iostream> #include <glm/glm.hpp> class Rectangle { public : float x ; float y ; float w ; float h ; Rectangle () : x ( 0.0f ), y ( 0.0f ), w ( 0.0f ), h ( 0.0f ) {} Rectangle ( float x , float y , float w , float h ) : x ( x ), y ( y ), w ( w ), h ( h ) {} Rectangle ( float x , float y , glm :: vec2 size ) : x ( x ), y ( y ), w ( size . x ), h ( size . y ) {} Rectangle ( glm :: vec2 position , glm :: vec2 size ) : x ( position . x ), y ( position . y ), w ( size . x ), h ( size . y ) {} bool operator == ( const Rectangle & otherRect2 ) const { return this -> x == otherRect2 . x && this -> y == otherRect2 . y && this -> w == otherRect2 . w && this -> h == otherRect2 . h ; } bool operator != ( const Rectangle & otherRect2 ) const { return ! ( * this == otherRect2 ); } friend std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ); }; #endif //RECTANGLE_H #include \"rectangle.h\" std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ) { os << \"(\" << r . x << \", \" << r . y << \", \" << r . w << \", \" << r . h << \")\" ; return os ; }","title":"Rectangle"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#custom-math-header","text":"Red Engine will use GLM, but we may want to use another math library or write our own in the future. To make this easier, will we define type aliases for math related classes. #ifndef MATH_H #define MATH_H #include \"rectangle.h\" using Vector2 = glm :: vec2 ; using IVector2 = glm :: ivec2 ; using Vector3 = glm :: vec3 ; using Matrix4 = glm :: mat4 ; using Rect2 = Rectangle ; #endif //MATH_H","title":"Custom Math Header"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#color","text":"Not much to explain other than needing a concept of color within the engine. #ifndef COLOR_H #define COLOR_H #include <glad/glad.h> class Color { public : float r = 1.0f ; float g = 1.0f ; float b = 1.0f ; float a = 1.0f ; Color () {} Color ( GLfloat red , GLfloat green , GLfloat blue ) : r ( red ), g ( green ), b ( blue ), a ( 1.0f ) {} Color ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) : r ( red ), g ( green ), b ( blue ), a ( alpha ) {} Color operator * ( float value ) { return Color ( this -> r * value , this -> g * value , this -> b * value , this -> a ); } }; #endif //COLOR_H","title":"Color"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#renderer-batcher","text":"The RendererBatcher class will be used to take draw calls and batch them to be used during rendering. Typically, batching is done to limit draw calls for efficiency and performance reasons but for simplicity\u2019s sake this batcher will be designed to just defer and submit draw calls during the Render phase. #ifndef RENDERER_BATCHER_H #define RENDERER_BATCHER_H #include <vector> #include <map> #include <string> #include <functional> #include \"./re/rendering/color.h\" #include \"./re/rendering/texture.h\" #include \"./re/math/math.h\" struct SpriteBatchItem { Texture * texture2D = nullptr ; Rect2 sourceRectangle ; Rect2 destinationRectangle ; float rotation = 0.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); bool flipX = false ; bool flipY = false ; }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; }; using RenderFlushFunction = std :: function < void ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) > ; class RendererBatcher { public : void BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ); void Flush ( const RenderFlushFunction & renderFlushFunction ); private : std :: map < int , ZIndexDrawBatch > drawBatches ; }; #endif //RENDERER_BATCHER_H #include \"./renderer_batcher.h\" void RendererBatcher::BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. spriteDrawBatches . emplace_back ( spriteBatchItem ); } void RendererBatcher::Flush ( const RenderFlushFunction & renderFlushFunction ) { for ( const auto & pair : drawBatches ) { const int zIndex = pair . first ; const ZIndexDrawBatch & zIndexDrawBatch = pair . second ; renderFlushFunction ( zIndex , zIndexDrawBatch ); } drawBatches . clear (); } The first thing to point out is the SpriteBatchItem struct as this will be used to determine what to render for a sprite. Red Engine will group draw batches by their z indices. The ZIndexDrawBatch struct will represent a draw batch for a particular z index. We also define an alias RenderFlushFunction to be used as a lambda function to render flushed draw batches by the Renderer which we'll get to later. RendererBatcher class is currently simple as it has one map and two functions. The drawBatches map maintains the order of draw batches based on their z indices. BatchDrawSprite will submit a batch item to the batcher to draw during the render phase. The Flush function is called during the render phase to render batch items submitted and will clear them when completed.","title":"Renderer Batcher"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#2d-rendering","text":"","title":"2D Rendering"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#shaders","text":"What are shaders? They are simply GPU programs, in the case of OpenGL written in GLSL (OpenGL Shading Language). Before we write the renderer for Red Engine we'll first implement the Shader class which will compile shaders, install the shaders for use, and set uniform variables . A shader can be written for each of the shader stages , but we will only use vertex and fragment shaders in Red Engine . #ifndef SHADER_H #define SHADER_H #include <string> #include <fstream> #include <sstream> #include <iostream> #include <glad/glad.h> #include \"../math/math.h\" #include \"./color.h\" #include \"../utils/logger.h\" struct OpenGLShaderSourceCode { std :: string vertex ; std :: string fragment ; }; class Shader { public : Shader (); Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ); Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ); ~ Shader (); OpenGLShaderSourceCode GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ); void Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ); void Use (); void SetBool ( const std :: string & name , bool value ) const ; void SetInt ( const std :: string & name , int value ) const ; void SetFloat ( const std :: string & name , float value ) const ; void SetVec2Float ( const std :: string & name , float v1 , float v2 ) const ; void SetVec2Float ( const std :: string & name , const Vector2 & value ) const ; void SetVec3Float ( const std :: string & name , const Color & value ) const ; void SetVec3Float ( const std :: string & name , const Vector3 & value ) const ; void SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const ; void SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const ; void SetVec4Float ( const std :: string & name , const Color & value ) const ; void SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const ; private : unsigned int ID ; Logger * logger = nullptr ; bool IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ); void CheckCompileErrors ( unsigned int shader , const std :: string & type ); }; #endif //SHADER_H #include \"shader.h\" #include <cassert> #include <glm/gtc/type_ptr.hpp> #include \"../utils/file_helper.h\" Shader :: Shader () : logger ( Logger :: GetInstance ()) {} Shader :: Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ) : logger ( Logger :: GetInstance ()) { Compile ( GetOpenGLShaderSourceFromPaths ( vertexPath , fragmentPath )); } Shader :: Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ) : logger ( Logger :: GetInstance ()) { Compile ( openGlShaderSourceCode ); } Shader ::~ Shader () {} OpenGLShaderSourceCode Shader :: GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ) { OpenGLShaderSourceCode openGlShaderSourceCode ; if ( IsShaderFilesValid ( vertexPath , fragmentPath )) { std :: ifstream vertexShaderFile ; std :: ifstream fragmentShaderFile ; vertexShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); fragmentShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); try { vertexShaderFile . open ( vertexPath . c_str ()); fragmentShaderFile . open ( fragmentPath . c_str ()); std :: stringstream vertexShaderStream , fragmentShaderStream ; vertexShaderStream << vertexShaderFile . rdbuf (); fragmentShaderStream << fragmentShaderFile . rdbuf (); vertexShaderFile . close (); fragmentShaderFile . close (); openGlShaderSourceCode . vertex = vertexShaderStream . str (); openGlShaderSourceCode . fragment = fragmentShaderStream . str (); } catch ( std :: ifstream :: failure & e ) { logger -> Error ( \"Error reading shader files! \\n \" \"vertex path = '%s' \\n fragment path = '%s'!\" , vertexPath . c_str (), fragmentPath . c_str ()); } } return openGlShaderSourceCode ; } void Shader :: Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ) { unsigned int vertex , fragment ; const char * vertexSource = openGlShaderSourceCode . vertex . c_str (); const char * fragmentSource = openGlShaderSourceCode . fragment . c_str (); // vertex vertex = glCreateShader ( GL_VERTEX_SHADER ); glShaderSource ( vertex , 1 , & vertexSource , nullptr ); glCompileShader ( vertex ); CheckCompileErrors ( vertex , \"VERTEX\" ); // fragment fragment = glCreateShader ( GL_FRAGMENT_SHADER ); glShaderSource ( fragment , 1 , & fragmentSource , nullptr ); glCompileShader ( fragment ); CheckCompileErrors ( fragment , \"FRAGMENT\" ); // shader ID = glCreateProgram (); glAttachShader ( ID , vertex ); glAttachShader ( ID , fragment ); glLinkProgram ( ID ); CheckCompileErrors ( ID , \"PROGRAM\" ); glDeleteShader ( vertex ); glDeleteShader ( fragment ); } void Shader :: Use () { glUseProgram ( ID ); } void Shader :: SetBool ( const std :: string & name , bool value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), ( int ) value ); } void Shader :: SetInt ( const std :: string & name , int value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetFloat ( const std :: string & name , float value ) const { glUniform1f ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetVec2Float ( const std :: string & name , float v1 , float v2 ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 ); } void Shader :: SetVec2Float ( const std :: string & name , const Vector2 & value ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y ); } void Shader :: SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 ); } void Shader :: SetVec3Float ( const std :: string & name , const Color & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b ); } void Shader :: SetVec3Float ( const std :: string & name , const Vector3 & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y , value . z ); } void Shader :: SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 , v4 ); } void Shader :: SetVec4Float ( const std :: string & name , const Color & value ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b , value . a ); } void Shader :: SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const { glUniformMatrix4fv ( glGetUniformLocation ( this -> ID , name . c_str ()), 1 , GL_FALSE , glm :: value_ptr ( mat )); } bool Shader :: IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ) { bool isValid = true ; if ( ! FileHelper :: DoesFileExist ( vertexPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } if ( ! FileHelper :: DoesFileExist ( fragmentPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } return isValid ; } void Shader :: CheckCompileErrors ( unsigned int shader , const std :: string & type ) { int success ; char infoLog [ 1024 ]; if ( type == \"PROGRAM\" ) { glGetProgramiv ( shader , GL_LINK_STATUS , & success ); if ( ! success ) { glGetProgramInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' linking failed! \\n %s\" , type . c_str (), infoLog ); } } else { glGetShaderiv ( shader , GL_COMPILE_STATUS , & success ); if ( ! success ) { glGetShaderInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' compilation failed! \\n %s\" , type . c_str (), infoLog ); } } } First, the OpenGLShaderSourceCode struct is used to hold a string representation of the shader code. The Shader class has two constructors, one that accepts OpenGLShaderSourceCode and another that accepts the file paths of the vertex and fragment shaders file paths as parameters which we won't use for this tutorial series. The Compile function compiles the vertex and fragment shaders, attaches the shader objects to the shader program, and links the shader program. We will call the Use function whenever we need to install a shader for use which we'll see an example of later. Other than that, the last thing to mention is the multiple Set$TYPE functions. These are used to set uniform variables within the shaders and we will see how they are used in the next section.","title":"Shaders"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#spriterenderer","text":"","title":"SpriteRenderer"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#shader-code","text":"The first thing to point out is the GLSL shader code for the vertex and fragment shaders. Vertex The vec4 variable vertex is a vertex attribute that contains data for the sprites position and texture coordinates. Next is the out variable for texCoord which we'll read from our vertex attribute and pass to the fragment shader. Next are the two uniform variables for the projection and model matrices. The main function simply set's the value for texCoord and set's the position of the vertex via gl_Position . #version 330 core layout ( location = 0 ) in vec4 vertex ; out vec2 texCoord uniform mat4 projection ; uniform mat4 model ; void main () { texCoord = vertex . zw ; gl_Position = projection * model * vec4 ( vertex . xy , 0.0 f , 1.0 f ); } Fragment The fragment shader is even simpler than the vertex as we're only setting the color of the fragment! We get the color of the texture with the texture function. We then take the color from the texture and blend it with the spriteColor passed in as a uniform variable. #version 330 core in vec2 texCoord ; out vec4 color ; uniform sampler2D sprite ; uniform vec4 spriteColor ; void main () { color = spriteColor * texture ( sprite , texCoord ); }","title":"Shader Code"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#spriterenderer-class","text":"The next thing to tackle it to write the renderer class for sprites! #ifndef SPRITE_RENDERER_H #define SPRITE_RENDERER_H #include <glad/glad.h> #include \"./re/rendering/shader.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/color.h\" #include \"./re/math/math.h\" #include \"project_properties.h\" static const std :: string & OPENGL_SHADER_SOURCE_VERTEX_SPRITE = \"#version 330 core \\n \" \" \\n \" \"layout (location = 0) in vec4 vertex; \\n \" \" \\n \" \"out vec2 texCoord; \\n \" \" \\n \" \"uniform mat4 projection; \\n \" \"uniform mat4 model; \\n \" \" \\n \" \"void main() { \\n \" \" texCoord = vertex.zw; \\n \" \" gl_Position = projection * model * vec4(vertex.xy, 0.0f, 1.0f); \\n \" \"} \\n \" \"\" ; static const std :: string & OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE = \"#version 330 core \\n \" \" \\n \" \"in vec2 texCoord; \\n \" \"out vec4 color; \\n \" \" \\n \" \"uniform sampler2D sprite; \\n \" \"uniform vec4 spriteColor; \\n \" \" \\n \" \"void main() { \\n \" \" color = spriteColor * texture(sprite, texCoord); \\n \" \"} \\n \" \"\" ; static const OpenGLShaderSourceCode OPENGL_SHADER_SOURCE_SPRITE = OpenGLShaderSourceCode { . vertex = OPENGL_SHADER_SOURCE_VERTEX_SPRITE , . fragment = OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE }; class SpriteRenderer { public : SpriteRenderer (); void Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ); private : Shader shader ; GLuint quadVAO ; GLuint quadVBO ; ProjectProperties * projectProperties = nullptr ; }; #endif //SPRITE_RENDERER_H #include \"sprite_renderer.h\" #include <glm/gtc/matrix_transform.hpp> SpriteRenderer :: SpriteRenderer () : projectProperties ( ProjectProperties :: GetInstance ()) { GLfloat vertices [] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; glGenVertexArrays ( 1 , & quadVAO ); glGenBuffers ( 1 , & quadVBO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( vertices ), vertices , GL_STATIC_DRAW ); glBindVertexArray ( quadVAO ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), ( void * ) nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); shader = Shader ( OPENGL_SHADER_SOURCE_SPRITE ); shader . Use (); shader . SetInt ( \"sprite\" , 0 ); Matrix4 projection = glm :: ortho ( 0.0f , static_cast < float > ( projectProperties -> GetWindowWidth ()), static_cast < float > ( projectProperties -> GetWindowHeight ()), 0.0f , -1.0f , 1.0f ); shader . SetMatrix4Float ( \"projection\" , projection ); } void SpriteRenderer :: Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ) { // 1. Translation Matrix4 model = glm :: mat4 ( 1.0f ); model = glm :: translate ( model , glm :: vec3 ( destinationRectangle . x , destinationRectangle . y , 0.0f )); // first translate (transformations are: scale happens first, then rotation, and then final translation happens; reversed order) // 2. Rotation model = glm :: translate ( model , Vector3 ( 0.5f * destinationRectangle . w , 0.5f * destinationRectangle . h , 0.0f )); // move origin of rotation to center of quad model = glm :: rotate ( model , glm :: radians ( rotation ), Vector3 ( 0.0f , 0.0f , 1.0f )); // then rotate model = glm :: translate ( model , Vector3 ( -0.5f * destinationRectangle . w , -0.5f * destinationRectangle . h , 0.0f )); // move origin back // 3. Scaling model = glm :: scale ( model , Vector3 ( destinationRectangle . w , destinationRectangle . h , 1.0f )); // last scale glBindVertexArray ( quadVAO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); shader . Use (); shader . SetMatrix4Float ( \"model\" , model ); shader . SetVec4Float ( \"spriteColor\" , color . r , color . g , color . b , color . a ); glActiveTexture ( GL_TEXTURE0 ); texture2D -> Bind (); // render subimage based on source rectangle glPixelStorei ( GL_UNPACK_ROW_LENGTH , texture2D -> GetWidth ()); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , sourceRectangle . x ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , sourceRectangle . y ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RGBA , sourceRectangle . w , sourceRectangle . h , 0 , texture2D -> GetImageFormat (), GL_UNSIGNED_BYTE , texture2D -> GetData ()); glPixelStorei ( GL_UNPACK_ROW_LENGTH , 0 ); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , 0 ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , 0 ); // Render Container GLfloat vertices [ 6 ][ 4 ] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; static const int VERT_X = 2 ; static const int VERT_Y = 3 ; if ( flipX ) { vertices [ 0 ][ VERT_X ] = 1.0f ; vertices [ 1 ][ VERT_X ] = 0.0f ; vertices [ 2 ][ VERT_X ] = 1.0f ; vertices [ 3 ][ VERT_X ] = 1.0f ; vertices [ 4 ][ VERT_X ] = 0.0f ; vertices [ 5 ][ VERT_X ] = 0.0f ; } if ( flipY ) { vertices [ 0 ][ VERT_Y ] = 0.0f ; vertices [ 1 ][ VERT_Y ] = 1.0f ; vertices [ 2 ][ VERT_Y ] = 1.0f ; vertices [ 3 ][ VERT_Y ] = 0.0f ; vertices [ 4 ][ VERT_Y ] = 0.0f ; vertices [ 5 ][ VERT_Y ] = 1.0f ; } glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( vertices ), vertices ); glDrawArrays ( GL_TRIANGLES , 0 , 6 ); glBindVertexArray ( 0 ); } Will explain soon...","title":"SpriteRenderer Class"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#renderer2d","text":"We have a SpriteRenderer and now it's time to define the top level 2d renderer class. #ifndef RENDERER_2D_H #define RENDERER_2D_H #include \"renderer_batcher.h\" #include \"sprite_renderer.h\" class Renderer2D { public : Renderer2D () = default ; ~ Renderer2D (); void Initialize (); void SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation = 0.0f , Color color = Color ( 1.0f , 1.0f , 1.0f ), bool flipX = false , bool flipY = false ); void FlushBatches (); private : RendererBatcher rendererBatcher ; SpriteRenderer * spriteRenderer = nullptr ; }; #endif //RENDERER_2D_H #include \"renderer_2d.h\" #include <cassert> #include <glad/glad.h> Renderer2D ::~ Renderer2D () { if ( spriteRenderer != nullptr ) { delete spriteRenderer ; } } void Renderer2D :: Initialize () { glEnable ( GL_BLEND ); glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ); spriteRenderer = new SpriteRenderer (); } void Renderer2D :: SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation , Color color , bool flipX , bool flipY ) { SpriteBatchItem spriteBatchItem = { texture2D , sourceRectangle , destinationRectangle , rotation , color , flipX , flipY }; rendererBatcher . BatchDrawSprite ( spriteBatchItem , zIndex ); } void Renderer2D :: FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } }; rendererBatcher . Flush ( renderFlushFunction ); } The Initialize function is straightforward as it initialized things for the renderer. SubmitSpriteBatchItem function will submit a sprite batch item to be rendered at a later time. Last but not least the FlushBatches will flush all queued draw batches and render them to the screen.","title":"Renderer2D"},{"location":"1.foundation/3.opengl_rendering/rendering_sprites/#render-sprites","text":"Updating constructor to initialize member pointer variables. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } Implementing the private InitializeRendering function. bool GameEngine::InitializeRendering () { // OpenGL attributes SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); renderContext -> window = SDL_CreateWindow ( projectProperties -> GetGameTitle (). c_str (), SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , projectProperties -> GetWindowWidth (), projectProperties -> GetWindowHeight (), renderContext -> windowFlags ); renderContext -> glContext = SDL_GL_CreateContext ( renderContext -> window ); renderContext -> currentWindowWidth = projectProperties -> GetWindowWidth (); renderContext -> currentWindowHeight = projectProperties -> GetWindowHeight (); if ( ! gladLoadGLLoader (( GLADloadproc ) SDL_GL_GetProcAddress )) { logger -> Error ( \"Couldn't initialize glad\" ); return false ; } renderer2D . Initialize (); // Temp Load Assets assetManager -> LoadTexture ( \"assets/images/melissa_walk_animation.png\" , \"assets/images/melissa_walk_animation.png\" ); return true ; } Now we will implement the Render function. void GameEngine::Render () { glClearColor ( projectProperties -> backgroundClearColor . r , projectProperties -> backgroundClearColor . g , projectProperties -> backgroundClearColor . b , projectProperties -> backgroundClearColor . a ); glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT ); // Render Sprites static Texture * mellisaWalkTexture = assetManager -> GetTexture ( \"assets/images/melissa_walk_animation.png\" ); static Rect2 drawSourceRect = Rect2 ( 0 , 0 , 32 , 32 ); static Rect2 drawDestinationRect = Rect2 ( windowCenter . x , windowCenter . y , drawSourceRect . w , drawSourceRect . h ); renderer2D . SubmitSpriteBatchItem ( mellisaWalkTexture , drawSourceRect , drawDestinationRect , 0 ); // Flush renderer2D . FlushBatches (); SDL_GL_SwapWindow ( renderContext -> window ); } Lastly we are going to process input by checking if an SDL_QUIT event type was triggered. If we click the 'X' in the top right part of the window, we will now close the window and shutdown the engine. void GameEngine::ProcessInput () { SDL_Event event ; while ( SDL_PollEvent ( & event )) { switch ( event . type ) { case SDL_QUIT : engineContext -> SetRunning ( false ); break ; case SDL_WINDOWEVENT : switch ( event . window . event ) { case SDL_WINDOWEVENT_RESIZED : renderContext -> currentWindowWidth = event . window . data1 ; renderContext -> currentWindowHeight = event . window . data2 ; glViewport ( 0 , 0 , renderContext -> currentWindowWidth , renderContext -> currentWindowHeight ); break ; } break ; } } } After executing the code, this will be rendered to the screen: The source code for this section can be found here . Now that we have rendered a sprite it's now time to render font.","title":"Render Sprites"},{"location":"1.foundation/3.opengl_rendering/rendering_text/","text":"Rendering Text Font Freetype Library Red Engine uses the FreeType to help render font. Font Class Before we render text to the screen, we need to first define the concept of a font within Red Engine . #ifndef FONT_H #define FONT_H #include <iostream> #include <string> #include <map> #include <ft2build.h> #include FT_FREETYPE_H #include <glad/glad.h> #include \"../math/math.h\" #include \"../utils/file_helper.h\" #include \"../utils/logger.h\" struct Character { GLuint textureID ; Vector2 size ; Vector2 bearing ; unsigned int advance ; }; class Font { public : std :: map < GLchar , Character > characters ; GLuint VAO ; GLuint VBO ; Font ( FT_Library freeTypeLibrary , const char * fileName , int size ) : filePath ( std :: string ( fileName )), size ( size ) { LoadFont ( freeTypeLibrary , fileName , size ); ConfigureVertex (); } std :: string GetFilePath () const { return filePath ; } int GetSize () const { return size ; } bool IsValid () const { return valid ; } private : std :: string filePath ; int size ; bool valid = false ; void LoadFont ( FT_Library freeTypeLibrary , const char * fileName , int size ) { static Logger * logger = Logger :: GetInstance (); if ( ! FileHelper :: DoesFileExist ( fileName )) { logger -> Error ( \"Font doesn't exist at path: %s\" , fileName ); } FT_Face face ; if ( FT_New_Face ( freeTypeLibrary , fileName , 0 , & face )) { logger -> Error ( \"Freetype failed to load font!\" ); } else { // set size to load glyphs. width set to 0 to dynamically adjust FT_Set_Pixel_Sizes ( face , 0 , size ); // disable byte-alignment restriction glPixelStorei ( GL_UNPACK_ALIGNMENT , 1 ); // load first 128 characters of ASCII set for ( unsigned char c = 0 ; c < 128 ; c ++ ) { // load character glyph if ( FT_Load_Char ( face , c , FT_LOAD_RENDER )) { logger -> Error ( \"Freetype Failed to load Glyph\" ); continue ; } // generate texture unsigned int textTexture ; glGenTextures ( 1 , & textTexture ); glBindTexture ( GL_TEXTURE_2D , textTexture ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RED , face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows , 0 , GL_RED , GL_UNSIGNED_BYTE , face -> glyph -> bitmap . buffer ); // set texture options glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); // store character for later use Character character = { . textureID = textTexture , . size = Vector2 ( face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows ), . bearing = Vector2 ( face -> glyph -> bitmap_left , face -> glyph -> bitmap_top ), . advance = static_cast < unsigned int > ( face -> glyph -> advance . x ) }; characters . insert ( std :: pair < char , Character > ( c , character )); } glBindTexture ( GL_TEXTURE_2D , 0 ); valid = true ; } FT_Done_Face ( face ); } void ConfigureVertex () { // configure VAO & VBO texture quads glGenVertexArrays ( 1 , & VAO ); glGenBuffers ( 1 , & VBO ); glBindVertexArray ( VAO ); glBindBuffer ( GL_ARRAY_BUFFER , VBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( GLfloat ) * 6 * 4 , NULL , GL_DYNAMIC_DRAW ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); } }; #endif //FONT_H Update Rendering Renderer Batcher Adding FontBatchItem struct. Also adding vector for font draw batches. struct FontBatchItem { Font * font = nullptr ; std :: string text ; float x = 0.0f ; float y = 0.0f ; float scale = 1.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; std :: vector < FontBatchItem > fontDrawBatches ; }; Adding function to batch draw font. void RendererBatcher::BatchDrawFont ( FontBatchItem fontBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. fontDrawBatches . emplace_back ( fontBatchItem ); } Renderer2D Function to submit font draw batch item. void Renderer2D::SubmitFontBatchItem ( Font * font , const std :: string & text , float x , float y , int zIndex , float scale , Color color ) { FontBatchItem fontBatchItem = { font , text , x , y , scale , color }; rendererBatcher . BatchDrawFont ( fontBatchItem , zIndex ); } Next is to update the FlushBatches function to draw font. void Renderer2D::FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { // Draw Sprites for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } // Draw Font for ( const FontBatchItem & fontBatchItem : zIndexDrawBatch . fontDrawBatches ) { fontRenderer -> Draw ( fontBatchItem . font , fontBatchItem . text , fontBatchItem . x , fontBatchItem . y , fontBatchItem . scale , fontBatchItem . color ); } }; rendererBatcher . Flush ( renderFlushFunction ); } Render Context We then add this to the render context to initialize the FreeType library. FT_Library freeTypeLibrary ; void InitializeFont () { if ( FT_Init_FreeType ( & freeTypeLibrary )) { Logger :: GetInstance () -> Error ( \"Could not initialize FreeType Library!\" ); } } Asset Manager Be sure to add RenderContext to AssetManager . AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()) {} Also add functions for fonts. void AssetManager::LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ) { Font * font = new Font ( fontId , renderContext -> freeTypeLibrary , fontPath . c_str (), size ); fonts . emplace ( fontId , font ); } Font * AssetManager::GetFont ( const std :: string & fontId ) { assert ( fonts . count ( fontId ) > 0 && \"Font hasn't been loaded!\" ); return fonts [ fontId ]; } bool AssetManager::HasFont ( const std :: string & fontId ) const { return fonts . count ( fontId ) > 0 ; } Render Text In InitializeRendering we are adding: renderContext -> InitializeFont (); We will also load a font into asset manager with: assetManager -> LoadFont ( \"assets/fonts/verdana.ttf\" , \"assets/fonts/verdana.ttf\" , 20 ); Next to render text, we call this within our Render function: static Font * textFont = assetManager -> GetFont ( \"assets/fonts/verdana.ttf\" ); static const std :: string & text = \"Hello World!\" ; static Vector2 fontPosition = Vector2 ( windowCenter . x - 35.0f , windowCenter . y - 20.0f ); static Color fontColor = Color ( 1.0f , 1.0f , 1.0f ); renderer2D . SubmitFontBatchItem ( textFont , text , fontPosition . x , fontPosition . y , 0 , 1.0f , fontColor ); Once we run the engine, the following will be rendered to the screen: We have finally rendered text to the screen! All source code for this section can be found here . Now that we have a way to render sprites and text to the screen it's now time to start adding implementing audio to play music and sound effects!","title":"Rendering Text"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#rendering-text","text":"","title":"Rendering Text"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#font","text":"","title":"Font"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#freetype-library","text":"Red Engine uses the FreeType to help render font.","title":"Freetype Library"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#font-class","text":"Before we render text to the screen, we need to first define the concept of a font within Red Engine . #ifndef FONT_H #define FONT_H #include <iostream> #include <string> #include <map> #include <ft2build.h> #include FT_FREETYPE_H #include <glad/glad.h> #include \"../math/math.h\" #include \"../utils/file_helper.h\" #include \"../utils/logger.h\" struct Character { GLuint textureID ; Vector2 size ; Vector2 bearing ; unsigned int advance ; }; class Font { public : std :: map < GLchar , Character > characters ; GLuint VAO ; GLuint VBO ; Font ( FT_Library freeTypeLibrary , const char * fileName , int size ) : filePath ( std :: string ( fileName )), size ( size ) { LoadFont ( freeTypeLibrary , fileName , size ); ConfigureVertex (); } std :: string GetFilePath () const { return filePath ; } int GetSize () const { return size ; } bool IsValid () const { return valid ; } private : std :: string filePath ; int size ; bool valid = false ; void LoadFont ( FT_Library freeTypeLibrary , const char * fileName , int size ) { static Logger * logger = Logger :: GetInstance (); if ( ! FileHelper :: DoesFileExist ( fileName )) { logger -> Error ( \"Font doesn't exist at path: %s\" , fileName ); } FT_Face face ; if ( FT_New_Face ( freeTypeLibrary , fileName , 0 , & face )) { logger -> Error ( \"Freetype failed to load font!\" ); } else { // set size to load glyphs. width set to 0 to dynamically adjust FT_Set_Pixel_Sizes ( face , 0 , size ); // disable byte-alignment restriction glPixelStorei ( GL_UNPACK_ALIGNMENT , 1 ); // load first 128 characters of ASCII set for ( unsigned char c = 0 ; c < 128 ; c ++ ) { // load character glyph if ( FT_Load_Char ( face , c , FT_LOAD_RENDER )) { logger -> Error ( \"Freetype Failed to load Glyph\" ); continue ; } // generate texture unsigned int textTexture ; glGenTextures ( 1 , & textTexture ); glBindTexture ( GL_TEXTURE_2D , textTexture ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RED , face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows , 0 , GL_RED , GL_UNSIGNED_BYTE , face -> glyph -> bitmap . buffer ); // set texture options glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); // store character for later use Character character = { . textureID = textTexture , . size = Vector2 ( face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows ), . bearing = Vector2 ( face -> glyph -> bitmap_left , face -> glyph -> bitmap_top ), . advance = static_cast < unsigned int > ( face -> glyph -> advance . x ) }; characters . insert ( std :: pair < char , Character > ( c , character )); } glBindTexture ( GL_TEXTURE_2D , 0 ); valid = true ; } FT_Done_Face ( face ); } void ConfigureVertex () { // configure VAO & VBO texture quads glGenVertexArrays ( 1 , & VAO ); glGenBuffers ( 1 , & VBO ); glBindVertexArray ( VAO ); glBindBuffer ( GL_ARRAY_BUFFER , VBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( GLfloat ) * 6 * 4 , NULL , GL_DYNAMIC_DRAW ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); } }; #endif //FONT_H","title":"Font Class"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#update-rendering","text":"","title":"Update Rendering"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#renderer-batcher","text":"Adding FontBatchItem struct. Also adding vector for font draw batches. struct FontBatchItem { Font * font = nullptr ; std :: string text ; float x = 0.0f ; float y = 0.0f ; float scale = 1.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; std :: vector < FontBatchItem > fontDrawBatches ; }; Adding function to batch draw font. void RendererBatcher::BatchDrawFont ( FontBatchItem fontBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. fontDrawBatches . emplace_back ( fontBatchItem ); }","title":"Renderer Batcher"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#renderer2d","text":"Function to submit font draw batch item. void Renderer2D::SubmitFontBatchItem ( Font * font , const std :: string & text , float x , float y , int zIndex , float scale , Color color ) { FontBatchItem fontBatchItem = { font , text , x , y , scale , color }; rendererBatcher . BatchDrawFont ( fontBatchItem , zIndex ); } Next is to update the FlushBatches function to draw font. void Renderer2D::FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { // Draw Sprites for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } // Draw Font for ( const FontBatchItem & fontBatchItem : zIndexDrawBatch . fontDrawBatches ) { fontRenderer -> Draw ( fontBatchItem . font , fontBatchItem . text , fontBatchItem . x , fontBatchItem . y , fontBatchItem . scale , fontBatchItem . color ); } }; rendererBatcher . Flush ( renderFlushFunction ); }","title":"Renderer2D"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#render-context","text":"We then add this to the render context to initialize the FreeType library. FT_Library freeTypeLibrary ; void InitializeFont () { if ( FT_Init_FreeType ( & freeTypeLibrary )) { Logger :: GetInstance () -> Error ( \"Could not initialize FreeType Library!\" ); } }","title":"Render Context"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#asset-manager","text":"Be sure to add RenderContext to AssetManager . AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()) {} Also add functions for fonts. void AssetManager::LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ) { Font * font = new Font ( fontId , renderContext -> freeTypeLibrary , fontPath . c_str (), size ); fonts . emplace ( fontId , font ); } Font * AssetManager::GetFont ( const std :: string & fontId ) { assert ( fonts . count ( fontId ) > 0 && \"Font hasn't been loaded!\" ); return fonts [ fontId ]; } bool AssetManager::HasFont ( const std :: string & fontId ) const { return fonts . count ( fontId ) > 0 ; }","title":"Asset Manager"},{"location":"1.foundation/3.opengl_rendering/rendering_text/#render-text","text":"In InitializeRendering we are adding: renderContext -> InitializeFont (); We will also load a font into asset manager with: assetManager -> LoadFont ( \"assets/fonts/verdana.ttf\" , \"assets/fonts/verdana.ttf\" , 20 ); Next to render text, we call this within our Render function: static Font * textFont = assetManager -> GetFont ( \"assets/fonts/verdana.ttf\" ); static const std :: string & text = \"Hello World!\" ; static Vector2 fontPosition = Vector2 ( windowCenter . x - 35.0f , windowCenter . y - 20.0f ); static Color fontColor = Color ( 1.0f , 1.0f , 1.0f ); renderer2D . SubmitFontBatchItem ( textFont , text , fontPosition . x , fontPosition . y , 0 , 1.0f , fontColor ); Once we run the engine, the following will be rendered to the screen: We have finally rendered text to the screen! All source code for this section can be found here . Now that we have a way to render sprites and text to the screen it's now time to start adding implementing audio to play music and sound effects!","title":"Render Text"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/","text":"Using SDL_mixer Audio Creating Music and SoundEffect classes. #ifndef AUDIO_H #define AUDIO_H #include <SDL2/SDL_mixer.h> #include \"../utils/logger.h\" enum class AudioVolume : int { MIN = 0 , MAX = 128 , }; class Music { public : Music ( const std :: string & filePath ) { mixMusic = Mix_LoadMUS ( filePath . c_str ()); if ( ! mixMusic ) { Logger :: GetInstance () -> Error ( \"Error loading music at path '%s' \\n SDL2 Mixer Error: %s\" , filePath . c_str (), Mix_GetError ()); } } ~ Music () { if ( mixMusic ) { delete mixMusic ; } } bool IsValid () const { return mixMusic != nullptr ; } Mix_Music * GetData () { return mixMusic ; } private : Mix_Music * mixMusic = nullptr ; }; class SoundEffect { public : SoundEffect ( const std :: string & filePath ) { mixChunk = Mix_LoadWAV ( filePath . c_str ()); if ( ! mixChunk ) { Logger :: GetInstance () -> Error ( \"Error loading sound at path '%s' \\n SDL2 Mixer Error: %s\" , filePath . c_str (), Mix_GetError ()); } } ~ SoundEffect () { if ( mixChunk ) { delete mixChunk ; } } bool IsValid () const { return mixChunk != nullptr ; } Mix_Chunk * GetData () { return mixChunk ; } private : Mix_Chunk * mixChunk = nullptr ; }; #endif //AUDIO_H Asset Manager Will need to add functions for Music and SoundEffect in the AssetManager class. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/audio/audio.h\" #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/font.h\" #include \"./re/rendering/render_context.h\" class AssetManager { public : static AssetManager * GetInstance (); // Texture void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; // Font void LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ); Font * GetFont ( const std :: string & fontId ); bool HasFont ( const std :: string & fontId ) const ; // Music void LoadMusic ( const std :: string & musicId , const std :: string & musicPath ); Music * GetMusic ( const std :: string & musicId ); bool HasMusic ( const std :: string & musicId ) const ; // Sound void LoadSound ( const std :: string & soundId , const std :: string & soundPath ); SoundEffect * GetSound ( const std :: string & soundId ); bool HasSound ( const std :: string & soundId ) const ; std :: unordered_map < std :: string , SoundEffect *> GetAllSounds (); private : std :: unordered_map < std :: string , Texture *> textures ; std :: unordered_map < std :: string , Font *> fonts ; std :: unordered_map < std :: string , Music *> music ; std :: unordered_map < std :: string , SoundEffect *> soundEffects ; RenderContext * renderContext = nullptr ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H void AssetManager::LoadMusic ( const std :: string & musicId , const std :: string & musicPath ) { if ( HasMusic ( musicId )) { logger -> Warn ( \"Already has music, not loading!\" ); return ; } Music * newMusic = new Music ( musicPath ); assert ( newMusic -> IsValid () && \"Failed to load music!\" ); music . emplace ( musicId , newMusic ); } Music * AssetManager::GetMusic ( const std :: string & musicId ) { assert ( HasMusic ( musicId ) && \"Failed to get music!\" ); return music [ musicId ]; } bool AssetManager::HasMusic ( const std :: string & musicId ) const { return music . count ( musicId ) > 0 ; } void AssetManager::LoadSound ( const std :: string & soundId , const std :: string & soundPath ) { if ( HasSound ( soundId )) { logger -> Warn ( \"Already have sound, not loading!\" ); return ; } SoundEffect * soundEffect = new SoundEffect ( soundPath ); assert ( soundEffect -> IsValid () && \"Failed to load sound effect!\" ); soundEffects . emplace ( soundId , soundEffect ); } SoundEffect * AssetManager::GetSound ( const std :: string & soundId ) { assert ( HasSound ( soundId ) && \"Failed to get sound effect!\" ); return soundEffects [ soundId ]; } bool AssetManager::HasSound ( const std :: string & soundId ) const { return soundEffects . count ( soundId ) > 0 ; } std :: unordered_map < std :: string , SoundEffect *> AssetManager :: GetAllSounds () { return soundEffects ; } I haven't included the entire asset_manager.cpp file to reduce lines. Audio Helper The AudioHelper class contains static functions used to interact with music and sound effects. #ifndef AUDIO_HELPER_H #define AUDIO_HELPER_H #include \"./re/audio/audio.h\" #include \"./re/utils/helper.h\" #include \"asset_manager.h\" class AudioHelper { public : static void PlayMusic ( Music * music , bool loops = true ) { int loopNumber = loops ? -1 : 0 ; Mix_PlayMusic ( music -> GetData (), loopNumber ); } static void PlayMusic ( const std :: string & musicId , bool loops = true ) { static AssetManager * assetManager = AssetManager :: GetInstance (); PlayMusic ( assetManager -> GetMusic ( musicId ), loops ); } static void StopMusic () { Mix_HaltMusic (); } static void PauseMusic () { Mix_PauseMusic (); } static void PlaySound ( SoundEffect * soundEffect ) { Mix_PlayChannel ( -1 , soundEffect -> GetData (), 0 ); } static void PlaySound ( const std :: string & soundId ) { static AssetManager * assetManager = AssetManager :: GetInstance (); PlaySound ( assetManager -> GetSound ( soundId )); } static void SetMusicVolume ( int volume ) { Helper :: Clamp < int > ( volume , static_cast < int > ( AudioVolume :: MIN ), static_cast < int > ( AudioVolume :: MAX )); Mix_VolumeMusic ( volume ); } static void SetSoundVolume ( int volume ) { Helper :: Clamp < int > ( volume , static_cast < int > ( AudioVolume :: MIN ), static_cast < int > ( AudioVolume :: MAX )); static AssetManager * assetManager = AssetManager :: GetInstance (); for ( auto const & pair : assetManager -> GetAllSounds ()) { SoundEffect * soundEffect = pair . second ; Mix_VolumeChunk ( soundEffect -> GetData (), volume ); } } static void SetAllVolume ( int volume ) { SetMusicVolume ( volume ); SetSoundVolume ( volume ); } }; #endif //AUDIO_HELPER_H Using Audio We'll need to make a few tweaks to the GameEngine class. bool GameEngine::InitializeAudio () { if ( Mix_OpenAudio ( 44100 , MIX_DEFAULT_FORMAT , 2 , 2048 ) < 0 ) { logger -> Error ( \"SDL_mixer could not be initialized!\" ); return false ; } // Temp load assets assetManager -> LoadMusic ( \"test_music\" , \"assets/audio/music/test_music.wav\" ); assetManager -> LoadSound ( \"test_sound\" , \"assets/audio/sound/test_sound_effect.wav\" ); return true ; } bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } In the initialize function we are now calling InitializeAudio . There is also a call to AudioHelper::PlayMusic to play music when the engine initializes. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); // Temporary timer to play sound after 3 seconds static Timer * timer = nullptr ; if ( ! timer ) { timer = new Timer ( 3.0f ); timer -> Start (); } static bool hasPlayedSound = false ; if ( timer -> HasReachedTimeOut () && ! hasPlayedSound ) { AudioHelper :: PlaySound ( \"test_sound\" ); hasPlayedSound = true ; } lastFrameTime = SDL_GetTicks (); } In the Update function, a timer is created to play a sound effect after 3 seconds. If you run the code, it should play song and a brief sound effect after 3 seconds once the engine is running. The source code for this section can be found here . Now that we have music and sound effects implemented it's time to tackle handling input next!","title":"Using SDL_mixer"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/#using-sdl_mixer","text":"","title":"Using SDL_mixer"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/#audio","text":"Creating Music and SoundEffect classes. #ifndef AUDIO_H #define AUDIO_H #include <SDL2/SDL_mixer.h> #include \"../utils/logger.h\" enum class AudioVolume : int { MIN = 0 , MAX = 128 , }; class Music { public : Music ( const std :: string & filePath ) { mixMusic = Mix_LoadMUS ( filePath . c_str ()); if ( ! mixMusic ) { Logger :: GetInstance () -> Error ( \"Error loading music at path '%s' \\n SDL2 Mixer Error: %s\" , filePath . c_str (), Mix_GetError ()); } } ~ Music () { if ( mixMusic ) { delete mixMusic ; } } bool IsValid () const { return mixMusic != nullptr ; } Mix_Music * GetData () { return mixMusic ; } private : Mix_Music * mixMusic = nullptr ; }; class SoundEffect { public : SoundEffect ( const std :: string & filePath ) { mixChunk = Mix_LoadWAV ( filePath . c_str ()); if ( ! mixChunk ) { Logger :: GetInstance () -> Error ( \"Error loading sound at path '%s' \\n SDL2 Mixer Error: %s\" , filePath . c_str (), Mix_GetError ()); } } ~ SoundEffect () { if ( mixChunk ) { delete mixChunk ; } } bool IsValid () const { return mixChunk != nullptr ; } Mix_Chunk * GetData () { return mixChunk ; } private : Mix_Chunk * mixChunk = nullptr ; }; #endif //AUDIO_H","title":"Audio"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/#asset-manager","text":"Will need to add functions for Music and SoundEffect in the AssetManager class. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/audio/audio.h\" #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/font.h\" #include \"./re/rendering/render_context.h\" class AssetManager { public : static AssetManager * GetInstance (); // Texture void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; // Font void LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ); Font * GetFont ( const std :: string & fontId ); bool HasFont ( const std :: string & fontId ) const ; // Music void LoadMusic ( const std :: string & musicId , const std :: string & musicPath ); Music * GetMusic ( const std :: string & musicId ); bool HasMusic ( const std :: string & musicId ) const ; // Sound void LoadSound ( const std :: string & soundId , const std :: string & soundPath ); SoundEffect * GetSound ( const std :: string & soundId ); bool HasSound ( const std :: string & soundId ) const ; std :: unordered_map < std :: string , SoundEffect *> GetAllSounds (); private : std :: unordered_map < std :: string , Texture *> textures ; std :: unordered_map < std :: string , Font *> fonts ; std :: unordered_map < std :: string , Music *> music ; std :: unordered_map < std :: string , SoundEffect *> soundEffects ; RenderContext * renderContext = nullptr ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H void AssetManager::LoadMusic ( const std :: string & musicId , const std :: string & musicPath ) { if ( HasMusic ( musicId )) { logger -> Warn ( \"Already has music, not loading!\" ); return ; } Music * newMusic = new Music ( musicPath ); assert ( newMusic -> IsValid () && \"Failed to load music!\" ); music . emplace ( musicId , newMusic ); } Music * AssetManager::GetMusic ( const std :: string & musicId ) { assert ( HasMusic ( musicId ) && \"Failed to get music!\" ); return music [ musicId ]; } bool AssetManager::HasMusic ( const std :: string & musicId ) const { return music . count ( musicId ) > 0 ; } void AssetManager::LoadSound ( const std :: string & soundId , const std :: string & soundPath ) { if ( HasSound ( soundId )) { logger -> Warn ( \"Already have sound, not loading!\" ); return ; } SoundEffect * soundEffect = new SoundEffect ( soundPath ); assert ( soundEffect -> IsValid () && \"Failed to load sound effect!\" ); soundEffects . emplace ( soundId , soundEffect ); } SoundEffect * AssetManager::GetSound ( const std :: string & soundId ) { assert ( HasSound ( soundId ) && \"Failed to get sound effect!\" ); return soundEffects [ soundId ]; } bool AssetManager::HasSound ( const std :: string & soundId ) const { return soundEffects . count ( soundId ) > 0 ; } std :: unordered_map < std :: string , SoundEffect *> AssetManager :: GetAllSounds () { return soundEffects ; } I haven't included the entire asset_manager.cpp file to reduce lines.","title":"Asset Manager"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/#audio-helper","text":"The AudioHelper class contains static functions used to interact with music and sound effects. #ifndef AUDIO_HELPER_H #define AUDIO_HELPER_H #include \"./re/audio/audio.h\" #include \"./re/utils/helper.h\" #include \"asset_manager.h\" class AudioHelper { public : static void PlayMusic ( Music * music , bool loops = true ) { int loopNumber = loops ? -1 : 0 ; Mix_PlayMusic ( music -> GetData (), loopNumber ); } static void PlayMusic ( const std :: string & musicId , bool loops = true ) { static AssetManager * assetManager = AssetManager :: GetInstance (); PlayMusic ( assetManager -> GetMusic ( musicId ), loops ); } static void StopMusic () { Mix_HaltMusic (); } static void PauseMusic () { Mix_PauseMusic (); } static void PlaySound ( SoundEffect * soundEffect ) { Mix_PlayChannel ( -1 , soundEffect -> GetData (), 0 ); } static void PlaySound ( const std :: string & soundId ) { static AssetManager * assetManager = AssetManager :: GetInstance (); PlaySound ( assetManager -> GetSound ( soundId )); } static void SetMusicVolume ( int volume ) { Helper :: Clamp < int > ( volume , static_cast < int > ( AudioVolume :: MIN ), static_cast < int > ( AudioVolume :: MAX )); Mix_VolumeMusic ( volume ); } static void SetSoundVolume ( int volume ) { Helper :: Clamp < int > ( volume , static_cast < int > ( AudioVolume :: MIN ), static_cast < int > ( AudioVolume :: MAX )); static AssetManager * assetManager = AssetManager :: GetInstance (); for ( auto const & pair : assetManager -> GetAllSounds ()) { SoundEffect * soundEffect = pair . second ; Mix_VolumeChunk ( soundEffect -> GetData (), volume ); } } static void SetAllVolume ( int volume ) { SetMusicVolume ( volume ); SetSoundVolume ( volume ); } }; #endif //AUDIO_HELPER_H","title":"Audio Helper"},{"location":"1.foundation/4.implementing_audio/using_sdl_mixer/#using-audio","text":"We'll need to make a few tweaks to the GameEngine class. bool GameEngine::InitializeAudio () { if ( Mix_OpenAudio ( 44100 , MIX_DEFAULT_FORMAT , 2 , 2048 ) < 0 ) { logger -> Error ( \"SDL_mixer could not be initialized!\" ); return false ; } // Temp load assets assetManager -> LoadMusic ( \"test_music\" , \"assets/audio/music/test_music.wav\" ); assetManager -> LoadSound ( \"test_sound\" , \"assets/audio/sound/test_sound_effect.wav\" ); return true ; } bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } In the initialize function we are now calling InitializeAudio . There is also a call to AudioHelper::PlayMusic to play music when the engine initializes. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); // Temporary timer to play sound after 3 seconds static Timer * timer = nullptr ; if ( ! timer ) { timer = new Timer ( 3.0f ); timer -> Start (); } static bool hasPlayedSound = false ; if ( timer -> HasReachedTimeOut () && ! hasPlayedSound ) { AudioHelper :: PlaySound ( \"test_sound\" ); hasPlayedSound = true ; } lastFrameTime = SDL_GetTicks (); } In the Update function, a timer is created to play a sound effect after 3 seconds. If you run the code, it should play song and a brief sound effect after 3 seconds once the engine is running. The source code for this section can be found here . Now that we have music and sound effects implemented it's time to tackle handling input next!","title":"Using Audio"},{"location":"1.foundation/5.input_management/input_events/","text":"Input Events Input Event State #ifndef INPUT_EVENT_STATE_H #define INPUT_EVENT_STATE_H #include <SDL2/SDL.h> #include \"../math/math.h\" enum class InputEventType { MOUSE , KEYBOARD , JOYSTICK , }; struct InputEvent { InputEventType type ; Uint32 sdlType ; // Mouse Vector2 mouseMotion ; bool mousePressed = false ; Uint8 mouseButton ; // Joystick Uint8 controllerId ; Sint16 buttonValue ; bool buttonPressed = false ; Uint8 hat ; Uint8 hatValue ; // Keyboard bool keyPressed = false ; SDL_Scancode keyScancode ; }; class InputEventState { public : InputEvent ProcessSDLEvent ( SDL_Event & event ) { InputEvent inputEvent ; inputEvent . sdlType = event . type ; switch ( event . type ) { // Mouse case SDL_MOUSEMOTION : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mouseMotion = Vector2 ( event . motion . x , event . motion . y ); break ; case SDL_MOUSEWHEEL : inputEvent . type = InputEventType :: MOUSE ; break ; case SDL_MOUSEBUTTONDOWN : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mousePressed = true ; inputEvent . mouseButton = event . button . button ; break ; case SDL_MOUSEBUTTONUP : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mousePressed = false ; inputEvent . mouseButton = event . button . button ; break ; // Joystick case SDL_JOYBUTTONDOWN : case SDL_JOYBUTTONUP : inputEvent . type = InputEventType :: JOYSTICK ; inputEvent . controllerId = event . jbutton . which ; inputEvent . buttonValue = event . jbutton . button ; inputEvent . buttonPressed = event . jbutton . state == SDL_PRESSED ; break ; case SDL_JOYHATMOTION : inputEvent . type = InputEventType :: JOYSTICK ; inputEvent . controllerId = event . jhat . which ; inputEvent . hat = event . jhat . hat ; inputEvent . hatValue = event . jhat . value ; break ; // Keyboard case SDL_KEYDOWN : case SDL_KEYUP : if ( ! event . key . repeat ) { inputEvent . type = InputEventType :: KEYBOARD ; inputEvent . keyPressed = event . key . state == SDL_PRESSED ; inputEvent . keyScancode = event . key . keysym . scancode ; } break ; default : break ; } return inputEvent ; } }; #endif //INPUT_EVENT_STATE_H Keyboard #ifndef KEYBOARD_INPUT_H #define KEYBOARD_INPUT_H #include <string> #include <map> #include <SDL2/SDL.h> const std :: string KEYBOARD_KEY_UP { \"up\" }; const std :: string KEYBOARD_KEY_DOWN { \"down\" }; const std :: string KEYBOARD_KEY_LEFT { \"left\" }; const std :: string KEYBOARD_KEY_RIGHT { \"right\" }; const std :: string KEYBOARD_KEY_SPACE { \"space\" }; const std :: string KEYBOARD_KEY_ESC { \"esc\" }; const std :: string KEYBOARD_KEY_RETURN { \"return\" }; static std :: map < std :: string , SDL_Scancode > KEYBOARD_SCANCODE_TO_VALUE_MAPPING = { { \"0\" , SDL_SCANCODE_0 }, { \"1\" , SDL_SCANCODE_1 }, { \"2\" , SDL_SCANCODE_2 }, { \"3\" , SDL_SCANCODE_3 }, { \"4\" , SDL_SCANCODE_4 }, { \"5\" , SDL_SCANCODE_5 }, { \"6\" , SDL_SCANCODE_6 }, { \"7\" , SDL_SCANCODE_7 }, { \"8\" , SDL_SCANCODE_8 }, { \"9\" , SDL_SCANCODE_9 }, { \"a\" , SDL_SCANCODE_A }, { \"b\" , SDL_SCANCODE_B }, { \"c\" , SDL_SCANCODE_C }, { \"d\" , SDL_SCANCODE_D }, { \"e\" , SDL_SCANCODE_E }, { \"f\" , SDL_SCANCODE_F }, { \"g\" , SDL_SCANCODE_G }, { \"h\" , SDL_SCANCODE_H }, { \"i\" , SDL_SCANCODE_I }, { \"j\" , SDL_SCANCODE_J }, { \"k\" , SDL_SCANCODE_K }, { \"l\" , SDL_SCANCODE_L }, { \"m\" , SDL_SCANCODE_M }, { \"n\" , SDL_SCANCODE_N }, { \"o\" , SDL_SCANCODE_O }, { \"p\" , SDL_SCANCODE_P }, { \"q\" , SDL_SCANCODE_Q }, { \"r\" , SDL_SCANCODE_R }, { \"s\" , SDL_SCANCODE_S }, { \"t\" , SDL_SCANCODE_T }, { \"u\" , SDL_SCANCODE_U }, { \"v\" , SDL_SCANCODE_V }, { \"w\" , SDL_SCANCODE_W }, { \"x\" , SDL_SCANCODE_X }, { \"y\" , SDL_SCANCODE_Y }, { \"z\" , SDL_SCANCODE_Z }, { KEYBOARD_KEY_LEFT , SDL_SCANCODE_LEFT }, { KEYBOARD_KEY_RIGHT , SDL_SCANCODE_RIGHT }, { KEYBOARD_KEY_UP , SDL_SCANCODE_UP }, { KEYBOARD_KEY_DOWN , SDL_SCANCODE_DOWN }, { KEYBOARD_KEY_RETURN , SDL_SCANCODE_RETURN }, { KEYBOARD_KEY_SPACE , SDL_SCANCODE_SPACE }, { KEYBOARD_KEY_ESC , SDL_SCANCODE_ESCAPE }, { \"f1\" , SDL_SCANCODE_F1 }, { \"f2\" , SDL_SCANCODE_F2 }, { \"f3\" , SDL_SCANCODE_F3 }, { \"f4\" , SDL_SCANCODE_F4 }, { \"f5\" , SDL_SCANCODE_F5 }, { \"f6\" , SDL_SCANCODE_F6 }, { \"f7\" , SDL_SCANCODE_F7 }, { \"f8\" , SDL_SCANCODE_F8 }, { \"f9\" , SDL_SCANCODE_F9 }, { \"f10\" , SDL_SCANCODE_F10 }, { \"f11\" , SDL_SCANCODE_F11 }, { \"f12\" , SDL_SCANCODE_F12 } }; class KeyboardAction { public : bool isActionPressed = false ; bool isActionJustPressed = false ; bool isActionJustReleased = false ; std :: vector < SDL_Scancode > values ; SDL_Scancode lastScancodePressed = SDL_SCANCODE_UNKNOWN ; void AddValue ( const std :: string & actionValue ) { if ( KEYBOARD_SCANCODE_TO_VALUE_MAPPING . count ( actionValue ) > 0 ) { SDL_Scancode valueScancode = KEYBOARD_SCANCODE_TO_VALUE_MAPPING [ actionValue ]; values . emplace_back ( valueScancode ); } } void ProcessInputs ( const Uint8 * keyboardState ) { for ( SDL_Scancode scancodeValue : values ) { bool isKeyboardValuePressed = keyboardState [ scancodeValue ]; if ( isKeyboardValuePressed && ! isActionPressed ) { isActionPressed = true ; isActionJustPressed = true ; lastScancodePressed = scancodeValue ; break ; } else if ( ! isKeyboardValuePressed && ! isActionJustReleased && isActionPressed && scancodeValue == lastScancodePressed ) { isActionPressed = false ; isActionJustPressed = false ; isActionJustReleased = true ; } } } }; #endif //KEYBOARD_INPUT_H Mouse #ifndef MOUSE_INPUT_H #define MOUSE_INPUT_H #include <string> #include <vector> #include <algorithm> #include <SDL2/SDL.h> #include \"../math/math.h\" #include \"input_event_state.h\" const std :: string MOUSE_BUTTON_LEFT { \"mb_left\" }; const std :: string MOUSE_BUTTON_RIGHT { \"mb_right\" }; const std :: string MOUSE_BUTTON_MIDDLE { \"mb_middle\" }; class MouseInput { public : bool isMouseLeftButtonPressed = false ; bool isMouseLeftButtonJustPressed = false ; bool isMouseLeftButtonJustReleased = false ; bool isMouseRightButtonPressed = false ; bool isMouseRightButtonJustPressed = false ; bool isMouseRightButtonJustReleased = false ; static MouseInput * GetInstance (); void ClearInputFlags (); Vector2 GetMousePosition () const ; void ProcessSDLEvent ( InputEvent & inputEvent ); private : static MouseInput * instance ; Vector2 mousePosition ; MouseInput () {} }; class MouseAction { public : MouseAction () : mouseInput ( MouseInput :: GetInstance ()) {} static bool IsMouseValue ( const std :: string & actionValue ) { if ( actionValue == MOUSE_BUTTON_LEFT || actionValue == MOUSE_BUTTON_RIGHT ) { return true ; } return false ; } void AddValue ( const std :: string & actionValue ) { if ( ! HasValue ( actionValue )) { mouseValues . emplace_back ( actionValue ); } } bool HasValue ( const std :: string & actionValue ) { return std :: find ( mouseValues . begin (), mouseValues . end (), actionValue ) != mouseValues . end (); } bool IsActionPressed () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonPressed ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonPressed )) { return true ; } } return false ; } bool IsActionJustPressed () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonJustPressed ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonJustPressed )) { return true ; } } return false ; } bool IsActionJustReleased () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonJustReleased ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonJustReleased )) { return true ; } } return false ; } private : std :: vector < std :: string > mouseValues ; MouseInput * mouseInput = nullptr ; }; #endif //MOUSE_INPUT_H #include \"mouse_input.h\" MouseInput * MouseInput::GetInstance () { static MouseInput * instance = new MouseInput (); return instance ; } void MouseInput::ClearInputFlags () { isMouseLeftButtonJustPressed = false ; isMouseRightButtonJustPressed = false ; isMouseLeftButtonJustReleased = false ; isMouseRightButtonJustReleased = false ; } Vector2 MouseInput::GetMousePosition () const { return mousePosition ; } void MouseInput::ProcessSDLEvent ( InputEvent & inputEvent ) { switch ( inputEvent . sdlType ) { // Mouse case SDL_MOUSEMOTION : mousePosition = inputEvent . mouseMotion ; break ; case SDL_MOUSEWHEEL : break ; case SDL_MOUSEBUTTONDOWN : if ( inputEvent . mouseButton == SDL_BUTTON_LEFT ) { isMouseLeftButtonPressed = true ; isMouseLeftButtonJustPressed = true ; } else if ( inputEvent . mouseButton == SDL_BUTTON_RIGHT ) { isMouseRightButtonPressed = true ; isMouseRightButtonJustPressed = true ; } break ; case SDL_MOUSEBUTTONUP : if ( inputEvent . mouseButton == SDL_BUTTON_LEFT ) { isMouseLeftButtonPressed = false ; isMouseLeftButtonJustPressed = false ; isMouseLeftButtonJustReleased = true ; } else if ( inputEvent . mouseButton == SDL_BUTTON_RIGHT ) { isMouseRightButtonPressed = false ; isMouseRightButtonJustPressed = false ; isMouseRightButtonJustReleased = true ; } break ; default : break ; } } Joystick #ifndef JOYSTICK_INPUT_H #define JOYSTICK_INPUT_H #include <string> #include <vector> #include <unordered_map> #include <algorithm> #include <SDL2/SDL.h> #include \"input_event_state.h\" #include \"../utils/logger.h\" enum class JoystickButtonType : int { INVALID = -1 , BUTTON_A = 0 , BUTTON_B = 1 , BUTTON_X = 2 , BUTTON_Y = 3 , BUTTON_BACK = 6 , BUTTON_START = 7 , BUTTON_LEFT_SHOULDER = 4 , BUTTON_RIGHT_SHOULDER = 5 , BUTTON_LEFT_AXIS = 8 , BUTTON_RIGHT_AXIS = 9 , }; enum class JoystickDeadZone : int { AXIS = 10000 , TRIGGER = 8000 , }; enum class JoystickAxisMotion : Uint8 { LEFT_TRIGGER = 2 , RIGHT_TRIGGER = 5 , LEFT_HORIZONTAL_AXIS = 0 , LEFT_VERTICAL_AXIS = 1 , RIGHT_HORIZONTAL_AXIS = 3 , RIGHT_VERTICAL_AXIS = 4 , }; const std :: string JOYSTICK_BUTTON_A { \"joystick_button_a\" }; const std :: string JOYSTICK_BUTTON_B { \"joystick_button_b\" }; const std :: string JOYSTICK_BUTTON_X { \"joystick_button_x\" }; const std :: string JOYSTICK_BUTTON_Y { \"joystick_button_y\" }; const std :: string JOYSTICK_KEYPAD_UP { \"joystick_keypad_up\" }; const std :: string JOYSTICK_KEYPAD_DOWN { \"joystick_keypad_down\" }; const std :: string JOYSTICK_KEYPAD_RIGHT { \"joystick_keypad_right\" }; const std :: string JOYSTICK_KEYPAD_LEFT { \"joystick_keypad_left\" }; const std :: string JOYSTICK_START { \"joystick_button_start\" }; const std :: string JOYSTICK_BACK { \"joystick_button_back\" }; const std :: string JOYSTICK_LEFT_SHOULDER { \"joystick_left_shoulder\" }; const std :: string JOYSTICK_RIGHT_SHOULDER { \"joystick_right_shoulder\" }; const std :: string JOYSTICK_LEFT_TRIGGER { \"joystick_left_trigger\" }; const std :: string JOYSTICK_RIGHT_TRIGGER { \"joystick_right_trigger\" }; const std :: string JOYSTICK_LEFT_ANALOG { \"joystick_left_analog\" }; const std :: string JOYSTICK_RIGHT_ANALOG { \"joystick_right_analog\" }; const std :: string JOYSTICK_LEFT_ANALOG_UP { \"joystick_left_analog_up\" }; const std :: string JOYSTICK_LEFT_ANALOG_DOWN { \"joystick_left_analog_down\" }; const std :: string JOYSTICK_LEFT_ANALOG_RIGHT { \"joystick_left_analog_right\" }; const std :: string JOYSTICK_LEFT_ANALOG_LEFT { \"joystick_left_analog_left\" }; const std :: string JOYSTICK_RIGHT_ANALOG_UP { \"joystick_right_analog_up\" }; const std :: string JOYSTICK_RIGHT_ANALOG_DOWN { \"joystick_right_analog_down\" }; const std :: string JOYSTICK_RIGHT_ANALOG_RIGHT { \"joystick_right_analog_right\" }; const std :: string JOYSTICK_RIGHT_ANALOG_LEFT { \"joystick_right_analog_left\" }; static std :: unordered_map < std :: string , JoystickButtonType > JOYSTICK_NAME_TO_BUTTON_TYPE_MAP = { { JOYSTICK_BUTTON_A , JoystickButtonType :: BUTTON_A }, { JOYSTICK_BUTTON_B , JoystickButtonType :: BUTTON_B }, { JOYSTICK_BUTTON_X , JoystickButtonType :: BUTTON_X }, { JOYSTICK_BUTTON_Y , JoystickButtonType :: BUTTON_Y }, { JOYSTICK_START , JoystickButtonType :: BUTTON_START }, { JOYSTICK_BACK , JoystickButtonType :: BUTTON_BACK }, { JOYSTICK_LEFT_SHOULDER , JoystickButtonType :: BUTTON_LEFT_SHOULDER }, { JOYSTICK_RIGHT_SHOULDER , JoystickButtonType :: BUTTON_RIGHT_SHOULDER }, { JOYSTICK_LEFT_ANALOG , JoystickButtonType :: BUTTON_LEFT_AXIS }, { JOYSTICK_RIGHT_ANALOG , JoystickButtonType :: BUTTON_RIGHT_AXIS }, }; static std :: unordered_map < JoystickButtonType , std :: string > JOYSTICK_BUTTON_TYPE_TO_NAME_MAP = { { JoystickButtonType :: BUTTON_A , JOYSTICK_BUTTON_A }, { JoystickButtonType :: BUTTON_B , JOYSTICK_BUTTON_B }, { JoystickButtonType :: BUTTON_X , JOYSTICK_BUTTON_X }, { JoystickButtonType :: BUTTON_Y , JOYSTICK_BUTTON_Y }, { JoystickButtonType :: BUTTON_START , JOYSTICK_START }, { JoystickButtonType :: BUTTON_BACK , JOYSTICK_BACK }, { JoystickButtonType :: BUTTON_LEFT_SHOULDER , JOYSTICK_LEFT_SHOULDER }, { JoystickButtonType :: BUTTON_RIGHT_SHOULDER , JOYSTICK_RIGHT_SHOULDER }, { JoystickButtonType :: BUTTON_LEFT_AXIS , JOYSTICK_LEFT_ANALOG }, { JoystickButtonType :: BUTTON_RIGHT_AXIS , JOYSTICK_RIGHT_ANALOG }, }; static std :: unordered_map < std :: string , SDL_GameControllerButton > JOYSTICK_ACTION_BUTTON_MAPPINGS = { { JOYSTICK_BUTTON_A , SDL_CONTROLLER_BUTTON_A }, { JOYSTICK_BUTTON_B , SDL_CONTROLLER_BUTTON_B }, { JOYSTICK_BUTTON_X , SDL_CONTROLLER_BUTTON_X }, { JOYSTICK_BUTTON_Y , SDL_CONTROLLER_BUTTON_Y }, { JOYSTICK_KEYPAD_UP , SDL_CONTROLLER_BUTTON_DPAD_UP }, { JOYSTICK_KEYPAD_DOWN , SDL_CONTROLLER_BUTTON_DPAD_DOWN }, { JOYSTICK_KEYPAD_LEFT , SDL_CONTROLLER_BUTTON_DPAD_LEFT }, { JOYSTICK_KEYPAD_RIGHT , SDL_CONTROLLER_BUTTON_DPAD_RIGHT }, { JOYSTICK_START , SDL_CONTROLLER_BUTTON_START }, { JOYSTICK_BACK , SDL_CONTROLLER_BUTTON_BACK }, { JOYSTICK_LEFT_SHOULDER , SDL_CONTROLLER_BUTTON_LEFTSHOULDER }, { JOYSTICK_RIGHT_SHOULDER , SDL_CONTROLLER_BUTTON_RIGHTSHOULDER }, { JOYSTICK_LEFT_SHOULDER , SDL_CONTROLLER_BUTTON_LEFTSHOULDER }, { JOYSTICK_LEFT_ANALOG , SDL_CONTROLLER_BUTTON_LEFTSTICK }, { JOYSTICK_RIGHT_ANALOG , SDL_CONTROLLER_BUTTON_RIGHTSTICK }, // Non Game Controller Button Actions { JOYSTICK_LEFT_TRIGGER , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_TRIGGER , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_UP , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_DOWN , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_RIGHT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_LEFT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_UP , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_DOWN , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_RIGHT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_LEFT , SDL_CONTROLLER_BUTTON_INVALID } }; struct JoystickInputPressState { bool isPressed = false ; bool isJustPressed = false ; bool isJustReleased = false ; }; static std :: unordered_map < std :: string , JoystickInputPressState > JOYSTICK_BUTTON_INPUT_FLAGS = { // Button Process { JOYSTICK_BUTTON_B , JoystickInputPressState {}}, { JOYSTICK_BUTTON_A , JoystickInputPressState {}}, { JOYSTICK_BUTTON_X , JoystickInputPressState {}}, { JOYSTICK_BUTTON_Y , JoystickInputPressState {}}, { JOYSTICK_START , JoystickInputPressState {}}, { JOYSTICK_BACK , JoystickInputPressState {}}, { JOYSTICK_LEFT_SHOULDER , JoystickInputPressState {}}, { JOYSTICK_RIGHT_SHOULDER , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG , JoystickInputPressState {}}, // Hat Process { JOYSTICK_KEYPAD_LEFT , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_RIGHT , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_UP , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_DOWN , JoystickInputPressState {}}, // Axis Process { JOYSTICK_LEFT_ANALOG_LEFT , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_RIGHT , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_UP , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_DOWN , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_LEFT , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_RIGHT , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_UP , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_DOWN , JoystickInputPressState {}}, { JOYSTICK_LEFT_TRIGGER , JoystickInputPressState {}}, { JOYSTICK_RIGHT_TRIGGER , JoystickInputPressState {}}, }; class JoystickInput { public : static JoystickInput * GetInstance (); void ProcessSDLEvent ( InputEvent & inputEvent ); void LoadJoysticks (); void ClearInputFlags (); bool IsJoystickValue ( const std :: string & value ) const ; bool IsActionPressed ( const std :: string & value ); bool IsActionJustPressed ( const std :: string & value ); bool IsActionJustReleased ( const std :: string & value ); private : SDL_Joystick * joystickController = nullptr ; SDL_GameController * gameController = nullptr ; Logger * logger = nullptr ; JoystickInput (); ~ JoystickInput (); void ProcessButtonPress ( InputEvent & inputEvent ); void ProcessButtonRelease ( InputEvent & inputEvent ); void ProcessJoyhatMotion ( InputEvent & inputEvent ); void ProcessAxisMotion (); }; class JoystickAction { public : JoystickAction () : joystickInput ( JoystickInput :: GetInstance ()) {} bool IsJoystickValue ( const std :: string & actionValue ) { return joystickInput -> IsJoystickValue ( actionValue ); } void AddValue ( const std :: string & actionValue ) { if ( ! HasValue ( actionValue )) { joystickValues . emplace_back ( actionValue ); } } bool HasValue ( const std :: string & actionValue ) { return std :: find ( joystickValues . begin (), joystickValues . end (), actionValue ) != joystickValues . end (); } bool IsActionPressed () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionPressed ( value )) { return true ; } } return false ; } bool IsActionJustPressed () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionJustPressed ( value )) { return true ; } } return false ; } bool IsActionJustReleased () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionJustReleased ( value )) { return true ; } } return false ; } private : JoystickInput * joystickInput = nullptr ; std :: vector < std :: string > joystickValues ; }; #endif //JOYSTICK_INPUT_H #include \"joystick_input.h\" JoystickInput :: JoystickInput () : logger ( Logger :: GetInstance ()) {} JoystickInput ::~ JoystickInput () { SDL_JoystickClose ( joystickController ); SDL_GameControllerClose ( gameController ); } void JoystickInput :: ProcessButtonPress ( InputEvent & inputEvent ) { const std :: string & buttonValue = JOYSTICK_BUTTON_TYPE_TO_NAME_MAP [( JoystickButtonType ) inputEvent . buttonValue ]; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isJustPressed = true ; } void JoystickInput :: ProcessButtonRelease ( InputEvent & inputEvent ) { const std :: string & buttonValue = JOYSTICK_BUTTON_TYPE_TO_NAME_MAP [( JoystickButtonType ) inputEvent . buttonValue ]; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isJustReleased = true ; } void JoystickInput :: ProcessJoyhatMotion ( InputEvent & inputEvent ) { if ( inputEvent . hatValue & SDL_HAT_LEFT ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_RIGHT ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_UP ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_DOWN ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isJustReleased = true ; } } } void JoystickInput :: ProcessAxisMotion () { // LEFT AXIS // Horizontal Sint16 leftHorizontalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_HORIZONTAL_AXIS ); if ( leftHorizontalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isJustPressed = true ; } } else if ( leftHorizontalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isJustReleased = true ; } } // Vertical Sint16 leftVerticalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_VERTICAL_AXIS ); if ( leftVerticalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isJustPressed = true ; } } else if ( leftVerticalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isJustReleased = true ; } } // RIGHT AXIS // Horizontal Sint16 rightHorizontalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_HORIZONTAL_AXIS ); if ( rightHorizontalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isJustPressed = true ; } } else if ( rightHorizontalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isJustReleased = true ; } } // Vertical Sint16 rightVerticalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_VERTICAL_AXIS ); if ( rightVerticalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isJustPressed = true ; } } else if ( rightVerticalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isJustReleased = true ; } } // Left Trigger Sint16 leftTriggerValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_TRIGGER ); if ( leftTriggerValue < - ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isJustReleased = true ; } } else if ( leftTriggerValue > ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isJustPressed = true ; } } // Right Trigger Sint16 rightTriggerValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_TRIGGER ); if ( rightTriggerValue < - ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isJustReleased = true ; } } else if ( rightTriggerValue > ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isJustPressed = true ; } } } JoystickInput * JoystickInput :: GetInstance () { static JoystickInput * instance = new JoystickInput (); return instance ; } void JoystickInput :: ProcessSDLEvent ( InputEvent & inputEvent ) {} void JoystickInput :: LoadJoysticks () { int result = SDL_GameControllerAddMappingsFromFile ( \"assets/resources/game_controller_db.txt\" ); assert ( result != -1 && \"Failed to load game controller db text file!\" ); if ( SDL_NumJoysticks () > 0 ) { joystickController = SDL_JoystickOpen ( 0 ); assert ( joystickController != nullptr && \"JoystickController didn't properly load!\" ); gameController = SDL_GameControllerOpen ( 0 ); assert ( gameController != nullptr && \"GameController didn't properly load!\" ); } else { logger -> Warn ( \"No joystick plugged in, not loading joysticks!\" ); } } void JoystickInput :: ClearInputFlags () { for ( const auto & pair : JOYSTICK_BUTTON_INPUT_FLAGS ) { JOYSTICK_BUTTON_INPUT_FLAGS [ pair . first ]. isJustPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ pair . first ]. isJustReleased = false ; } } bool JoystickInput :: IsJoystickValue ( const std :: string & value ) const { return false ; } bool JoystickInput :: IsActionPressed ( const std :: string & value ) { return false ; } bool JoystickInput :: IsActionJustPressed ( const std :: string & value ) { return false ; } bool JoystickInput :: IsActionJustReleased ( const std :: string & value ) { return false ; }","title":"Input Events"},{"location":"1.foundation/5.input_management/input_events/#input-events","text":"","title":"Input Events"},{"location":"1.foundation/5.input_management/input_events/#input-event-state","text":"#ifndef INPUT_EVENT_STATE_H #define INPUT_EVENT_STATE_H #include <SDL2/SDL.h> #include \"../math/math.h\" enum class InputEventType { MOUSE , KEYBOARD , JOYSTICK , }; struct InputEvent { InputEventType type ; Uint32 sdlType ; // Mouse Vector2 mouseMotion ; bool mousePressed = false ; Uint8 mouseButton ; // Joystick Uint8 controllerId ; Sint16 buttonValue ; bool buttonPressed = false ; Uint8 hat ; Uint8 hatValue ; // Keyboard bool keyPressed = false ; SDL_Scancode keyScancode ; }; class InputEventState { public : InputEvent ProcessSDLEvent ( SDL_Event & event ) { InputEvent inputEvent ; inputEvent . sdlType = event . type ; switch ( event . type ) { // Mouse case SDL_MOUSEMOTION : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mouseMotion = Vector2 ( event . motion . x , event . motion . y ); break ; case SDL_MOUSEWHEEL : inputEvent . type = InputEventType :: MOUSE ; break ; case SDL_MOUSEBUTTONDOWN : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mousePressed = true ; inputEvent . mouseButton = event . button . button ; break ; case SDL_MOUSEBUTTONUP : inputEvent . type = InputEventType :: MOUSE ; inputEvent . mousePressed = false ; inputEvent . mouseButton = event . button . button ; break ; // Joystick case SDL_JOYBUTTONDOWN : case SDL_JOYBUTTONUP : inputEvent . type = InputEventType :: JOYSTICK ; inputEvent . controllerId = event . jbutton . which ; inputEvent . buttonValue = event . jbutton . button ; inputEvent . buttonPressed = event . jbutton . state == SDL_PRESSED ; break ; case SDL_JOYHATMOTION : inputEvent . type = InputEventType :: JOYSTICK ; inputEvent . controllerId = event . jhat . which ; inputEvent . hat = event . jhat . hat ; inputEvent . hatValue = event . jhat . value ; break ; // Keyboard case SDL_KEYDOWN : case SDL_KEYUP : if ( ! event . key . repeat ) { inputEvent . type = InputEventType :: KEYBOARD ; inputEvent . keyPressed = event . key . state == SDL_PRESSED ; inputEvent . keyScancode = event . key . keysym . scancode ; } break ; default : break ; } return inputEvent ; } }; #endif //INPUT_EVENT_STATE_H","title":"Input Event State"},{"location":"1.foundation/5.input_management/input_events/#keyboard","text":"#ifndef KEYBOARD_INPUT_H #define KEYBOARD_INPUT_H #include <string> #include <map> #include <SDL2/SDL.h> const std :: string KEYBOARD_KEY_UP { \"up\" }; const std :: string KEYBOARD_KEY_DOWN { \"down\" }; const std :: string KEYBOARD_KEY_LEFT { \"left\" }; const std :: string KEYBOARD_KEY_RIGHT { \"right\" }; const std :: string KEYBOARD_KEY_SPACE { \"space\" }; const std :: string KEYBOARD_KEY_ESC { \"esc\" }; const std :: string KEYBOARD_KEY_RETURN { \"return\" }; static std :: map < std :: string , SDL_Scancode > KEYBOARD_SCANCODE_TO_VALUE_MAPPING = { { \"0\" , SDL_SCANCODE_0 }, { \"1\" , SDL_SCANCODE_1 }, { \"2\" , SDL_SCANCODE_2 }, { \"3\" , SDL_SCANCODE_3 }, { \"4\" , SDL_SCANCODE_4 }, { \"5\" , SDL_SCANCODE_5 }, { \"6\" , SDL_SCANCODE_6 }, { \"7\" , SDL_SCANCODE_7 }, { \"8\" , SDL_SCANCODE_8 }, { \"9\" , SDL_SCANCODE_9 }, { \"a\" , SDL_SCANCODE_A }, { \"b\" , SDL_SCANCODE_B }, { \"c\" , SDL_SCANCODE_C }, { \"d\" , SDL_SCANCODE_D }, { \"e\" , SDL_SCANCODE_E }, { \"f\" , SDL_SCANCODE_F }, { \"g\" , SDL_SCANCODE_G }, { \"h\" , SDL_SCANCODE_H }, { \"i\" , SDL_SCANCODE_I }, { \"j\" , SDL_SCANCODE_J }, { \"k\" , SDL_SCANCODE_K }, { \"l\" , SDL_SCANCODE_L }, { \"m\" , SDL_SCANCODE_M }, { \"n\" , SDL_SCANCODE_N }, { \"o\" , SDL_SCANCODE_O }, { \"p\" , SDL_SCANCODE_P }, { \"q\" , SDL_SCANCODE_Q }, { \"r\" , SDL_SCANCODE_R }, { \"s\" , SDL_SCANCODE_S }, { \"t\" , SDL_SCANCODE_T }, { \"u\" , SDL_SCANCODE_U }, { \"v\" , SDL_SCANCODE_V }, { \"w\" , SDL_SCANCODE_W }, { \"x\" , SDL_SCANCODE_X }, { \"y\" , SDL_SCANCODE_Y }, { \"z\" , SDL_SCANCODE_Z }, { KEYBOARD_KEY_LEFT , SDL_SCANCODE_LEFT }, { KEYBOARD_KEY_RIGHT , SDL_SCANCODE_RIGHT }, { KEYBOARD_KEY_UP , SDL_SCANCODE_UP }, { KEYBOARD_KEY_DOWN , SDL_SCANCODE_DOWN }, { KEYBOARD_KEY_RETURN , SDL_SCANCODE_RETURN }, { KEYBOARD_KEY_SPACE , SDL_SCANCODE_SPACE }, { KEYBOARD_KEY_ESC , SDL_SCANCODE_ESCAPE }, { \"f1\" , SDL_SCANCODE_F1 }, { \"f2\" , SDL_SCANCODE_F2 }, { \"f3\" , SDL_SCANCODE_F3 }, { \"f4\" , SDL_SCANCODE_F4 }, { \"f5\" , SDL_SCANCODE_F5 }, { \"f6\" , SDL_SCANCODE_F6 }, { \"f7\" , SDL_SCANCODE_F7 }, { \"f8\" , SDL_SCANCODE_F8 }, { \"f9\" , SDL_SCANCODE_F9 }, { \"f10\" , SDL_SCANCODE_F10 }, { \"f11\" , SDL_SCANCODE_F11 }, { \"f12\" , SDL_SCANCODE_F12 } }; class KeyboardAction { public : bool isActionPressed = false ; bool isActionJustPressed = false ; bool isActionJustReleased = false ; std :: vector < SDL_Scancode > values ; SDL_Scancode lastScancodePressed = SDL_SCANCODE_UNKNOWN ; void AddValue ( const std :: string & actionValue ) { if ( KEYBOARD_SCANCODE_TO_VALUE_MAPPING . count ( actionValue ) > 0 ) { SDL_Scancode valueScancode = KEYBOARD_SCANCODE_TO_VALUE_MAPPING [ actionValue ]; values . emplace_back ( valueScancode ); } } void ProcessInputs ( const Uint8 * keyboardState ) { for ( SDL_Scancode scancodeValue : values ) { bool isKeyboardValuePressed = keyboardState [ scancodeValue ]; if ( isKeyboardValuePressed && ! isActionPressed ) { isActionPressed = true ; isActionJustPressed = true ; lastScancodePressed = scancodeValue ; break ; } else if ( ! isKeyboardValuePressed && ! isActionJustReleased && isActionPressed && scancodeValue == lastScancodePressed ) { isActionPressed = false ; isActionJustPressed = false ; isActionJustReleased = true ; } } } }; #endif //KEYBOARD_INPUT_H","title":"Keyboard"},{"location":"1.foundation/5.input_management/input_events/#mouse","text":"#ifndef MOUSE_INPUT_H #define MOUSE_INPUT_H #include <string> #include <vector> #include <algorithm> #include <SDL2/SDL.h> #include \"../math/math.h\" #include \"input_event_state.h\" const std :: string MOUSE_BUTTON_LEFT { \"mb_left\" }; const std :: string MOUSE_BUTTON_RIGHT { \"mb_right\" }; const std :: string MOUSE_BUTTON_MIDDLE { \"mb_middle\" }; class MouseInput { public : bool isMouseLeftButtonPressed = false ; bool isMouseLeftButtonJustPressed = false ; bool isMouseLeftButtonJustReleased = false ; bool isMouseRightButtonPressed = false ; bool isMouseRightButtonJustPressed = false ; bool isMouseRightButtonJustReleased = false ; static MouseInput * GetInstance (); void ClearInputFlags (); Vector2 GetMousePosition () const ; void ProcessSDLEvent ( InputEvent & inputEvent ); private : static MouseInput * instance ; Vector2 mousePosition ; MouseInput () {} }; class MouseAction { public : MouseAction () : mouseInput ( MouseInput :: GetInstance ()) {} static bool IsMouseValue ( const std :: string & actionValue ) { if ( actionValue == MOUSE_BUTTON_LEFT || actionValue == MOUSE_BUTTON_RIGHT ) { return true ; } return false ; } void AddValue ( const std :: string & actionValue ) { if ( ! HasValue ( actionValue )) { mouseValues . emplace_back ( actionValue ); } } bool HasValue ( const std :: string & actionValue ) { return std :: find ( mouseValues . begin (), mouseValues . end (), actionValue ) != mouseValues . end (); } bool IsActionPressed () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonPressed ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonPressed )) { return true ; } } return false ; } bool IsActionJustPressed () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonJustPressed ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonJustPressed )) { return true ; } } return false ; } bool IsActionJustReleased () { for ( const std :: string & value : mouseValues ) { if (( value == MOUSE_BUTTON_LEFT && mouseInput -> isMouseLeftButtonJustReleased ) || ( value == MOUSE_BUTTON_RIGHT && mouseInput -> isMouseRightButtonJustReleased )) { return true ; } } return false ; } private : std :: vector < std :: string > mouseValues ; MouseInput * mouseInput = nullptr ; }; #endif //MOUSE_INPUT_H #include \"mouse_input.h\" MouseInput * MouseInput::GetInstance () { static MouseInput * instance = new MouseInput (); return instance ; } void MouseInput::ClearInputFlags () { isMouseLeftButtonJustPressed = false ; isMouseRightButtonJustPressed = false ; isMouseLeftButtonJustReleased = false ; isMouseRightButtonJustReleased = false ; } Vector2 MouseInput::GetMousePosition () const { return mousePosition ; } void MouseInput::ProcessSDLEvent ( InputEvent & inputEvent ) { switch ( inputEvent . sdlType ) { // Mouse case SDL_MOUSEMOTION : mousePosition = inputEvent . mouseMotion ; break ; case SDL_MOUSEWHEEL : break ; case SDL_MOUSEBUTTONDOWN : if ( inputEvent . mouseButton == SDL_BUTTON_LEFT ) { isMouseLeftButtonPressed = true ; isMouseLeftButtonJustPressed = true ; } else if ( inputEvent . mouseButton == SDL_BUTTON_RIGHT ) { isMouseRightButtonPressed = true ; isMouseRightButtonJustPressed = true ; } break ; case SDL_MOUSEBUTTONUP : if ( inputEvent . mouseButton == SDL_BUTTON_LEFT ) { isMouseLeftButtonPressed = false ; isMouseLeftButtonJustPressed = false ; isMouseLeftButtonJustReleased = true ; } else if ( inputEvent . mouseButton == SDL_BUTTON_RIGHT ) { isMouseRightButtonPressed = false ; isMouseRightButtonJustPressed = false ; isMouseRightButtonJustReleased = true ; } break ; default : break ; } }","title":"Mouse"},{"location":"1.foundation/5.input_management/input_events/#joystick","text":"#ifndef JOYSTICK_INPUT_H #define JOYSTICK_INPUT_H #include <string> #include <vector> #include <unordered_map> #include <algorithm> #include <SDL2/SDL.h> #include \"input_event_state.h\" #include \"../utils/logger.h\" enum class JoystickButtonType : int { INVALID = -1 , BUTTON_A = 0 , BUTTON_B = 1 , BUTTON_X = 2 , BUTTON_Y = 3 , BUTTON_BACK = 6 , BUTTON_START = 7 , BUTTON_LEFT_SHOULDER = 4 , BUTTON_RIGHT_SHOULDER = 5 , BUTTON_LEFT_AXIS = 8 , BUTTON_RIGHT_AXIS = 9 , }; enum class JoystickDeadZone : int { AXIS = 10000 , TRIGGER = 8000 , }; enum class JoystickAxisMotion : Uint8 { LEFT_TRIGGER = 2 , RIGHT_TRIGGER = 5 , LEFT_HORIZONTAL_AXIS = 0 , LEFT_VERTICAL_AXIS = 1 , RIGHT_HORIZONTAL_AXIS = 3 , RIGHT_VERTICAL_AXIS = 4 , }; const std :: string JOYSTICK_BUTTON_A { \"joystick_button_a\" }; const std :: string JOYSTICK_BUTTON_B { \"joystick_button_b\" }; const std :: string JOYSTICK_BUTTON_X { \"joystick_button_x\" }; const std :: string JOYSTICK_BUTTON_Y { \"joystick_button_y\" }; const std :: string JOYSTICK_KEYPAD_UP { \"joystick_keypad_up\" }; const std :: string JOYSTICK_KEYPAD_DOWN { \"joystick_keypad_down\" }; const std :: string JOYSTICK_KEYPAD_RIGHT { \"joystick_keypad_right\" }; const std :: string JOYSTICK_KEYPAD_LEFT { \"joystick_keypad_left\" }; const std :: string JOYSTICK_START { \"joystick_button_start\" }; const std :: string JOYSTICK_BACK { \"joystick_button_back\" }; const std :: string JOYSTICK_LEFT_SHOULDER { \"joystick_left_shoulder\" }; const std :: string JOYSTICK_RIGHT_SHOULDER { \"joystick_right_shoulder\" }; const std :: string JOYSTICK_LEFT_TRIGGER { \"joystick_left_trigger\" }; const std :: string JOYSTICK_RIGHT_TRIGGER { \"joystick_right_trigger\" }; const std :: string JOYSTICK_LEFT_ANALOG { \"joystick_left_analog\" }; const std :: string JOYSTICK_RIGHT_ANALOG { \"joystick_right_analog\" }; const std :: string JOYSTICK_LEFT_ANALOG_UP { \"joystick_left_analog_up\" }; const std :: string JOYSTICK_LEFT_ANALOG_DOWN { \"joystick_left_analog_down\" }; const std :: string JOYSTICK_LEFT_ANALOG_RIGHT { \"joystick_left_analog_right\" }; const std :: string JOYSTICK_LEFT_ANALOG_LEFT { \"joystick_left_analog_left\" }; const std :: string JOYSTICK_RIGHT_ANALOG_UP { \"joystick_right_analog_up\" }; const std :: string JOYSTICK_RIGHT_ANALOG_DOWN { \"joystick_right_analog_down\" }; const std :: string JOYSTICK_RIGHT_ANALOG_RIGHT { \"joystick_right_analog_right\" }; const std :: string JOYSTICK_RIGHT_ANALOG_LEFT { \"joystick_right_analog_left\" }; static std :: unordered_map < std :: string , JoystickButtonType > JOYSTICK_NAME_TO_BUTTON_TYPE_MAP = { { JOYSTICK_BUTTON_A , JoystickButtonType :: BUTTON_A }, { JOYSTICK_BUTTON_B , JoystickButtonType :: BUTTON_B }, { JOYSTICK_BUTTON_X , JoystickButtonType :: BUTTON_X }, { JOYSTICK_BUTTON_Y , JoystickButtonType :: BUTTON_Y }, { JOYSTICK_START , JoystickButtonType :: BUTTON_START }, { JOYSTICK_BACK , JoystickButtonType :: BUTTON_BACK }, { JOYSTICK_LEFT_SHOULDER , JoystickButtonType :: BUTTON_LEFT_SHOULDER }, { JOYSTICK_RIGHT_SHOULDER , JoystickButtonType :: BUTTON_RIGHT_SHOULDER }, { JOYSTICK_LEFT_ANALOG , JoystickButtonType :: BUTTON_LEFT_AXIS }, { JOYSTICK_RIGHT_ANALOG , JoystickButtonType :: BUTTON_RIGHT_AXIS }, }; static std :: unordered_map < JoystickButtonType , std :: string > JOYSTICK_BUTTON_TYPE_TO_NAME_MAP = { { JoystickButtonType :: BUTTON_A , JOYSTICK_BUTTON_A }, { JoystickButtonType :: BUTTON_B , JOYSTICK_BUTTON_B }, { JoystickButtonType :: BUTTON_X , JOYSTICK_BUTTON_X }, { JoystickButtonType :: BUTTON_Y , JOYSTICK_BUTTON_Y }, { JoystickButtonType :: BUTTON_START , JOYSTICK_START }, { JoystickButtonType :: BUTTON_BACK , JOYSTICK_BACK }, { JoystickButtonType :: BUTTON_LEFT_SHOULDER , JOYSTICK_LEFT_SHOULDER }, { JoystickButtonType :: BUTTON_RIGHT_SHOULDER , JOYSTICK_RIGHT_SHOULDER }, { JoystickButtonType :: BUTTON_LEFT_AXIS , JOYSTICK_LEFT_ANALOG }, { JoystickButtonType :: BUTTON_RIGHT_AXIS , JOYSTICK_RIGHT_ANALOG }, }; static std :: unordered_map < std :: string , SDL_GameControllerButton > JOYSTICK_ACTION_BUTTON_MAPPINGS = { { JOYSTICK_BUTTON_A , SDL_CONTROLLER_BUTTON_A }, { JOYSTICK_BUTTON_B , SDL_CONTROLLER_BUTTON_B }, { JOYSTICK_BUTTON_X , SDL_CONTROLLER_BUTTON_X }, { JOYSTICK_BUTTON_Y , SDL_CONTROLLER_BUTTON_Y }, { JOYSTICK_KEYPAD_UP , SDL_CONTROLLER_BUTTON_DPAD_UP }, { JOYSTICK_KEYPAD_DOWN , SDL_CONTROLLER_BUTTON_DPAD_DOWN }, { JOYSTICK_KEYPAD_LEFT , SDL_CONTROLLER_BUTTON_DPAD_LEFT }, { JOYSTICK_KEYPAD_RIGHT , SDL_CONTROLLER_BUTTON_DPAD_RIGHT }, { JOYSTICK_START , SDL_CONTROLLER_BUTTON_START }, { JOYSTICK_BACK , SDL_CONTROLLER_BUTTON_BACK }, { JOYSTICK_LEFT_SHOULDER , SDL_CONTROLLER_BUTTON_LEFTSHOULDER }, { JOYSTICK_RIGHT_SHOULDER , SDL_CONTROLLER_BUTTON_RIGHTSHOULDER }, { JOYSTICK_LEFT_SHOULDER , SDL_CONTROLLER_BUTTON_LEFTSHOULDER }, { JOYSTICK_LEFT_ANALOG , SDL_CONTROLLER_BUTTON_LEFTSTICK }, { JOYSTICK_RIGHT_ANALOG , SDL_CONTROLLER_BUTTON_RIGHTSTICK }, // Non Game Controller Button Actions { JOYSTICK_LEFT_TRIGGER , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_TRIGGER , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_UP , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_DOWN , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_RIGHT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_LEFT_ANALOG_LEFT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_UP , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_DOWN , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_RIGHT , SDL_CONTROLLER_BUTTON_INVALID }, { JOYSTICK_RIGHT_ANALOG_LEFT , SDL_CONTROLLER_BUTTON_INVALID } }; struct JoystickInputPressState { bool isPressed = false ; bool isJustPressed = false ; bool isJustReleased = false ; }; static std :: unordered_map < std :: string , JoystickInputPressState > JOYSTICK_BUTTON_INPUT_FLAGS = { // Button Process { JOYSTICK_BUTTON_B , JoystickInputPressState {}}, { JOYSTICK_BUTTON_A , JoystickInputPressState {}}, { JOYSTICK_BUTTON_X , JoystickInputPressState {}}, { JOYSTICK_BUTTON_Y , JoystickInputPressState {}}, { JOYSTICK_START , JoystickInputPressState {}}, { JOYSTICK_BACK , JoystickInputPressState {}}, { JOYSTICK_LEFT_SHOULDER , JoystickInputPressState {}}, { JOYSTICK_RIGHT_SHOULDER , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG , JoystickInputPressState {}}, // Hat Process { JOYSTICK_KEYPAD_LEFT , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_RIGHT , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_UP , JoystickInputPressState {}}, { JOYSTICK_KEYPAD_DOWN , JoystickInputPressState {}}, // Axis Process { JOYSTICK_LEFT_ANALOG_LEFT , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_RIGHT , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_UP , JoystickInputPressState {}}, { JOYSTICK_LEFT_ANALOG_DOWN , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_LEFT , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_RIGHT , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_UP , JoystickInputPressState {}}, { JOYSTICK_RIGHT_ANALOG_DOWN , JoystickInputPressState {}}, { JOYSTICK_LEFT_TRIGGER , JoystickInputPressState {}}, { JOYSTICK_RIGHT_TRIGGER , JoystickInputPressState {}}, }; class JoystickInput { public : static JoystickInput * GetInstance (); void ProcessSDLEvent ( InputEvent & inputEvent ); void LoadJoysticks (); void ClearInputFlags (); bool IsJoystickValue ( const std :: string & value ) const ; bool IsActionPressed ( const std :: string & value ); bool IsActionJustPressed ( const std :: string & value ); bool IsActionJustReleased ( const std :: string & value ); private : SDL_Joystick * joystickController = nullptr ; SDL_GameController * gameController = nullptr ; Logger * logger = nullptr ; JoystickInput (); ~ JoystickInput (); void ProcessButtonPress ( InputEvent & inputEvent ); void ProcessButtonRelease ( InputEvent & inputEvent ); void ProcessJoyhatMotion ( InputEvent & inputEvent ); void ProcessAxisMotion (); }; class JoystickAction { public : JoystickAction () : joystickInput ( JoystickInput :: GetInstance ()) {} bool IsJoystickValue ( const std :: string & actionValue ) { return joystickInput -> IsJoystickValue ( actionValue ); } void AddValue ( const std :: string & actionValue ) { if ( ! HasValue ( actionValue )) { joystickValues . emplace_back ( actionValue ); } } bool HasValue ( const std :: string & actionValue ) { return std :: find ( joystickValues . begin (), joystickValues . end (), actionValue ) != joystickValues . end (); } bool IsActionPressed () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionPressed ( value )) { return true ; } } return false ; } bool IsActionJustPressed () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionJustPressed ( value )) { return true ; } } return false ; } bool IsActionJustReleased () { for ( const std :: string & value : joystickValues ) { if ( joystickInput -> IsActionJustReleased ( value )) { return true ; } } return false ; } private : JoystickInput * joystickInput = nullptr ; std :: vector < std :: string > joystickValues ; }; #endif //JOYSTICK_INPUT_H #include \"joystick_input.h\" JoystickInput :: JoystickInput () : logger ( Logger :: GetInstance ()) {} JoystickInput ::~ JoystickInput () { SDL_JoystickClose ( joystickController ); SDL_GameControllerClose ( gameController ); } void JoystickInput :: ProcessButtonPress ( InputEvent & inputEvent ) { const std :: string & buttonValue = JOYSTICK_BUTTON_TYPE_TO_NAME_MAP [( JoystickButtonType ) inputEvent . buttonValue ]; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isJustPressed = true ; } void JoystickInput :: ProcessButtonRelease ( InputEvent & inputEvent ) { const std :: string & buttonValue = JOYSTICK_BUTTON_TYPE_TO_NAME_MAP [( JoystickButtonType ) inputEvent . buttonValue ]; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ buttonValue ]. isJustReleased = true ; } void JoystickInput :: ProcessJoyhatMotion ( InputEvent & inputEvent ) { if ( inputEvent . hatValue & SDL_HAT_LEFT ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_LEFT ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_RIGHT ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_RIGHT ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_UP ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_UP ]. isJustReleased = true ; } } if ( inputEvent . hatValue & SDL_HAT_DOWN ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_KEYPAD_DOWN ]. isJustReleased = true ; } } } void JoystickInput :: ProcessAxisMotion () { // LEFT AXIS // Horizontal Sint16 leftHorizontalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_HORIZONTAL_AXIS ); if ( leftHorizontalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isJustPressed = true ; } } else if ( leftHorizontalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_LEFT ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_RIGHT ]. isJustReleased = true ; } } // Vertical Sint16 leftVerticalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_VERTICAL_AXIS ); if ( leftVerticalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isJustPressed = true ; } } else if ( leftVerticalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_UP ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_ANALOG_DOWN ]. isJustReleased = true ; } } // RIGHT AXIS // Horizontal Sint16 rightHorizontalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_HORIZONTAL_AXIS ); if ( rightHorizontalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isJustPressed = true ; } } else if ( rightHorizontalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_LEFT ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_RIGHT ]. isJustReleased = true ; } } // Vertical Sint16 rightVerticalValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_VERTICAL_AXIS ); if ( rightVerticalValue < - ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isJustPressed = true ; } } else if ( rightVerticalValue > ( Uint8 ) JoystickDeadZone :: AXIS ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isJustPressed = true ; } } else { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_UP ]. isJustReleased = true ; } if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_ANALOG_DOWN ]. isJustReleased = true ; } } // Left Trigger Sint16 leftTriggerValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: LEFT_TRIGGER ); if ( leftTriggerValue < - ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isJustReleased = true ; } } else if ( leftTriggerValue > ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_LEFT_TRIGGER ]. isJustPressed = true ; } } // Right Trigger Sint16 rightTriggerValue = SDL_JoystickGetAxis ( joystickController , ( Uint8 ) JoystickAxisMotion :: RIGHT_TRIGGER ); if ( rightTriggerValue < - ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isJustReleased = true ; } } else if ( rightTriggerValue > ( Uint8 ) JoystickDeadZone :: TRIGGER ) { if ( ! JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed ) { JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isPressed = true ; JOYSTICK_BUTTON_INPUT_FLAGS [ JOYSTICK_RIGHT_TRIGGER ]. isJustPressed = true ; } } } JoystickInput * JoystickInput :: GetInstance () { static JoystickInput * instance = new JoystickInput (); return instance ; } void JoystickInput :: ProcessSDLEvent ( InputEvent & inputEvent ) {} void JoystickInput :: LoadJoysticks () { int result = SDL_GameControllerAddMappingsFromFile ( \"assets/resources/game_controller_db.txt\" ); assert ( result != -1 && \"Failed to load game controller db text file!\" ); if ( SDL_NumJoysticks () > 0 ) { joystickController = SDL_JoystickOpen ( 0 ); assert ( joystickController != nullptr && \"JoystickController didn't properly load!\" ); gameController = SDL_GameControllerOpen ( 0 ); assert ( gameController != nullptr && \"GameController didn't properly load!\" ); } else { logger -> Warn ( \"No joystick plugged in, not loading joysticks!\" ); } } void JoystickInput :: ClearInputFlags () { for ( const auto & pair : JOYSTICK_BUTTON_INPUT_FLAGS ) { JOYSTICK_BUTTON_INPUT_FLAGS [ pair . first ]. isJustPressed = false ; JOYSTICK_BUTTON_INPUT_FLAGS [ pair . first ]. isJustReleased = false ; } } bool JoystickInput :: IsJoystickValue ( const std :: string & value ) const { return false ; } bool JoystickInput :: IsActionPressed ( const std :: string & value ) { return false ; } bool JoystickInput :: IsActionJustPressed ( const std :: string & value ) { return false ; } bool JoystickInput :: IsActionJustReleased ( const std :: string & value ) { return false ; }","title":"Joystick"},{"location":"1.foundation/5.input_management/input_management/","text":"Input Management Input Action #ifndef INPUT_ACTION_H #define INPUT_ACTION_H #include <vector> #include <algorithm> #include <SDL2/SDL.h> #include \"mouse_input.h\" #include \"keyboard_input.h\" #include \"joystick_input.h\" #include \"../utils/logger.h\" class InputAction { private : MouseAction mouseAction ; KeyboardAction keyboardAction ; JoystickAction joystickAction ; Logger * logger = nullptr ; public : bool isActionPressed = false ; bool isActionJustPressed = false ; bool isActionJustReleased = false ; InputAction () { logger = Logger :: GetInstance (); } void AddValue ( const std :: string & actionValue ) { if ( mouseAction . IsMouseValue ( actionValue )) { mouseAction . AddValue ( actionValue ); } else if ( joystickAction . IsJoystickValue ( actionValue )) { joystickAction . AddValue ( actionValue ); } else { keyboardAction . AddValue ( actionValue ); } } bool IsActionPressed () { if ( mouseAction . IsActionPressed ()) { return true ; } if ( keyboardAction . isActionPressed ) { return true ; } if ( joystickAction . IsActionPressed ()) { return true ; } return false ; } bool IsActionJustPressed () { if ( mouseAction . IsActionJustPressed ()) { return true ; } if ( keyboardAction . isActionJustPressed ) { return true ; } if ( joystickAction . IsActionJustPressed ()) { return true ; } return false ; } bool IsActionJustReleased () { if ( mouseAction . IsActionJustReleased ()) { return true ; } if ( keyboardAction . isActionJustReleased ) { return true ; } if ( joystickAction . IsActionJustReleased ()) { return true ; } return false ; } void ProcessInputs ( const Uint8 * keyboardState ) { keyboardAction . ProcessInputs ( keyboardState ); } void ClearInputFlags () { keyboardAction . isActionJustPressed = false ; keyboardAction . isActionJustReleased = false ; } }; #endif //INPUT_ACTION_H Input Manager #ifndef INPUT_MANAGER_H #define INPUT_MANAGER_H #include <unordered_map> #include \"input_action.h\" #include \"mouse_input.h\" #include \"joystick_input.h\" #include \"input_event_state.h\" class InputManager { public : static InputManager * GetInstance (); void Initialize (); void ProcessInputs ( SDL_Event & event ); void ClearInputFlags (); void AddAction ( const std :: string & actionName , const std :: string & actionValue ); void RemoveAction ( const std :: string & actionName ); bool IsActionPressed ( const std :: string & actionName ); bool IsActionJustPressed ( const std :: string & actionName ); bool IsActionJustReleased ( const std :: string & actionName ); InputEvent GetCurrentInputEvent () const ; private : MouseInput * mouseInput = nullptr ; JoystickInput * joystickInput = nullptr ; InputEvent currentInputEvent ; InputEventState inputEventState ; std :: unordered_map < std :: string , InputAction *> inputActions ; InputManager (); }; #endif //INPUT_MANAGER_H #include \"input_manager.h\" InputManager :: InputManager () : mouseInput ( MouseInput :: GetInstance ()), joystickInput ( JoystickInput :: GetInstance ()) {} InputManager * InputManager :: GetInstance () { static InputManager * instance = new InputManager (); return instance ; } void InputManager :: Initialize () { joystickInput -> LoadJoysticks (); } void InputManager :: ProcessInputs ( SDL_Event & event ) { currentInputEvent = inputEventState . ProcessSDLEvent ( event ); const Uint8 * keyboardState = SDL_GetKeyboardState ( nullptr ); mouseInput -> ProcessSDLEvent ( currentInputEvent ); joystickInput -> ProcessSDLEvent ( currentInputEvent ); for ( auto const & pair : inputActions ) { InputAction * inputAction = pair . second ; inputAction -> ProcessInputs ( keyboardState ); } } void InputManager :: ClearInputFlags () { mouseInput -> ClearInputFlags (); joystickInput -> ClearInputFlags (); for ( auto const & pair : inputActions ) { InputAction * inputAction = pair . second ; inputAction -> ClearInputFlags (); } } void InputManager :: AddAction ( const std :: string & actionName , const std :: string & actionValue ) { if ( inputActions . count ( actionName ) <= 0 ) { inputActions . emplace ( actionName , new InputAction ()); } inputActions [ actionName ] -> AddValue ( actionValue ); } void InputManager :: RemoveAction ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { delete inputActions [ actionName ]; inputActions . erase ( actionName ); } } bool InputManager :: IsActionPressed ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionPressed (); } return false ; } bool InputManager :: IsActionJustPressed ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionJustPressed (); } return false ; } bool InputManager :: IsActionJustReleased ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionJustReleased (); } return false ; } InputEvent InputManager :: GetCurrentInputEvent () const { return currentInputEvent ; } Processing Input Events Will add inputManager to GameEngine class. InputManager * inputManager = nullptr ; Initialize inputManager in constructor. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()), inputManager ( InputManager :: GetInstance ()) { Initialize (); } Adding new function InitializeInput . bool GameEngine::InitializeInput () { inputManager -> Initialize (); // temp adding actions inputManager -> AddAction ( \"quit\" , \"esc\" ); inputManager -> AddAction ( \"play_sound\" , \"space\" ); return true ; } Call InitializeInput in Initialize function. bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } if ( ! InitializeInput ()) { logger -> Error ( \"Failed to initialize input!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } Adding this to the bottom of the ProcessInput function. inputManager -> ProcessInputs ( event ); // Temp input processing if ( inputManager -> IsActionJustPressed ( \"quit\" )) { engineContext -> SetRunning ( false ); } if ( inputManager -> IsActionJustPressed ( \"play_sound\" )) { AudioHelper :: PlaySound ( \"test_sound\" ); } If you run the engine now, you'll be able to exit out of the game by pressing the ESC key. You can also trigger a sound effect to play by pressing the SPACE key. All source code for this section can be found here . Now that we have input management in place, it's time to expand further and build out our Entity Component System.","title":"Input Management"},{"location":"1.foundation/5.input_management/input_management/#input-management","text":"","title":"Input Management"},{"location":"1.foundation/5.input_management/input_management/#input-action","text":"#ifndef INPUT_ACTION_H #define INPUT_ACTION_H #include <vector> #include <algorithm> #include <SDL2/SDL.h> #include \"mouse_input.h\" #include \"keyboard_input.h\" #include \"joystick_input.h\" #include \"../utils/logger.h\" class InputAction { private : MouseAction mouseAction ; KeyboardAction keyboardAction ; JoystickAction joystickAction ; Logger * logger = nullptr ; public : bool isActionPressed = false ; bool isActionJustPressed = false ; bool isActionJustReleased = false ; InputAction () { logger = Logger :: GetInstance (); } void AddValue ( const std :: string & actionValue ) { if ( mouseAction . IsMouseValue ( actionValue )) { mouseAction . AddValue ( actionValue ); } else if ( joystickAction . IsJoystickValue ( actionValue )) { joystickAction . AddValue ( actionValue ); } else { keyboardAction . AddValue ( actionValue ); } } bool IsActionPressed () { if ( mouseAction . IsActionPressed ()) { return true ; } if ( keyboardAction . isActionPressed ) { return true ; } if ( joystickAction . IsActionPressed ()) { return true ; } return false ; } bool IsActionJustPressed () { if ( mouseAction . IsActionJustPressed ()) { return true ; } if ( keyboardAction . isActionJustPressed ) { return true ; } if ( joystickAction . IsActionJustPressed ()) { return true ; } return false ; } bool IsActionJustReleased () { if ( mouseAction . IsActionJustReleased ()) { return true ; } if ( keyboardAction . isActionJustReleased ) { return true ; } if ( joystickAction . IsActionJustReleased ()) { return true ; } return false ; } void ProcessInputs ( const Uint8 * keyboardState ) { keyboardAction . ProcessInputs ( keyboardState ); } void ClearInputFlags () { keyboardAction . isActionJustPressed = false ; keyboardAction . isActionJustReleased = false ; } }; #endif //INPUT_ACTION_H","title":"Input Action"},{"location":"1.foundation/5.input_management/input_management/#input-manager","text":"#ifndef INPUT_MANAGER_H #define INPUT_MANAGER_H #include <unordered_map> #include \"input_action.h\" #include \"mouse_input.h\" #include \"joystick_input.h\" #include \"input_event_state.h\" class InputManager { public : static InputManager * GetInstance (); void Initialize (); void ProcessInputs ( SDL_Event & event ); void ClearInputFlags (); void AddAction ( const std :: string & actionName , const std :: string & actionValue ); void RemoveAction ( const std :: string & actionName ); bool IsActionPressed ( const std :: string & actionName ); bool IsActionJustPressed ( const std :: string & actionName ); bool IsActionJustReleased ( const std :: string & actionName ); InputEvent GetCurrentInputEvent () const ; private : MouseInput * mouseInput = nullptr ; JoystickInput * joystickInput = nullptr ; InputEvent currentInputEvent ; InputEventState inputEventState ; std :: unordered_map < std :: string , InputAction *> inputActions ; InputManager (); }; #endif //INPUT_MANAGER_H #include \"input_manager.h\" InputManager :: InputManager () : mouseInput ( MouseInput :: GetInstance ()), joystickInput ( JoystickInput :: GetInstance ()) {} InputManager * InputManager :: GetInstance () { static InputManager * instance = new InputManager (); return instance ; } void InputManager :: Initialize () { joystickInput -> LoadJoysticks (); } void InputManager :: ProcessInputs ( SDL_Event & event ) { currentInputEvent = inputEventState . ProcessSDLEvent ( event ); const Uint8 * keyboardState = SDL_GetKeyboardState ( nullptr ); mouseInput -> ProcessSDLEvent ( currentInputEvent ); joystickInput -> ProcessSDLEvent ( currentInputEvent ); for ( auto const & pair : inputActions ) { InputAction * inputAction = pair . second ; inputAction -> ProcessInputs ( keyboardState ); } } void InputManager :: ClearInputFlags () { mouseInput -> ClearInputFlags (); joystickInput -> ClearInputFlags (); for ( auto const & pair : inputActions ) { InputAction * inputAction = pair . second ; inputAction -> ClearInputFlags (); } } void InputManager :: AddAction ( const std :: string & actionName , const std :: string & actionValue ) { if ( inputActions . count ( actionName ) <= 0 ) { inputActions . emplace ( actionName , new InputAction ()); } inputActions [ actionName ] -> AddValue ( actionValue ); } void InputManager :: RemoveAction ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { delete inputActions [ actionName ]; inputActions . erase ( actionName ); } } bool InputManager :: IsActionPressed ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionPressed (); } return false ; } bool InputManager :: IsActionJustPressed ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionJustPressed (); } return false ; } bool InputManager :: IsActionJustReleased ( const std :: string & actionName ) { if ( inputActions . count ( actionName ) > 0 ) { return inputActions [ actionName ] -> IsActionJustReleased (); } return false ; } InputEvent InputManager :: GetCurrentInputEvent () const { return currentInputEvent ; }","title":"Input Manager"},{"location":"1.foundation/5.input_management/input_management/#processing-input-events","text":"Will add inputManager to GameEngine class. InputManager * inputManager = nullptr ; Initialize inputManager in constructor. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()), inputManager ( InputManager :: GetInstance ()) { Initialize (); } Adding new function InitializeInput . bool GameEngine::InitializeInput () { inputManager -> Initialize (); // temp adding actions inputManager -> AddAction ( \"quit\" , \"esc\" ); inputManager -> AddAction ( \"play_sound\" , \"space\" ); return true ; } Call InitializeInput in Initialize function. bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } if ( ! InitializeInput ()) { logger -> Error ( \"Failed to initialize input!\" ); return false ; } logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } Adding this to the bottom of the ProcessInput function. inputManager -> ProcessInputs ( event ); // Temp input processing if ( inputManager -> IsActionJustPressed ( \"quit\" )) { engineContext -> SetRunning ( false ); } if ( inputManager -> IsActionJustPressed ( \"play_sound\" )) { AudioHelper :: PlaySound ( \"test_sound\" ); } If you run the engine now, you'll be able to exit out of the game by pressing the ESC key. You can also trigger a sound effect to play by pressing the SPACE key. All source code for this section can be found here . Now that we have input management in place, it's time to expand further and build out our Entity Component System.","title":"Processing Input Events"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/","text":"Building An ECS Entity An Entity will represented as an unsigned int . #ifndef ENTITY_H #define ENTITY_H using Entity = unsigned int ; const Entity MAX_ENTITIES = 20000 ; const Entity NULL_ENTITY = 0 ; #endif //ENTITY_H Component Components will add functionality for an entity. Component Class #ifndef COMPONENT_H #define COMPONENT_H #include <bitset> const std :: uint32_t MAX_COMPONENT_TYPES = 32 ; using ComponentType = std :: uint32_t ; using ComponentSignature = std :: bitset < MAX_COMPONENT_TYPES > ; #endif //COMPONENT_H Component Array #ifndef COMPONENT_ARRAY_H #define COMPONENT_ARRAY_H #include <unordered_map> #include <cassert> #include \"../entity/entity.h\" #include \"component.h\" class IComponentArray { public : virtual ~ IComponentArray () = default ; virtual void EntityDestroyed ( Entity entity ) = 0 ; }; template < typename T > class ComponentArray : public IComponentArray { public : void InsertNewData ( Entity entity , T component ) { assert ( entityToIndexMap . find ( entity ) == entityToIndexMap . end () && \"Component added to same entity more than once!\" ); size_t newIndex = size ; entityToIndexMap [ entity ] = newIndex ; indexToEntityMap [ newIndex ] = entity ; components [ newIndex ] = component ; size ++ ; } void UpdateData ( Entity entity , T component ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Component hasn't been added!\" ); components [ entityToIndexMap [ entity ]] = component ; } void RemoveData ( Entity entity ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Removing non-existent component!\" ); // Copy element at end into deleted element's place to maintain array density size_t indexOfRemovedEntity = entityToIndexMap [ entity ]; size_t indexOfLastElement = size - 1 ; components [ indexOfRemovedEntity ] = components [ indexOfLastElement ]; // Update map to point to moved spot Entity entityOfLastElement = indexToEntityMap [ indexOfLastElement ]; entityToIndexMap [ entityOfLastElement ] = indexOfRemovedEntity ; indexToEntityMap [ indexOfRemovedEntity ] = entityOfLastElement ; entityToIndexMap . erase ( entity ); indexToEntityMap . erase ( indexOfLastElement ); size -- ; } T & GetData ( Entity entity ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Retrieving non-existent component!\" ); return components [ entityToIndexMap [ entity ]]; } bool HasData ( Entity entity ) { return entityToIndexMap . find ( entity ) != entityToIndexMap . end (); } void EntityDestroyed ( Entity entity ) override { if ( entityToIndexMap . find ( entity ) != entityToIndexMap . end ()) { RemoveData ( entity ); } } private : std :: array < T , MAX_ENTITIES > components ; std :: unordered_map < Entity , size_t > entityToIndexMap ; std :: unordered_map < size_t , Entity > indexToEntityMap ; size_t size = 0 ; }; #endif //COMPONENT_ARRAY_H System Systems will process components for an entity based on a signature. #ifndef EC_SYSTEM_H #define EC_SYSTEM_H #include <set> #include \"../entity/entity.h\" #include \"../../scene/scene.h\" const unsigned int MAX_SYSTEMS = 32 ; class ECSystem { protected : bool enabled = false ; std :: set < Entity > entities ; public : virtual void Initialize () { enabled = true ; } virtual void RegisterEntity ( Entity entity ) { entities . insert ( entity ); } virtual void UnregisterEntity ( Entity entity ) { entities . erase ( entity ); } virtual void Enable () { enabled = true ; } virtual void Disable () { enabled = false ; } bool IsEnabled () { return enabled ; } // Event hooks virtual void Update ( float deltaTime ) {} virtual void PhysicsUpdate ( float deltaTime ) {} virtual void Render () {} virtual void OnSceneStart ( Scene * scene ) {} virtual void OnSceneEnd ( Scene * scene ) {} }; #endif //EC_SYSTEM_H Scene Entities will be placed in a scene. #ifndef SCENE_H #define SCENE_H #include <vector> #include <unordered_map> #include \"../ecs/entity/entity.h\" #include \"../utils/helper.h\" struct SceneNode { Entity entity = NULL_ENTITY ; Entity parent = NULL_ENTITY ; std :: vector < SceneNode > children = {}; }; struct Scene { SceneNode rootNode = {}; std :: unordered_map < Entity , SceneNode > sceneNodes = {}; }; #endif //SCENE_H","title":"Building An ECS"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#building-an-ecs","text":"","title":"Building An ECS"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#entity","text":"An Entity will represented as an unsigned int . #ifndef ENTITY_H #define ENTITY_H using Entity = unsigned int ; const Entity MAX_ENTITIES = 20000 ; const Entity NULL_ENTITY = 0 ; #endif //ENTITY_H","title":"Entity"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#component","text":"Components will add functionality for an entity.","title":"Component"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#component-class","text":"#ifndef COMPONENT_H #define COMPONENT_H #include <bitset> const std :: uint32_t MAX_COMPONENT_TYPES = 32 ; using ComponentType = std :: uint32_t ; using ComponentSignature = std :: bitset < MAX_COMPONENT_TYPES > ; #endif //COMPONENT_H","title":"Component Class"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#component-array","text":"#ifndef COMPONENT_ARRAY_H #define COMPONENT_ARRAY_H #include <unordered_map> #include <cassert> #include \"../entity/entity.h\" #include \"component.h\" class IComponentArray { public : virtual ~ IComponentArray () = default ; virtual void EntityDestroyed ( Entity entity ) = 0 ; }; template < typename T > class ComponentArray : public IComponentArray { public : void InsertNewData ( Entity entity , T component ) { assert ( entityToIndexMap . find ( entity ) == entityToIndexMap . end () && \"Component added to same entity more than once!\" ); size_t newIndex = size ; entityToIndexMap [ entity ] = newIndex ; indexToEntityMap [ newIndex ] = entity ; components [ newIndex ] = component ; size ++ ; } void UpdateData ( Entity entity , T component ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Component hasn't been added!\" ); components [ entityToIndexMap [ entity ]] = component ; } void RemoveData ( Entity entity ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Removing non-existent component!\" ); // Copy element at end into deleted element's place to maintain array density size_t indexOfRemovedEntity = entityToIndexMap [ entity ]; size_t indexOfLastElement = size - 1 ; components [ indexOfRemovedEntity ] = components [ indexOfLastElement ]; // Update map to point to moved spot Entity entityOfLastElement = indexToEntityMap [ indexOfLastElement ]; entityToIndexMap [ entityOfLastElement ] = indexOfRemovedEntity ; indexToEntityMap [ indexOfRemovedEntity ] = entityOfLastElement ; entityToIndexMap . erase ( entity ); indexToEntityMap . erase ( indexOfLastElement ); size -- ; } T & GetData ( Entity entity ) { assert ( entityToIndexMap . find ( entity ) != entityToIndexMap . end () && \"Retrieving non-existent component!\" ); return components [ entityToIndexMap [ entity ]]; } bool HasData ( Entity entity ) { return entityToIndexMap . find ( entity ) != entityToIndexMap . end (); } void EntityDestroyed ( Entity entity ) override { if ( entityToIndexMap . find ( entity ) != entityToIndexMap . end ()) { RemoveData ( entity ); } } private : std :: array < T , MAX_ENTITIES > components ; std :: unordered_map < Entity , size_t > entityToIndexMap ; std :: unordered_map < size_t , Entity > indexToEntityMap ; size_t size = 0 ; }; #endif //COMPONENT_ARRAY_H","title":"Component Array"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#system","text":"Systems will process components for an entity based on a signature. #ifndef EC_SYSTEM_H #define EC_SYSTEM_H #include <set> #include \"../entity/entity.h\" #include \"../../scene/scene.h\" const unsigned int MAX_SYSTEMS = 32 ; class ECSystem { protected : bool enabled = false ; std :: set < Entity > entities ; public : virtual void Initialize () { enabled = true ; } virtual void RegisterEntity ( Entity entity ) { entities . insert ( entity ); } virtual void UnregisterEntity ( Entity entity ) { entities . erase ( entity ); } virtual void Enable () { enabled = true ; } virtual void Disable () { enabled = false ; } bool IsEnabled () { return enabled ; } // Event hooks virtual void Update ( float deltaTime ) {} virtual void PhysicsUpdate ( float deltaTime ) {} virtual void Render () {} virtual void OnSceneStart ( Scene * scene ) {} virtual void OnSceneEnd ( Scene * scene ) {} }; #endif //EC_SYSTEM_H","title":"System"},{"location":"1.foundation/6.entity_component_system/building_an_ecs/#scene","text":"Entities will be placed in a scene. #ifndef SCENE_H #define SCENE_H #include <vector> #include <unordered_map> #include \"../ecs/entity/entity.h\" #include \"../utils/helper.h\" struct SceneNode { Entity entity = NULL_ENTITY ; Entity parent = NULL_ENTITY ; std :: vector < SceneNode > children = {}; }; struct Scene { SceneNode rootNode = {}; std :: unordered_map < Entity , SceneNode > sceneNodes = {}; }; #endif //SCENE_H","title":"Scene"},{"location":"1.foundation/6.entity_component_system/ecs_orchestrator/","text":"ECS Orchestrator ECS Orchestrator Class #ifndef ECS_ORCHESTRATOR_H #define ECS_ORCHESTRATOR_H #include <vector> #include \"system/ec_system_manager.h\" #include \"../scene/scene_manager.h\" class ECSOrchestrator { public : ~ ECSOrchestrator (); static ECSOrchestrator * GetInstance (); // Entity Entity CreateEntity () { return entityManager -> CreateEntity (); } // Component template < typename T > void RegisterComponent () { componentManager -> RegisterComponent < T > (); } template < typename T > void AddComponent ( Entity entity , T component ) { componentManager -> AddComponent < T > ( entity , component ); auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), true ); entityManager -> SetSignature ( entity , signature ); entityManager -> SetEnabledSignature ( entity , signature ); RefreshEntitySignatureChanged ( entity ); } template < typename T > void UpdateComponent ( Entity entity , T component ) { componentManager -> UpdateComponent ( entity , component ); } template < typename T > void RemoveComponent ( Entity entity ) { componentManager -> RemoveComponent < T > ( entity ); auto signature = entityManager -> GetSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetSignature ( entity , signature ); auto enabledSignature = entityManager -> GetEnabledSignature ( entity ); enabledSignature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetEnabledSignature ( entity , enabledSignature ); ecSystemManager -> EntitySignatureChanged ( entity , enabledSignature ); } template < typename T > void EnableComponent ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), true ); entityManager -> SetEnabledSignature ( entity , signature ); ecSystemManager -> EntitySignatureChanged ( entity , signature ); } template < typename T > void DisableComponent ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetEnabledSignature ( entity , signature ); ecSystemManager -> EntitySignatureChanged ( entity , signature ); } template < typename T > bool IsComponentEnabled ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); return ( GetComponentType < T > () & signature ) == signature ; } template < typename T > T & GetComponent ( Entity entity ) { return componentManager -> GetComponent < T > ( entity ); } template < typename T > ComponentType GetComponentType () { return componentManager -> GetComponentType < T > (); } template < typename T > bool HasComponent ( Entity entity ) { return componentManager -> HasComponent < T > ( entity ); } // EC System template < typename T > T * RegisterSystem ( ComponentSignature initialComponentSignature = {}, ECSystemRegistration ecSystemRegistration = ECSystemRegistration :: NONE ) { T * system = ecSystemManager -> RegisterSystem < T > ( ecSystemRegistration ); SetSystemSignature < T > ( initialComponentSignature ); return system ; } template < typename T > T * GetSystem () { return ecSystemManager -> GetSystem < T > (); } template < typename T > bool HasSystem () { return ecSystemManager -> HasSystem < T > (); } template < typename T > void SetSystemSignature ( ComponentSignature signature ) { ecSystemManager -> SetSignature < T > ( signature ); } template < typename T > ComponentSignature GetSystemSignature () { return ecSystemManager -> GetSignature < T > (); } // Event Hooks void UpdateSystems ( float deltaTime ); void PhysicsUpdateSystems ( float deltaTime ); void RenderSystems (); void OnSceneStartSystems (); void OnSceneEndSystems (); // Scene void PrepareSceneChange ( const std :: string & filePath ); void ChangeToScene (); void DestroyScene (); bool HasSceneToCreate () const ; bool HasSceneToDestroy () const ; void RegisterLoadedSceneNodeComponents (); void AddRootNode ( Entity rootEntity ); void AddChildNode ( Entity child , Entity parent ); bool IsNodeInScene ( Entity entity ) const ; void QueueDestroyEntity ( Entity entity ); void DestroyQueuedEntities (); Scene * GetCurrentScene (); private : ECSystemManager * ecSystemManager = nullptr ; EntityManager * entityManager = nullptr ; ComponentManager * componentManager = nullptr ; SceneManager * sceneManager = nullptr ; std :: string sceneToChangeFilePath ; bool shouldDestroySceneNextFrame = false ; std :: vector < Entity > entitiesQueuedForDeletion ; ECSOrchestrator (); void RefreshEntitySignatureChanged ( Entity entity ); void DestroyEntity ( Entity entity ); }; #endif //ECS_ORCHESTRATOR_H #include \"ecs_orchestrator.h\" ECSOrchestrator :: ECSOrchestrator () : ecSystemManager ( new ECSystemManager ()), entityManager ( EntityManager :: GetInstance ()), componentManager ( ComponentManager :: GetInstance ()), sceneManager ( SceneManager :: GetInstance ()) {} ECSOrchestrator ::~ ECSOrchestrator () { if ( ecSystemManager ) { delete ecSystemManager ; } if ( entityManager ) { delete entityManager ; } } ECSOrchestrator * ECSOrchestrator :: GetInstance () { static ECSOrchestrator * instance = new ECSOrchestrator (); return instance ; } void ECSOrchestrator :: RefreshEntitySignatureChanged ( Entity entity ) { ecSystemManager -> EntitySignatureChanged ( entity , entityManager -> GetEnabledSignature ( entity )); } void ECSOrchestrator :: PrepareSceneChange ( const std :: string & filePath ) { sceneToChangeFilePath = filePath ; shouldDestroySceneNextFrame = true ; } void ECSOrchestrator :: ChangeToScene () { sceneManager -> ChangeToScene ( sceneToChangeFilePath ); sceneToChangeFilePath . clear (); } void ECSOrchestrator :: DestroyScene () { shouldDestroySceneNextFrame = false ; } bool ECSOrchestrator :: HasSceneToCreate () const { return ! sceneToChangeFilePath . empty () && ! shouldDestroySceneNextFrame ; } bool ECSOrchestrator :: HasSceneToDestroy () const { return shouldDestroySceneNextFrame ; } void ECSOrchestrator :: RegisterLoadedSceneNodeComponents () { Scene * currentScene = sceneManager -> GetCurrentScene (); RefreshEntitySignatureChanged ( currentScene -> rootNode . entity ); for ( SceneNode childSceneNode : currentScene -> rootNode . children ) { RefreshEntitySignatureChanged ( childSceneNode . entity ); } } void ECSOrchestrator :: AddRootNode ( Entity rootEntity ) { sceneManager -> AddRootNode ( rootEntity ); RefreshEntitySignatureChanged ( rootEntity ); } void ECSOrchestrator :: AddChildNode ( Entity child , Entity parent ) { sceneManager -> AddChildNode ( child , parent ); RefreshEntitySignatureChanged ( child ); } void ECSOrchestrator :: QueueDestroyEntity ( Entity entity ) { entitiesQueuedForDeletion . emplace_back ( entity ); } void ECSOrchestrator :: DestroyQueuedEntities () { for ( Entity entity : entitiesQueuedForDeletion ) { DestroyEntity ( entity ); } entitiesQueuedForDeletion . clear (); } void ECSOrchestrator :: DestroyEntity ( Entity entity ) { sceneManager -> DeleteNode ( entity ); componentManager -> EntityDestroyed ( entity ); ecSystemManager -> EntityDestroyed ( entity ); } bool ECSOrchestrator :: IsNodeInScene ( Entity entity ) const { return sceneManager -> IsNodeInScene ( entity ); } Scene * ECSOrchestrator :: GetCurrentScene () { return sceneManager -> GetCurrentScene (); } void ECSOrchestrator :: UpdateSystems ( float deltaTime ) { ecSystemManager -> UpdateSystems ( deltaTime ); } void ECSOrchestrator :: PhysicsUpdateSystems ( float deltaTime ) { ecSystemManager -> PhysicsUpdateSystems ( deltaTime ); } void ECSOrchestrator :: RenderSystems () { ecSystemManager -> RenderSystems (); } void ECSOrchestrator :: OnSceneStartSystems () { ecSystemManager -> OnSceneStartSystems ( sceneManager -> GetCurrentScene ()); } void ECSOrchestrator :: OnSceneEndSystems () { ecSystemManager -> OnSceneEndSystems ( sceneManager -> GetCurrentScene ()); } Now when you run the code, everything should function as normal but defined with the ecs system. And just like every other section, you can find the source code in github here . Now that we have an ecs let's now serialize scene and project properties with json.","title":"ECS Orchestrator"},{"location":"1.foundation/6.entity_component_system/ecs_orchestrator/#ecs-orchestrator","text":"","title":"ECS Orchestrator"},{"location":"1.foundation/6.entity_component_system/ecs_orchestrator/#ecs-orchestrator-class","text":"#ifndef ECS_ORCHESTRATOR_H #define ECS_ORCHESTRATOR_H #include <vector> #include \"system/ec_system_manager.h\" #include \"../scene/scene_manager.h\" class ECSOrchestrator { public : ~ ECSOrchestrator (); static ECSOrchestrator * GetInstance (); // Entity Entity CreateEntity () { return entityManager -> CreateEntity (); } // Component template < typename T > void RegisterComponent () { componentManager -> RegisterComponent < T > (); } template < typename T > void AddComponent ( Entity entity , T component ) { componentManager -> AddComponent < T > ( entity , component ); auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), true ); entityManager -> SetSignature ( entity , signature ); entityManager -> SetEnabledSignature ( entity , signature ); RefreshEntitySignatureChanged ( entity ); } template < typename T > void UpdateComponent ( Entity entity , T component ) { componentManager -> UpdateComponent ( entity , component ); } template < typename T > void RemoveComponent ( Entity entity ) { componentManager -> RemoveComponent < T > ( entity ); auto signature = entityManager -> GetSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetSignature ( entity , signature ); auto enabledSignature = entityManager -> GetEnabledSignature ( entity ); enabledSignature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetEnabledSignature ( entity , enabledSignature ); ecSystemManager -> EntitySignatureChanged ( entity , enabledSignature ); } template < typename T > void EnableComponent ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), true ); entityManager -> SetEnabledSignature ( entity , signature ); ecSystemManager -> EntitySignatureChanged ( entity , signature ); } template < typename T > void DisableComponent ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); signature . set ( componentManager -> GetComponentType < T > (), false ); entityManager -> SetEnabledSignature ( entity , signature ); ecSystemManager -> EntitySignatureChanged ( entity , signature ); } template < typename T > bool IsComponentEnabled ( Entity entity ) { auto signature = entityManager -> GetEnabledSignature ( entity ); return ( GetComponentType < T > () & signature ) == signature ; } template < typename T > T & GetComponent ( Entity entity ) { return componentManager -> GetComponent < T > ( entity ); } template < typename T > ComponentType GetComponentType () { return componentManager -> GetComponentType < T > (); } template < typename T > bool HasComponent ( Entity entity ) { return componentManager -> HasComponent < T > ( entity ); } // EC System template < typename T > T * RegisterSystem ( ComponentSignature initialComponentSignature = {}, ECSystemRegistration ecSystemRegistration = ECSystemRegistration :: NONE ) { T * system = ecSystemManager -> RegisterSystem < T > ( ecSystemRegistration ); SetSystemSignature < T > ( initialComponentSignature ); return system ; } template < typename T > T * GetSystem () { return ecSystemManager -> GetSystem < T > (); } template < typename T > bool HasSystem () { return ecSystemManager -> HasSystem < T > (); } template < typename T > void SetSystemSignature ( ComponentSignature signature ) { ecSystemManager -> SetSignature < T > ( signature ); } template < typename T > ComponentSignature GetSystemSignature () { return ecSystemManager -> GetSignature < T > (); } // Event Hooks void UpdateSystems ( float deltaTime ); void PhysicsUpdateSystems ( float deltaTime ); void RenderSystems (); void OnSceneStartSystems (); void OnSceneEndSystems (); // Scene void PrepareSceneChange ( const std :: string & filePath ); void ChangeToScene (); void DestroyScene (); bool HasSceneToCreate () const ; bool HasSceneToDestroy () const ; void RegisterLoadedSceneNodeComponents (); void AddRootNode ( Entity rootEntity ); void AddChildNode ( Entity child , Entity parent ); bool IsNodeInScene ( Entity entity ) const ; void QueueDestroyEntity ( Entity entity ); void DestroyQueuedEntities (); Scene * GetCurrentScene (); private : ECSystemManager * ecSystemManager = nullptr ; EntityManager * entityManager = nullptr ; ComponentManager * componentManager = nullptr ; SceneManager * sceneManager = nullptr ; std :: string sceneToChangeFilePath ; bool shouldDestroySceneNextFrame = false ; std :: vector < Entity > entitiesQueuedForDeletion ; ECSOrchestrator (); void RefreshEntitySignatureChanged ( Entity entity ); void DestroyEntity ( Entity entity ); }; #endif //ECS_ORCHESTRATOR_H #include \"ecs_orchestrator.h\" ECSOrchestrator :: ECSOrchestrator () : ecSystemManager ( new ECSystemManager ()), entityManager ( EntityManager :: GetInstance ()), componentManager ( ComponentManager :: GetInstance ()), sceneManager ( SceneManager :: GetInstance ()) {} ECSOrchestrator ::~ ECSOrchestrator () { if ( ecSystemManager ) { delete ecSystemManager ; } if ( entityManager ) { delete entityManager ; } } ECSOrchestrator * ECSOrchestrator :: GetInstance () { static ECSOrchestrator * instance = new ECSOrchestrator (); return instance ; } void ECSOrchestrator :: RefreshEntitySignatureChanged ( Entity entity ) { ecSystemManager -> EntitySignatureChanged ( entity , entityManager -> GetEnabledSignature ( entity )); } void ECSOrchestrator :: PrepareSceneChange ( const std :: string & filePath ) { sceneToChangeFilePath = filePath ; shouldDestroySceneNextFrame = true ; } void ECSOrchestrator :: ChangeToScene () { sceneManager -> ChangeToScene ( sceneToChangeFilePath ); sceneToChangeFilePath . clear (); } void ECSOrchestrator :: DestroyScene () { shouldDestroySceneNextFrame = false ; } bool ECSOrchestrator :: HasSceneToCreate () const { return ! sceneToChangeFilePath . empty () && ! shouldDestroySceneNextFrame ; } bool ECSOrchestrator :: HasSceneToDestroy () const { return shouldDestroySceneNextFrame ; } void ECSOrchestrator :: RegisterLoadedSceneNodeComponents () { Scene * currentScene = sceneManager -> GetCurrentScene (); RefreshEntitySignatureChanged ( currentScene -> rootNode . entity ); for ( SceneNode childSceneNode : currentScene -> rootNode . children ) { RefreshEntitySignatureChanged ( childSceneNode . entity ); } } void ECSOrchestrator :: AddRootNode ( Entity rootEntity ) { sceneManager -> AddRootNode ( rootEntity ); RefreshEntitySignatureChanged ( rootEntity ); } void ECSOrchestrator :: AddChildNode ( Entity child , Entity parent ) { sceneManager -> AddChildNode ( child , parent ); RefreshEntitySignatureChanged ( child ); } void ECSOrchestrator :: QueueDestroyEntity ( Entity entity ) { entitiesQueuedForDeletion . emplace_back ( entity ); } void ECSOrchestrator :: DestroyQueuedEntities () { for ( Entity entity : entitiesQueuedForDeletion ) { DestroyEntity ( entity ); } entitiesQueuedForDeletion . clear (); } void ECSOrchestrator :: DestroyEntity ( Entity entity ) { sceneManager -> DeleteNode ( entity ); componentManager -> EntityDestroyed ( entity ); ecSystemManager -> EntityDestroyed ( entity ); } bool ECSOrchestrator :: IsNodeInScene ( Entity entity ) const { return sceneManager -> IsNodeInScene ( entity ); } Scene * ECSOrchestrator :: GetCurrentScene () { return sceneManager -> GetCurrentScene (); } void ECSOrchestrator :: UpdateSystems ( float deltaTime ) { ecSystemManager -> UpdateSystems ( deltaTime ); } void ECSOrchestrator :: PhysicsUpdateSystems ( float deltaTime ) { ecSystemManager -> PhysicsUpdateSystems ( deltaTime ); } void ECSOrchestrator :: RenderSystems () { ecSystemManager -> RenderSystems (); } void ECSOrchestrator :: OnSceneStartSystems () { ecSystemManager -> OnSceneStartSystems ( sceneManager -> GetCurrentScene ()); } void ECSOrchestrator :: OnSceneEndSystems () { ecSystemManager -> OnSceneEndSystems ( sceneManager -> GetCurrentScene ()); } Now when you run the code, everything should function as normal but defined with the ecs system. And just like every other section, you can find the source code in github here . Now that we have an ecs let's now serialize scene and project properties with json.","title":"ECS Orchestrator Class"},{"location":"1.foundation/6.entity_component_system/managers/","text":"Managers Entity Manager #ifndef ENTITY_MANAGER_H #define ENTITY_MANAGER_H #include <array> #include <vector> #include <queue> #include <unordered_map> #include <cassert> #include \"entity.h\" #include \"../component/component.h\" class EntityManager { public : static EntityManager * GetInstance (); Entity CreateEntity (); void DestroyEntity ( Entity entity ); void DeleteEntitiesQueuedForDeletion (); unsigned int GetAliveEntities (); void SetSignature ( Entity entity , ComponentSignature signature ); void SetEnabledSignature ( Entity entity , ComponentSignature signature ); void ResetEnabledSignature ( Entity entity ); ComponentSignature GetSignature ( Entity entity ); ComponentSignature GetEnabledSignature ( Entity entity ); private : unsigned int entityIdCounter = 1 ; // Starts at 1 as 0 is invalid unsigned int livingEntityCounter = 0 ; std :: queue < Entity > availableEntityIds ; std :: array < ComponentSignature , MAX_ENTITIES > signatures ; std :: array < ComponentSignature , MAX_ENTITIES > enabledSignatures ; std :: vector < Entity > entitiesToDelete ; EntityManager () = default ; Entity GetUniqueEntityId (); }; #endif //ENTITY_MANAGER_H #include \"entity_manager.h\" #include \"../../utils/helper.h\" EntityManager * EntityManager::GetInstance () { static EntityManager * instance = new EntityManager (); return instance ; } Entity EntityManager::CreateEntity () { assert ( livingEntityCounter < MAX_ENTITIES && \"Too many entities to create!\" ); livingEntityCounter ++ ; return GetUniqueEntityId (); } void EntityManager::DestroyEntity ( Entity entity ) { entitiesToDelete . insert ( entitiesToDelete . end (), 1 , entity ); livingEntityCounter -- ; } void EntityManager::DeleteEntitiesQueuedForDeletion () { for ( Entity entity : entitiesToDelete ) { signatures [ entity ]. reset (); enabledSignatures [ entity ]. reset (); availableEntityIds . push ( entity ); } entitiesToDelete . clear (); } unsigned int EntityManager :: GetAliveEntities () { return livingEntityCounter ; } void EntityManager :: SetSignature ( Entity entity , ComponentSignature signature ) { signatures [ entity ] = signature ; } ComponentSignature EntityManager :: GetSignature ( Entity entity ) { return signatures [ entity ]; } ComponentSignature EntityManager :: GetEnabledSignature ( Entity entity ) { return enabledSignatures [ entity ]; } void EntityManager :: SetEnabledSignature ( Entity entity , ComponentSignature signature ) { enabledSignatures [ entity ] = signature ; } void EntityManager :: ResetEnabledSignature ( Entity entity ) { enabledSignatures [ entity ] = signatures [ entity ]; } Entity EntityManager :: GetUniqueEntityId () { if ( availableEntityIds . empty ()) { availableEntityIds . push ( entityIdCounter ); entityIdCounter ++ ; } Entity newEntityId = availableEntityIds . front (); availableEntityIds . pop (); return newEntityId ; } Component Manager #ifndef COMPONENT_MANAGER_H #define COMPONENT_MANAGER_H #include <unordered_map> #include <memory> #include <iostream> #include \"component.h\" #include \"component_array.h\" class ComponentManager { private : std :: unordered_map < const char * , ComponentType > componentTypes ; std :: unordered_map < const char * , IComponentArray *> componentArrays ; unsigned int componentIndex = 0 ; ComponentManager () = default ; template < typename T > ComponentArray < T >* GetComponentArray () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) != componentTypes . end () && \"Component not registered before use.\" ); return ( ComponentArray < T >* ) componentArrays [ typeName ]; } public : static ComponentManager * GetInstance (); template < typename T > void RegisterComponent () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) == componentTypes . end () && \"Registering component type more than once!\" ); componentTypes . insert ({ typeName , componentIndex }); componentArrays . insert ({ typeName , new ComponentArray < T > ()}); componentIndex ++ ; } template < typename T > ComponentType GetComponentType () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) != componentTypes . end () && \"Component not registered!\" ); return componentTypes [ typeName ]; } template < typename T > void AddComponent ( Entity entity , T component ) { GetComponentArray < T > () -> InsertNewData ( entity , component ); } template < typename T > void UpdateComponent ( Entity entity , T component ) { GetComponentArray < T > () -> UpdateData ( entity , component ); } template < typename T > void RemoveComponent ( Entity entity ) { GetComponentArray < T > () -> RemoveData ( entity ); } template < typename T > T & GetComponent ( Entity entity ) { return GetComponentArray < T > () -> GetData ( entity ); } template < typename T > bool HasComponent ( Entity entity ) { return GetComponentArray < T > () -> HasData ( entity ); } void EntityDestroyed ( Entity entity ); }; #endif //COMPONENT_MANAGER_H #include \"component_manager.h\" ComponentManager * ComponentManager::GetInstance () { static ComponentManager * instance = new ComponentManager (); return instance ; } void ComponentManager::EntityDestroyed ( Entity entity ) { for ( auto const & pair : componentArrays ) { auto const & component = pair . second ; component -> EntityDestroyed ( entity ); } } EC System Manager #ifndef ENTITY_MANAGER_H #define ENTITY_MANAGER_H #include <array> #include <vector> #include <queue> #include <unordered_map> #include <cassert> #include \"entity.h\" #include \"../component/component.h\" class EntityManager { public : static EntityManager * GetInstance (); Entity CreateEntity (); void DestroyEntity ( Entity entity ); void DeleteEntitiesQueuedForDeletion (); unsigned int GetAliveEntities (); void SetSignature ( Entity entity , ComponentSignature signature ); void SetEnabledSignature ( Entity entity , ComponentSignature signature ); void ResetEnabledSignature ( Entity entity ); ComponentSignature GetSignature ( Entity entity ); ComponentSignature GetEnabledSignature ( Entity entity ); private : unsigned int entityIdCounter = 1 ; // Starts at 1 as 0 is invalid unsigned int livingEntityCounter = 0 ; std :: queue < Entity > availableEntityIds ; std :: array < ComponentSignature , MAX_ENTITIES > signatures ; std :: array < ComponentSignature , MAX_ENTITIES > enabledSignatures ; std :: vector < Entity > entitiesToDelete ; EntityManager () = default ; Entity GetUniqueEntityId (); }; #endif //ENTITY_MANAGER_H #include \"entity_manager.h\" #include \"../../utils/helper.h\" EntityManager * EntityManager::GetInstance () { static EntityManager * instance = new EntityManager (); return instance ; } Entity EntityManager::CreateEntity () { assert ( livingEntityCounter < MAX_ENTITIES && \"Too many entities to create!\" ); livingEntityCounter ++ ; return GetUniqueEntityId (); } void EntityManager::DestroyEntity ( Entity entity ) { entitiesToDelete . insert ( entitiesToDelete . end (), 1 , entity ); livingEntityCounter -- ; } void EntityManager::DeleteEntitiesQueuedForDeletion () { for ( Entity entity : entitiesToDelete ) { signatures [ entity ]. reset (); enabledSignatures [ entity ]. reset (); availableEntityIds . push ( entity ); } entitiesToDelete . clear (); } unsigned int EntityManager :: GetAliveEntities () { return livingEntityCounter ; } void EntityManager :: SetSignature ( Entity entity , ComponentSignature signature ) { signatures [ entity ] = signature ; } ComponentSignature EntityManager :: GetSignature ( Entity entity ) { return signatures [ entity ]; } ComponentSignature EntityManager :: GetEnabledSignature ( Entity entity ) { return enabledSignatures [ entity ]; } void EntityManager :: SetEnabledSignature ( Entity entity , ComponentSignature signature ) { enabledSignatures [ entity ] = signature ; } void EntityManager :: ResetEnabledSignature ( Entity entity ) { enabledSignatures [ entity ] = signatures [ entity ]; } Entity EntityManager :: GetUniqueEntityId () { if ( availableEntityIds . empty ()) { availableEntityIds . push ( entityIdCounter ); entityIdCounter ++ ; } Entity newEntityId = availableEntityIds . front (); availableEntityIds . pop (); return newEntityId ; }","title":"Managers"},{"location":"1.foundation/6.entity_component_system/managers/#managers","text":"","title":"Managers"},{"location":"1.foundation/6.entity_component_system/managers/#entity-manager","text":"#ifndef ENTITY_MANAGER_H #define ENTITY_MANAGER_H #include <array> #include <vector> #include <queue> #include <unordered_map> #include <cassert> #include \"entity.h\" #include \"../component/component.h\" class EntityManager { public : static EntityManager * GetInstance (); Entity CreateEntity (); void DestroyEntity ( Entity entity ); void DeleteEntitiesQueuedForDeletion (); unsigned int GetAliveEntities (); void SetSignature ( Entity entity , ComponentSignature signature ); void SetEnabledSignature ( Entity entity , ComponentSignature signature ); void ResetEnabledSignature ( Entity entity ); ComponentSignature GetSignature ( Entity entity ); ComponentSignature GetEnabledSignature ( Entity entity ); private : unsigned int entityIdCounter = 1 ; // Starts at 1 as 0 is invalid unsigned int livingEntityCounter = 0 ; std :: queue < Entity > availableEntityIds ; std :: array < ComponentSignature , MAX_ENTITIES > signatures ; std :: array < ComponentSignature , MAX_ENTITIES > enabledSignatures ; std :: vector < Entity > entitiesToDelete ; EntityManager () = default ; Entity GetUniqueEntityId (); }; #endif //ENTITY_MANAGER_H #include \"entity_manager.h\" #include \"../../utils/helper.h\" EntityManager * EntityManager::GetInstance () { static EntityManager * instance = new EntityManager (); return instance ; } Entity EntityManager::CreateEntity () { assert ( livingEntityCounter < MAX_ENTITIES && \"Too many entities to create!\" ); livingEntityCounter ++ ; return GetUniqueEntityId (); } void EntityManager::DestroyEntity ( Entity entity ) { entitiesToDelete . insert ( entitiesToDelete . end (), 1 , entity ); livingEntityCounter -- ; } void EntityManager::DeleteEntitiesQueuedForDeletion () { for ( Entity entity : entitiesToDelete ) { signatures [ entity ]. reset (); enabledSignatures [ entity ]. reset (); availableEntityIds . push ( entity ); } entitiesToDelete . clear (); } unsigned int EntityManager :: GetAliveEntities () { return livingEntityCounter ; } void EntityManager :: SetSignature ( Entity entity , ComponentSignature signature ) { signatures [ entity ] = signature ; } ComponentSignature EntityManager :: GetSignature ( Entity entity ) { return signatures [ entity ]; } ComponentSignature EntityManager :: GetEnabledSignature ( Entity entity ) { return enabledSignatures [ entity ]; } void EntityManager :: SetEnabledSignature ( Entity entity , ComponentSignature signature ) { enabledSignatures [ entity ] = signature ; } void EntityManager :: ResetEnabledSignature ( Entity entity ) { enabledSignatures [ entity ] = signatures [ entity ]; } Entity EntityManager :: GetUniqueEntityId () { if ( availableEntityIds . empty ()) { availableEntityIds . push ( entityIdCounter ); entityIdCounter ++ ; } Entity newEntityId = availableEntityIds . front (); availableEntityIds . pop (); return newEntityId ; }","title":"Entity Manager"},{"location":"1.foundation/6.entity_component_system/managers/#component-manager","text":"#ifndef COMPONENT_MANAGER_H #define COMPONENT_MANAGER_H #include <unordered_map> #include <memory> #include <iostream> #include \"component.h\" #include \"component_array.h\" class ComponentManager { private : std :: unordered_map < const char * , ComponentType > componentTypes ; std :: unordered_map < const char * , IComponentArray *> componentArrays ; unsigned int componentIndex = 0 ; ComponentManager () = default ; template < typename T > ComponentArray < T >* GetComponentArray () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) != componentTypes . end () && \"Component not registered before use.\" ); return ( ComponentArray < T >* ) componentArrays [ typeName ]; } public : static ComponentManager * GetInstance (); template < typename T > void RegisterComponent () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) == componentTypes . end () && \"Registering component type more than once!\" ); componentTypes . insert ({ typeName , componentIndex }); componentArrays . insert ({ typeName , new ComponentArray < T > ()}); componentIndex ++ ; } template < typename T > ComponentType GetComponentType () { const char * typeName = typeid ( T ). name (); assert ( componentTypes . find ( typeName ) != componentTypes . end () && \"Component not registered!\" ); return componentTypes [ typeName ]; } template < typename T > void AddComponent ( Entity entity , T component ) { GetComponentArray < T > () -> InsertNewData ( entity , component ); } template < typename T > void UpdateComponent ( Entity entity , T component ) { GetComponentArray < T > () -> UpdateData ( entity , component ); } template < typename T > void RemoveComponent ( Entity entity ) { GetComponentArray < T > () -> RemoveData ( entity ); } template < typename T > T & GetComponent ( Entity entity ) { return GetComponentArray < T > () -> GetData ( entity ); } template < typename T > bool HasComponent ( Entity entity ) { return GetComponentArray < T > () -> HasData ( entity ); } void EntityDestroyed ( Entity entity ); }; #endif //COMPONENT_MANAGER_H #include \"component_manager.h\" ComponentManager * ComponentManager::GetInstance () { static ComponentManager * instance = new ComponentManager (); return instance ; } void ComponentManager::EntityDestroyed ( Entity entity ) { for ( auto const & pair : componentArrays ) { auto const & component = pair . second ; component -> EntityDestroyed ( entity ); } }","title":"Component Manager"},{"location":"1.foundation/6.entity_component_system/managers/#ec-system-manager","text":"#ifndef ENTITY_MANAGER_H #define ENTITY_MANAGER_H #include <array> #include <vector> #include <queue> #include <unordered_map> #include <cassert> #include \"entity.h\" #include \"../component/component.h\" class EntityManager { public : static EntityManager * GetInstance (); Entity CreateEntity (); void DestroyEntity ( Entity entity ); void DeleteEntitiesQueuedForDeletion (); unsigned int GetAliveEntities (); void SetSignature ( Entity entity , ComponentSignature signature ); void SetEnabledSignature ( Entity entity , ComponentSignature signature ); void ResetEnabledSignature ( Entity entity ); ComponentSignature GetSignature ( Entity entity ); ComponentSignature GetEnabledSignature ( Entity entity ); private : unsigned int entityIdCounter = 1 ; // Starts at 1 as 0 is invalid unsigned int livingEntityCounter = 0 ; std :: queue < Entity > availableEntityIds ; std :: array < ComponentSignature , MAX_ENTITIES > signatures ; std :: array < ComponentSignature , MAX_ENTITIES > enabledSignatures ; std :: vector < Entity > entitiesToDelete ; EntityManager () = default ; Entity GetUniqueEntityId (); }; #endif //ENTITY_MANAGER_H #include \"entity_manager.h\" #include \"../../utils/helper.h\" EntityManager * EntityManager::GetInstance () { static EntityManager * instance = new EntityManager (); return instance ; } Entity EntityManager::CreateEntity () { assert ( livingEntityCounter < MAX_ENTITIES && \"Too many entities to create!\" ); livingEntityCounter ++ ; return GetUniqueEntityId (); } void EntityManager::DestroyEntity ( Entity entity ) { entitiesToDelete . insert ( entitiesToDelete . end (), 1 , entity ); livingEntityCounter -- ; } void EntityManager::DeleteEntitiesQueuedForDeletion () { for ( Entity entity : entitiesToDelete ) { signatures [ entity ]. reset (); enabledSignatures [ entity ]. reset (); availableEntityIds . push ( entity ); } entitiesToDelete . clear (); } unsigned int EntityManager :: GetAliveEntities () { return livingEntityCounter ; } void EntityManager :: SetSignature ( Entity entity , ComponentSignature signature ) { signatures [ entity ] = signature ; } ComponentSignature EntityManager :: GetSignature ( Entity entity ) { return signatures [ entity ]; } ComponentSignature EntityManager :: GetEnabledSignature ( Entity entity ) { return enabledSignatures [ entity ]; } void EntityManager :: SetEnabledSignature ( Entity entity , ComponentSignature signature ) { enabledSignatures [ entity ] = signature ; } void EntityManager :: ResetEnabledSignature ( Entity entity ) { enabledSignatures [ entity ] = signatures [ entity ]; } Entity EntityManager :: GetUniqueEntityId () { if ( availableEntityIds . empty ()) { availableEntityIds . push ( entityIdCounter ); entityIdCounter ++ ; } Entity newEntityId = availableEntityIds . front (); availableEntityIds . pop (); return newEntityId ; }","title":"EC System Manager"},{"location":"1.foundation/7.serializing_with_json/creating_scene_json_files/","text":"Creating Scene Json Files Scene Loader #ifndef SCENE_LOADER_H #define SCENE_LOADER_H #include \"scene.h\" #include \"../ecs/entity/entity_manager.h\" #include \"../ecs/component/component_manager.h\" #include \"../ecs/component/components/scene_component.h\" #include \"../ecs/component/components/transform2d_component.h\" #include \"../ecs/component/components/text_label_component.h\" #include \"../ecs/component/components/sprite_component.h\" #include \"../data/asset_manager.h\" #include \"../utils/file_helper.h\" #include \"../utils/json_helper.h\" class SceneNodeJsonParser { private : EntityManager * entityManager = nullptr ; ComponentManager * componentManager = nullptr ; AssetManager * assetManager = nullptr ; unsigned int GetEntityNameCount ( const std :: string & name , const SceneNode & parentSceneNode ); std :: string GetUniqueSceneNodeName ( const std :: string & name , const SceneNode & parentSceneNode ); SceneComponent GenerateSceneComponent ( const std :: string & nodeName , const SceneNode & parentSceneNode , const nlohmann :: json & nodeTagsJsonArray ); void ParseComponentArray ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentJsonArray ); void ParseTransform2DComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); void ParseSpriteComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); void ParseTextLabelComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); public : SceneNodeJsonParser () : entityManager ( EntityManager :: GetInstance ()), componentManager ( ComponentManager :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()) {} SceneNode ParseSceneJson ( Scene * scene , const nlohmann :: json & nodeJson , bool isRoot , const SceneNode & parentSceneNode = {}); }; class SceneLoader { public : static Scene * LoadSceneFile ( const std :: string & filePath ); }; #endif //SCENE_LOADER_H #include \"scene_loader.h\" unsigned int SceneNodeJsonParser :: GetEntityNameCount ( const std :: string & name , const SceneNode & parentSceneNode ) { unsigned int enitityNameCount = 0 ; for ( const SceneNode & childrenSceneNode : parentSceneNode . children ) { SceneComponent sceneComponent = componentManager -> GetComponent < SceneComponent > ( childrenSceneNode . entity ); std :: string childName = sceneComponent . name ; const std :: string & childNumberAtTheEndString = Helper :: GetNumberFromEndOfString ( childName ); if ( childNumberAtTheEndString . empty ()) { continue ; } childName . resize ( childName . size () - childNumberAtTheEndString . size ()); unsigned int childNumberAtEnd = Helper :: ConvertStringToUnsignedInt ( childNumberAtTheEndString ); enitityNameCount = std :: max ( enitityNameCount , childNumberAtEnd ); } return enitityNameCount ; } std :: string SceneNodeJsonParser :: GetUniqueSceneNodeName ( const std :: string & name , const SceneNode & parentSceneNode ) { if ( ! parentSceneNode . children . empty ()) { unsigned int entitiesWithSameNameCount = GetEntityNameCount ( name , parentSceneNode ); if ( entitiesWithSameNameCount > 0 ) { unsigned int uniqueId = entitiesWithSameNameCount + 1 ; const std :: string & numberAtEndString = Helper :: GetNumberFromEndOfString ( name ); std :: string nameWithoutNumber = Helper :: RemoveNumberFromEndOfString ( name ); // Make sure provided number isn't higher than unique id if ( ! numberAtEndString . empty ()) { unsigned int numberAtTheEnd = Helper :: ConvertStringToUnsignedInt ( numberAtEndString ); uniqueId = std :: max ( uniqueId , numberAtTheEnd ); } return nameWithoutNumber + std :: to_string ( uniqueId ); } } return name ; } SceneComponent SceneNodeJsonParser :: GenerateSceneComponent ( const std :: string & nodeName , const SceneNode & parentSceneNode , const nlohmann :: json & nodeTagsJsonArray ) { std :: vector < std :: string > nodeTags = {}; for ( auto & nodeTag : nodeTagsJsonArray ) { nodeTags . emplace_back ( nodeTag ); } return SceneComponent { GetUniqueSceneNodeName ( nodeName , parentSceneNode ), nodeTags }; } void SceneNodeJsonParser :: ParseComponentArray ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentJsonArray ) { for ( nlohmann :: json nodeComponentJson : nodeComponentJsonArray ) { nlohmann :: json :: iterator it = nodeComponentJson . begin (); const std :: string & nodeComponentType = it . key (); nlohmann :: json nodeComponentObjectJson = it . value (); // TODO: Map to functions with keys if ( nodeComponentType == \"transform2D\" ) { ParseTransform2DComponent ( sceneNode , nodeComponentObjectJson ); } else if ( nodeComponentType == \"sprite\" ) { ParseSpriteComponent ( sceneNode , nodeComponentObjectJson ); } else if ( nodeComponentType == \"text_label\" ) { ParseTextLabelComponent ( sceneNode , nodeComponentObjectJson ); } } } void SceneNodeJsonParser :: ParseTransform2DComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { nlohmann :: json nodeTransform2DPosition = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"position\" ); nlohmann :: json nodeTransform2DScale = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"scale\" ); const Vector2 nodePosition = Vector2 ( JsonHelper :: Get < float > ( nodeTransform2DPosition , \"x\" ), JsonHelper :: Get < float > ( nodeTransform2DPosition , \"y\" )); const Vector2 nodeScale = Vector2 ( JsonHelper :: Get < float > ( nodeTransform2DScale , \"x\" ), JsonHelper :: Get < float > ( nodeTransform2DScale , \"y\" )); const float nodeRotation = JsonHelper :: Get < float > ( nodeComponentObjectJson , \"rotation\" ); const int nodeZIndex = JsonHelper :: Get < int > ( nodeComponentObjectJson , \"z_index\" ); const bool nodeZIndexIsRelativeToParent = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"z_index_relative_to_parent\" ); const bool nodeIgnoreCamera = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"ignore_camera\" ); componentManager -> AddComponent ( sceneNode . entity , Transform2DComponent { . position = nodePosition , . scale = nodeScale , . rotation = nodeRotation , . zIndex = nodeZIndex , . isZIndexRelativeToParent = nodeZIndexIsRelativeToParent , . ignoreCamera = nodeIgnoreCamera }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); bool isTransformComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); signature . set ( componentManager -> GetComponentType < Transform2DComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); if ( isTransformComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } void SceneNodeJsonParser :: ParseSpriteComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { const std :: string & nodeTexturePath = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"texture_path\" ); nlohmann :: json nodeDrawSourceJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"draw_source\" ); const float nodeDrawSourceX = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"x\" ); const float nodeDrawSourceY = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"y\" ); const float nodeDrawSourceWidth = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"width\" ); const float nodeDrawSourceHeight = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"height\" ); const bool nodeFlipX = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"flip_x\" ); const bool nodeFlipY = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"flip_x\" ); nlohmann :: json nodeModulateJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"modulate\" ); const Color nodeModulate = Color :: NormalizedColor ( JsonHelper :: Get < int > ( nodeModulateJson , \"red\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"green\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"blue\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"alpha\" ) ); componentManager -> AddComponent ( sceneNode . entity , SpriteComponent { . texture = nodeTexturePath . empty () ? nullptr : assetManager -> GetTexture ( nodeTexturePath ), . drawSource = Rect2 ( nodeDrawSourceX , nodeDrawSourceY , nodeDrawSourceWidth , nodeDrawSourceHeight ), . flipX = nodeFlipX , . flipY = nodeFlipY , . modulate = nodeModulate }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); signature . set ( componentManager -> GetComponentType < SpriteComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); const bool isSpriteEnabled = ! nodeTexturePath . empty (); bool isSpriteComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); if ( isSpriteEnabled && isSpriteComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } void SceneNodeJsonParser :: ParseTextLabelComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { const std :: string & nodeText = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"text\" ); const std :: string & nodeFontUID = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"font_uid\" ); nlohmann :: json nodeColorJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"color\" ); const Color nodeColor = Color :: NormalizedColor ( JsonHelper :: Get < int > ( nodeColorJson , \"red\" ), JsonHelper :: Get < int > ( nodeColorJson , \"green\" ), JsonHelper :: Get < int > ( nodeColorJson , \"blue\" ), JsonHelper :: Get < int > ( nodeColorJson , \"alpha\" ) ); componentManager -> AddComponent ( sceneNode . entity , TextLabelComponent { . text = nodeText , . font = nodeFontUID . empty () ? nullptr : assetManager -> GetFont ( nodeFontUID ), . color = nodeColor }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); signature . set ( componentManager -> GetComponentType < TextLabelComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); const bool isTextLabelEnabled = ! nodeFontUID . empty (); bool isTextLabelComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); if ( isTextLabelEnabled && isTextLabelComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } SceneNode SceneNodeJsonParser :: ParseSceneJson ( Scene * scene , const nlohmann :: json & nodeJson , bool isRoot , const SceneNode & parentSceneNode ) { SceneNode sceneNode ; if ( parentSceneNode . entity != NULL_ENTITY ) { sceneNode = { entityManager -> CreateEntity (), parentSceneNode . entity }; } else { sceneNode = { entityManager -> CreateEntity () }; } // Configure scene component const std :: string & nodeName = JsonHelper :: Get < std :: string > ( nodeJson , \"name\" ); const std :: string & nodeType = JsonHelper :: Get < std :: string > ( nodeJson , \"type\" ); nlohmann :: json nodeTagsJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"tags\" ); const std :: string & nodeExternalSceneSource = JsonHelper :: Get < std :: string > ( nodeJson , \"external_scene_source\" ); componentManager -> AddComponent ( sceneNode . entity , GenerateSceneComponent ( nodeName , parentSceneNode , nodeTagsJsonArray )); // Rest of components nlohmann :: json nodeComponentJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"components\" ); ParseComponentArray ( sceneNode , nodeComponentJsonArray ); nlohmann :: json nodeChildrenJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"children\" ); for ( nlohmann :: json nodeChildJson : nodeChildrenJsonArray ) { SceneNode childNode = ParseSceneJson ( scene , nodeChildJson , false , sceneNode ); sceneNode . children . emplace_back ( childNode ); } scene -> sceneNodes . emplace ( sceneNode . entity , sceneNode ); if ( isRoot ) { scene -> rootNode = sceneNode ; } return sceneNode ; } Scene * SceneLoader :: LoadSceneFile ( const std :: string & filePath ) { Scene * loadedScene = new Scene (); if ( FileHelper :: DoesFileExist ( filePath )) { nlohmann :: json sceneJson = JsonFileHelper :: LoadJsonFile ( filePath ); static SceneNodeJsonParser sceneNodeJsonParser ; sceneNodeJsonParser . ParseSceneJson ( loadedScene , sceneJson , true ); } else { Logger :: GetInstance () -> Error ( \"Scene file '%s' not found!\" , filePath . c_str ()); } return loadedScene ; } More Changes to the Game Engine Class Will update the Update function to account for scene changes. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const Uint32 currentTime = SDL_GetTicks (); static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = Timing :: Update :: MILLISECONDS_PER_TICK / projectProperties -> GetTargetFPS (); unsigned int timeToWait = FRAME_TARGET_TIME - ( currentTime - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); if ( ecsOrchestrator -> HasSceneToCreate ()) { ecsOrchestrator -> ChangeToScene (); ecsOrchestrator -> RegisterLoadedSceneNodeComponents (); ecsOrchestrator -> OnSceneStartSystems (); } const float variableDeltaTime = ( currentTime - lastFrameTime ) / static_cast < float > ( Timing :: Update :: MILLISECONDS_PER_TICK ); ecsOrchestrator -> UpdateSystems ( variableDeltaTime ); PhysicsUpdate (); inputManager -> ClearInputFlags (); if ( ecsOrchestrator -> HasSceneToDestroy ()) { ecsOrchestrator -> DestroyScene (); } ecsOrchestrator -> DestroyQueuedEntities (); lastFrameTime = SDL_GetTicks (); } Update the Initialize function to change to initial scene. bool GameEngine::Initialize () { // Initialize stuff above ... assetManager -> LoadProjectConfigurations ( projectProperties -> GetAssetConfigurations ()); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Load initial scene ecsOrchestrator -> PrepareSceneChange ( projectProperties -> GetInitialScenePath ()); // Temp play music AudioHelper :: PlayMusic ( \"assets/audio/music/test_music.wav\" ); return true ; } If we now run Red Engine it should work as expected with no changes. The source code for this section can be found here . Now that we have scene loading with json it's time to start defining our engine api as well as implement more functionality.","title":"Creating Scene Json Files"},{"location":"1.foundation/7.serializing_with_json/creating_scene_json_files/#creating-scene-json-files","text":"","title":"Creating Scene Json Files"},{"location":"1.foundation/7.serializing_with_json/creating_scene_json_files/#scene-loader","text":"#ifndef SCENE_LOADER_H #define SCENE_LOADER_H #include \"scene.h\" #include \"../ecs/entity/entity_manager.h\" #include \"../ecs/component/component_manager.h\" #include \"../ecs/component/components/scene_component.h\" #include \"../ecs/component/components/transform2d_component.h\" #include \"../ecs/component/components/text_label_component.h\" #include \"../ecs/component/components/sprite_component.h\" #include \"../data/asset_manager.h\" #include \"../utils/file_helper.h\" #include \"../utils/json_helper.h\" class SceneNodeJsonParser { private : EntityManager * entityManager = nullptr ; ComponentManager * componentManager = nullptr ; AssetManager * assetManager = nullptr ; unsigned int GetEntityNameCount ( const std :: string & name , const SceneNode & parentSceneNode ); std :: string GetUniqueSceneNodeName ( const std :: string & name , const SceneNode & parentSceneNode ); SceneComponent GenerateSceneComponent ( const std :: string & nodeName , const SceneNode & parentSceneNode , const nlohmann :: json & nodeTagsJsonArray ); void ParseComponentArray ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentJsonArray ); void ParseTransform2DComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); void ParseSpriteComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); void ParseTextLabelComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ); public : SceneNodeJsonParser () : entityManager ( EntityManager :: GetInstance ()), componentManager ( ComponentManager :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()) {} SceneNode ParseSceneJson ( Scene * scene , const nlohmann :: json & nodeJson , bool isRoot , const SceneNode & parentSceneNode = {}); }; class SceneLoader { public : static Scene * LoadSceneFile ( const std :: string & filePath ); }; #endif //SCENE_LOADER_H #include \"scene_loader.h\" unsigned int SceneNodeJsonParser :: GetEntityNameCount ( const std :: string & name , const SceneNode & parentSceneNode ) { unsigned int enitityNameCount = 0 ; for ( const SceneNode & childrenSceneNode : parentSceneNode . children ) { SceneComponent sceneComponent = componentManager -> GetComponent < SceneComponent > ( childrenSceneNode . entity ); std :: string childName = sceneComponent . name ; const std :: string & childNumberAtTheEndString = Helper :: GetNumberFromEndOfString ( childName ); if ( childNumberAtTheEndString . empty ()) { continue ; } childName . resize ( childName . size () - childNumberAtTheEndString . size ()); unsigned int childNumberAtEnd = Helper :: ConvertStringToUnsignedInt ( childNumberAtTheEndString ); enitityNameCount = std :: max ( enitityNameCount , childNumberAtEnd ); } return enitityNameCount ; } std :: string SceneNodeJsonParser :: GetUniqueSceneNodeName ( const std :: string & name , const SceneNode & parentSceneNode ) { if ( ! parentSceneNode . children . empty ()) { unsigned int entitiesWithSameNameCount = GetEntityNameCount ( name , parentSceneNode ); if ( entitiesWithSameNameCount > 0 ) { unsigned int uniqueId = entitiesWithSameNameCount + 1 ; const std :: string & numberAtEndString = Helper :: GetNumberFromEndOfString ( name ); std :: string nameWithoutNumber = Helper :: RemoveNumberFromEndOfString ( name ); // Make sure provided number isn't higher than unique id if ( ! numberAtEndString . empty ()) { unsigned int numberAtTheEnd = Helper :: ConvertStringToUnsignedInt ( numberAtEndString ); uniqueId = std :: max ( uniqueId , numberAtTheEnd ); } return nameWithoutNumber + std :: to_string ( uniqueId ); } } return name ; } SceneComponent SceneNodeJsonParser :: GenerateSceneComponent ( const std :: string & nodeName , const SceneNode & parentSceneNode , const nlohmann :: json & nodeTagsJsonArray ) { std :: vector < std :: string > nodeTags = {}; for ( auto & nodeTag : nodeTagsJsonArray ) { nodeTags . emplace_back ( nodeTag ); } return SceneComponent { GetUniqueSceneNodeName ( nodeName , parentSceneNode ), nodeTags }; } void SceneNodeJsonParser :: ParseComponentArray ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentJsonArray ) { for ( nlohmann :: json nodeComponentJson : nodeComponentJsonArray ) { nlohmann :: json :: iterator it = nodeComponentJson . begin (); const std :: string & nodeComponentType = it . key (); nlohmann :: json nodeComponentObjectJson = it . value (); // TODO: Map to functions with keys if ( nodeComponentType == \"transform2D\" ) { ParseTransform2DComponent ( sceneNode , nodeComponentObjectJson ); } else if ( nodeComponentType == \"sprite\" ) { ParseSpriteComponent ( sceneNode , nodeComponentObjectJson ); } else if ( nodeComponentType == \"text_label\" ) { ParseTextLabelComponent ( sceneNode , nodeComponentObjectJson ); } } } void SceneNodeJsonParser :: ParseTransform2DComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { nlohmann :: json nodeTransform2DPosition = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"position\" ); nlohmann :: json nodeTransform2DScale = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"scale\" ); const Vector2 nodePosition = Vector2 ( JsonHelper :: Get < float > ( nodeTransform2DPosition , \"x\" ), JsonHelper :: Get < float > ( nodeTransform2DPosition , \"y\" )); const Vector2 nodeScale = Vector2 ( JsonHelper :: Get < float > ( nodeTransform2DScale , \"x\" ), JsonHelper :: Get < float > ( nodeTransform2DScale , \"y\" )); const float nodeRotation = JsonHelper :: Get < float > ( nodeComponentObjectJson , \"rotation\" ); const int nodeZIndex = JsonHelper :: Get < int > ( nodeComponentObjectJson , \"z_index\" ); const bool nodeZIndexIsRelativeToParent = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"z_index_relative_to_parent\" ); const bool nodeIgnoreCamera = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"ignore_camera\" ); componentManager -> AddComponent ( sceneNode . entity , Transform2DComponent { . position = nodePosition , . scale = nodeScale , . rotation = nodeRotation , . zIndex = nodeZIndex , . isZIndexRelativeToParent = nodeZIndexIsRelativeToParent , . ignoreCamera = nodeIgnoreCamera }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); bool isTransformComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); signature . set ( componentManager -> GetComponentType < Transform2DComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); if ( isTransformComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } void SceneNodeJsonParser :: ParseSpriteComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { const std :: string & nodeTexturePath = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"texture_path\" ); nlohmann :: json nodeDrawSourceJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"draw_source\" ); const float nodeDrawSourceX = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"x\" ); const float nodeDrawSourceY = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"y\" ); const float nodeDrawSourceWidth = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"width\" ); const float nodeDrawSourceHeight = JsonHelper :: Get < float > ( nodeDrawSourceJson , \"height\" ); const bool nodeFlipX = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"flip_x\" ); const bool nodeFlipY = JsonHelper :: Get < bool > ( nodeComponentObjectJson , \"flip_x\" ); nlohmann :: json nodeModulateJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"modulate\" ); const Color nodeModulate = Color :: NormalizedColor ( JsonHelper :: Get < int > ( nodeModulateJson , \"red\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"green\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"blue\" ), JsonHelper :: Get < int > ( nodeModulateJson , \"alpha\" ) ); componentManager -> AddComponent ( sceneNode . entity , SpriteComponent { . texture = nodeTexturePath . empty () ? nullptr : assetManager -> GetTexture ( nodeTexturePath ), . drawSource = Rect2 ( nodeDrawSourceX , nodeDrawSourceY , nodeDrawSourceWidth , nodeDrawSourceHeight ), . flipX = nodeFlipX , . flipY = nodeFlipY , . modulate = nodeModulate }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); signature . set ( componentManager -> GetComponentType < SpriteComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); const bool isSpriteEnabled = ! nodeTexturePath . empty (); bool isSpriteComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); if ( isSpriteEnabled && isSpriteComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } void SceneNodeJsonParser :: ParseTextLabelComponent ( SceneNode & sceneNode , const nlohmann :: json & nodeComponentObjectJson ) { const std :: string & nodeText = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"text\" ); const std :: string & nodeFontUID = JsonHelper :: Get < std :: string > ( nodeComponentObjectJson , \"font_uid\" ); nlohmann :: json nodeColorJson = JsonHelper :: Get < nlohmann :: json > ( nodeComponentObjectJson , \"color\" ); const Color nodeColor = Color :: NormalizedColor ( JsonHelper :: Get < int > ( nodeColorJson , \"red\" ), JsonHelper :: Get < int > ( nodeColorJson , \"green\" ), JsonHelper :: Get < int > ( nodeColorJson , \"blue\" ), JsonHelper :: Get < int > ( nodeColorJson , \"alpha\" ) ); componentManager -> AddComponent ( sceneNode . entity , TextLabelComponent { . text = nodeText , . font = nodeFontUID . empty () ? nullptr : assetManager -> GetFont ( nodeFontUID ), . color = nodeColor }); auto signature = entityManager -> GetEnabledSignature ( sceneNode . entity ); signature . set ( componentManager -> GetComponentType < TextLabelComponent > (), true ); entityManager -> SetSignature ( sceneNode . entity , signature ); const bool isTextLabelEnabled = ! nodeFontUID . empty (); bool isTextLabelComponentEnabled = JsonHelper :: GetDefault < bool > ( nodeComponentObjectJson , \"enabled\" , true ); if ( isTextLabelEnabled && isTextLabelComponentEnabled ) { entityManager -> SetEnabledSignature ( sceneNode . entity , signature ); } } SceneNode SceneNodeJsonParser :: ParseSceneJson ( Scene * scene , const nlohmann :: json & nodeJson , bool isRoot , const SceneNode & parentSceneNode ) { SceneNode sceneNode ; if ( parentSceneNode . entity != NULL_ENTITY ) { sceneNode = { entityManager -> CreateEntity (), parentSceneNode . entity }; } else { sceneNode = { entityManager -> CreateEntity () }; } // Configure scene component const std :: string & nodeName = JsonHelper :: Get < std :: string > ( nodeJson , \"name\" ); const std :: string & nodeType = JsonHelper :: Get < std :: string > ( nodeJson , \"type\" ); nlohmann :: json nodeTagsJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"tags\" ); const std :: string & nodeExternalSceneSource = JsonHelper :: Get < std :: string > ( nodeJson , \"external_scene_source\" ); componentManager -> AddComponent ( sceneNode . entity , GenerateSceneComponent ( nodeName , parentSceneNode , nodeTagsJsonArray )); // Rest of components nlohmann :: json nodeComponentJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"components\" ); ParseComponentArray ( sceneNode , nodeComponentJsonArray ); nlohmann :: json nodeChildrenJsonArray = JsonHelper :: Get < nlohmann :: json > ( nodeJson , \"children\" ); for ( nlohmann :: json nodeChildJson : nodeChildrenJsonArray ) { SceneNode childNode = ParseSceneJson ( scene , nodeChildJson , false , sceneNode ); sceneNode . children . emplace_back ( childNode ); } scene -> sceneNodes . emplace ( sceneNode . entity , sceneNode ); if ( isRoot ) { scene -> rootNode = sceneNode ; } return sceneNode ; } Scene * SceneLoader :: LoadSceneFile ( const std :: string & filePath ) { Scene * loadedScene = new Scene (); if ( FileHelper :: DoesFileExist ( filePath )) { nlohmann :: json sceneJson = JsonFileHelper :: LoadJsonFile ( filePath ); static SceneNodeJsonParser sceneNodeJsonParser ; sceneNodeJsonParser . ParseSceneJson ( loadedScene , sceneJson , true ); } else { Logger :: GetInstance () -> Error ( \"Scene file '%s' not found!\" , filePath . c_str ()); } return loadedScene ; }","title":"Scene Loader"},{"location":"1.foundation/7.serializing_with_json/creating_scene_json_files/#more-changes-to-the-game-engine-class","text":"Will update the Update function to account for scene changes. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const Uint32 currentTime = SDL_GetTicks (); static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = Timing :: Update :: MILLISECONDS_PER_TICK / projectProperties -> GetTargetFPS (); unsigned int timeToWait = FRAME_TARGET_TIME - ( currentTime - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); if ( ecsOrchestrator -> HasSceneToCreate ()) { ecsOrchestrator -> ChangeToScene (); ecsOrchestrator -> RegisterLoadedSceneNodeComponents (); ecsOrchestrator -> OnSceneStartSystems (); } const float variableDeltaTime = ( currentTime - lastFrameTime ) / static_cast < float > ( Timing :: Update :: MILLISECONDS_PER_TICK ); ecsOrchestrator -> UpdateSystems ( variableDeltaTime ); PhysicsUpdate (); inputManager -> ClearInputFlags (); if ( ecsOrchestrator -> HasSceneToDestroy ()) { ecsOrchestrator -> DestroyScene (); } ecsOrchestrator -> DestroyQueuedEntities (); lastFrameTime = SDL_GetTicks (); } Update the Initialize function to change to initial scene. bool GameEngine::Initialize () { // Initialize stuff above ... assetManager -> LoadProjectConfigurations ( projectProperties -> GetAssetConfigurations ()); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Load initial scene ecsOrchestrator -> PrepareSceneChange ( projectProperties -> GetInitialScenePath ()); // Temp play music AudioHelper :: PlayMusic ( \"assets/audio/music/test_music.wav\" ); return true ; } If we now run Red Engine it should work as expected with no changes. The source code for this section can be found here . Now that we have scene loading with json it's time to start defining our engine api as well as implement more functionality.","title":"More Changes to the Game Engine Class"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/","text":"Parsing JSON Properties File Nlohmann Json Red Engine will use the nlohmann json library to help with parsing json files. Json Helper The JsonHelper class will be used to help validate json fields and the JsonFileHelper to load json files. #ifndef JSON_HELPER_H #define JSON_HELPER_H #include <iostream> #include <fstream> #include <cassert> #include <json/json.hpp> class JsonHelper { public : template < typename T > static T Get ( const nlohmann :: json & json , const std :: string & key ) { if ( json . contains ( key )) { return json . at ( key ); } std :: cerr << \"Key '\" << key << \"' doesn't exist!\" << std :: endl ; assert ( false && \"Key doesn't exist in json!\" ); return T (); // Not reached, just added to have returns for all code paths } template < typename T > static T GetDefault ( const nlohmann :: json & json , const std :: string & key , T defaultValue ) { if ( json . contains ( key )) { return json . at ( key ); } return defaultValue ; } }; class JsonFileHelper { public : static nlohmann :: json LoadJsonFile ( const std :: string & filePath ) { std :: ifstream i ( filePath ); nlohmann :: json json ; i >> json ; return json ; } }; #endif //JSON_HELPER_H Project Properties Example of properties.json . { \"game_title\" : \"2D Test\" , \"initial_scene\" : \"scenes/main.sscn\" , \"base_resolution\" : { \"width\" : 800 , \"height\" : 600 }, \"colliders_visible\" : true , \"target_fps\" : 60 , \"background_color\" : { \"red\" : 50 , \"green\" : 50 , \"blue\" : 50 }, \"assets\" : [ { \"type\" : \"texture\" , \"file_path\" : \"assets/images/melissa_walk_animation.png\" , \"wrap_s\" : \"clamp_to_border\" , \"wrap_t\" : \"clamp_to_border\" , \"filter_min\" : \"nearest\" , \"filter_max\" : \"nearest\" }, { \"type\" : \"font\" , \"uid\" : \"verdana-32\" , \"file_path\" : \"assets/fonts/verdana.ttf\" , \"size\" : 32 }, { \"type\" : \"music\" , \"file_path\" : \"assets/audio/music/test_music.wav\" }, { \"type\" : \"sound\" , \"file_path\" : \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\" : [ { \"name\" : \"quit\" , \"values\" : [ \"esc\" ] }, { \"name\" : \"move_left\" , \"values\" : [ \"left\" ] }, { \"name\" : \"move_right\" , \"values\" : [ \"right\" ] } ] } Game Engine Class Add a new function to load properties json file. bool GameEngine::LoadProjectProperties () { const char * projectPropertiesPath = \"properties.json\" ; if ( ! FileHelper :: DoesFileExist ( projectPropertiesPath )) { logger -> Error ( \"Unable to find properties file '%s'\" , projectPropertiesPath ); return false ; } projectProperties -> SetProjectProperties ( JsonFileHelper :: LoadJsonFile ( projectPropertiesPath )); return true ; } We should now call this before everything else in the Initialize function. bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! LoadProjectProperties ()) { logger -> Error ( \"Failed to load project properties!\" ); return false ; } if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } if ( ! InitializeInput ()) { logger -> Error ( \"Failed to initialize input!\" ); return false ; } if ( ! InitializeECS ()) { logger -> Error ( \"Failed to initialize ECS!\" ); return false ; } assetManager -> LoadProjectConfigurations ( projectProperties -> GetAssetConfigurations ()); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } Now that we are initializing the project properties by passing in the data loading in from the json properties file. Don't forget to remove the LoadTexture , LoadMusic , LoadSound , and AddAction function calls as these are no longer needed in game_engine.cpp . The source code for this section can be found here .","title":"Parsing JSON Properties File"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/#parsing-json-properties-file","text":"","title":"Parsing JSON Properties File"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/#nlohmann-json","text":"Red Engine will use the nlohmann json library to help with parsing json files.","title":"Nlohmann Json"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/#json-helper","text":"The JsonHelper class will be used to help validate json fields and the JsonFileHelper to load json files. #ifndef JSON_HELPER_H #define JSON_HELPER_H #include <iostream> #include <fstream> #include <cassert> #include <json/json.hpp> class JsonHelper { public : template < typename T > static T Get ( const nlohmann :: json & json , const std :: string & key ) { if ( json . contains ( key )) { return json . at ( key ); } std :: cerr << \"Key '\" << key << \"' doesn't exist!\" << std :: endl ; assert ( false && \"Key doesn't exist in json!\" ); return T (); // Not reached, just added to have returns for all code paths } template < typename T > static T GetDefault ( const nlohmann :: json & json , const std :: string & key , T defaultValue ) { if ( json . contains ( key )) { return json . at ( key ); } return defaultValue ; } }; class JsonFileHelper { public : static nlohmann :: json LoadJsonFile ( const std :: string & filePath ) { std :: ifstream i ( filePath ); nlohmann :: json json ; i >> json ; return json ; } }; #endif //JSON_HELPER_H","title":"Json Helper"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/#project-properties","text":"Example of properties.json . { \"game_title\" : \"2D Test\" , \"initial_scene\" : \"scenes/main.sscn\" , \"base_resolution\" : { \"width\" : 800 , \"height\" : 600 }, \"colliders_visible\" : true , \"target_fps\" : 60 , \"background_color\" : { \"red\" : 50 , \"green\" : 50 , \"blue\" : 50 }, \"assets\" : [ { \"type\" : \"texture\" , \"file_path\" : \"assets/images/melissa_walk_animation.png\" , \"wrap_s\" : \"clamp_to_border\" , \"wrap_t\" : \"clamp_to_border\" , \"filter_min\" : \"nearest\" , \"filter_max\" : \"nearest\" }, { \"type\" : \"font\" , \"uid\" : \"verdana-32\" , \"file_path\" : \"assets/fonts/verdana.ttf\" , \"size\" : 32 }, { \"type\" : \"music\" , \"file_path\" : \"assets/audio/music/test_music.wav\" }, { \"type\" : \"sound\" , \"file_path\" : \"assets/audio/sound/test_sound_effect.wav\" } ], \"input_actions\" : [ { \"name\" : \"quit\" , \"values\" : [ \"esc\" ] }, { \"name\" : \"move_left\" , \"values\" : [ \"left\" ] }, { \"name\" : \"move_right\" , \"values\" : [ \"right\" ] } ] }","title":"Project Properties"},{"location":"1.foundation/7.serializing_with_json/parsing_json_properties_file/#game-engine-class","text":"Add a new function to load properties json file. bool GameEngine::LoadProjectProperties () { const char * projectPropertiesPath = \"properties.json\" ; if ( ! FileHelper :: DoesFileExist ( projectPropertiesPath )) { logger -> Error ( \"Unable to find properties file '%s'\" , projectPropertiesPath ); return false ; } projectProperties -> SetProjectProperties ( JsonFileHelper :: LoadJsonFile ( projectPropertiesPath )); return true ; } We should now call this before everything else in the Initialize function. bool GameEngine::Initialize () { logger -> Debug ( \"Initializing...\" ); if ( ! LoadProjectProperties ()) { logger -> Error ( \"Failed to load project properties!\" ); return false ; } if ( ! InitializeSDL ()) { logger -> Error ( \"Failed to initialize SDL!\" ); return false ; } if ( ! InitializeAudio ()) { logger -> Error ( \"Failed to initialize audio!\" ); return false ; } if ( ! InitializeRendering ()) { logger -> Error ( \"Failed to initialize rendering!\" ); return false ; } if ( ! InitializeInput ()) { logger -> Error ( \"Failed to initialize input!\" ); return false ; } if ( ! InitializeECS ()) { logger -> Error ( \"Failed to initialize ECS!\" ); return false ; } assetManager -> LoadProjectConfigurations ( projectProperties -> GetAssetConfigurations ()); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); engineContext -> SetRunning ( true ); // Temp play music AudioHelper :: PlayMusic ( \"test_music\" ); return true ; } Now that we are initializing the project properties by passing in the data loading in from the json properties file. Don't forget to remove the LoadTexture , LoadMusic , LoadSound , and AddAction function calls as these are no longer needed in game_engine.cpp . The source code for this section can be found here .","title":"Game Engine Class"},{"location":"2.engine_api/about/","text":"Engine API Coming soon...","title":"Defining Red Engine API"},{"location":"2.engine_api/about/#engine-api","text":"Coming soon...","title":"Engine API"},{"location":"3.games/about/","text":"Games Coming soon...","title":"Making Games"},{"location":"3.games/about/#games","text":"Coming soon...","title":"Games"},{"location":"source_code/source_code/","text":"Source Code The full source code of the tutorials are on github and can be found here .","title":"Source Code"},{"location":"source_code/source_code/#source-code","text":"The full source code of the tutorials are on github and can be found here .","title":"Source Code"}]}