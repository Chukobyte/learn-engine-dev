{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To Learn Engine Dev About Welcome to a tutorial series for creating a simple game engine from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future. Purpose The purpose of this tutorial series is to provide a step by step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with our engine to test it out! Prerequisites Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL. Structure Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Tech Stack The engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code","title":"Introduction"},{"location":"#welcome-to-learn-engine-dev","text":"","title":"Welcome To Learn Engine Dev"},{"location":"#about","text":"Welcome to a tutorial series for creating a simple game engine from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future.","title":"About"},{"location":"#purpose","text":"The purpose of this tutorial series is to provide a step by step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with our engine to test it out!","title":"Purpose"},{"location":"#prerequisites","text":"Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL.","title":"Prerequisites"},{"location":"#structure","text":"Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo .","title":"Structure"},{"location":"#tech-stack","text":"The engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code","title":"Tech Stack"},{"location":"embedding_python/custom_python_module/","text":"Custom Python Module Creating a Game Library There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/game_lib . With that being said we will move our python code (including from the previous section) into ./include/game_lib/python . Python Modules Class We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining our engine api. To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents our engine version. Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./game_lib/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Custom Python Module"},{"location":"embedding_python/custom_python_module/#custom-python-module","text":"","title":"Custom Python Module"},{"location":"embedding_python/custom_python_module/#creating-a-game-library","text":"There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/game_lib . With that being said we will move our python code (including from the previous section) into ./include/game_lib/python .","title":"Creating a Game Library"},{"location":"embedding_python/custom_python_module/#python-modules-class","text":"We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining our engine api. To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents our engine version. Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./game_lib/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Python Modules Class"},{"location":"embedding_python/embedding_further/","text":"Embedding Further PyHelper Class So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { private : PyObject * pyObj ; public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here . Creating A Python Instance in C++ We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call our engine api from within python scripts.","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#embedding-further","text":"","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#pyhelper-class","text":"So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { private : PyObject * pyObj ; public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here .","title":"PyHelper Class"},{"location":"embedding_python/embedding_further/#creating-a-python-instance-in-c","text":"We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call our engine api from within python scripts.","title":"Creating A Python Instance in C++"},{"location":"embedding_python/hello_python/","text":"Hello Python Dependencies For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the learn_engine_dev executable. Build For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := learn_engine_dev # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : ./ $( BUILD_OBJECT ) format : astyle -n --style = google --recursive src/*.cpp Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55. Hello World It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from our engine and also be able to call C++ functions from a python script. Let's work on that next! Execute A Python Function From C++ Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into our engine and create classes to generalize some of our usages of the Python API.","title":"Hello Python"},{"location":"embedding_python/hello_python/#hello-python","text":"","title":"Hello Python"},{"location":"embedding_python/hello_python/#dependencies","text":"For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the learn_engine_dev executable.","title":"Dependencies"},{"location":"embedding_python/hello_python/#build","text":"For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := learn_engine_dev # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : ./ $( BUILD_OBJECT ) format : astyle -n --style = google --recursive src/*.cpp Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55.","title":"Build"},{"location":"embedding_python/hello_python/#hello-world","text":"It's time to finally write python code within our engine! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from our engine and also be able to call C++ functions from a python script. Let's work on that next!","title":"Hello World"},{"location":"embedding_python/hello_python/#execute-a-python-function-from-c","text":"Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"learn_engine_dev\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into our engine and create classes to generalize some of our usages of the Python API.","title":"Execute A Python Function From C++"},{"location":"entity_component_system/building_an_ecs/","text":"Building An ECS Coming soon.","title":"Building An ECS"},{"location":"entity_component_system/building_an_ecs/#building-an-ecs","text":"Coming soon.","title":"Building An ECS"},{"location":"game_loop_and_sdl/game_loop_introduction/","text":"Game Loop Introduction Game Loop Before we start adding other systems to our game engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so. Logger As we add more functionality and systems to the game it will be useful to make logging statements for debugging, erorr, etc... The Logger class will be used for this purpose throughout the engine. #ifndef LOGGER_H #define LOGGER_H #include <string> typedef int LogLevel ; enum _LogLevel { LogLevel_DEBUG = 0 , LogLevel_WARN = 1 , LogLevel_INFO = 2 , LogLevel_ERROR = 3 , }; class Logger { private : Logger () = default ; public : LogLevel logLevel = LogLevel_DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel_DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel_WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel_INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel_ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel_DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel_WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel_INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel_ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs. Engine Context EngineContext will store engine related properties and state. There will be parts of our game engine that need access to properties such as if the game engine is running or the engine name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Simple\" ; bool running = false ; GameEngineContext () = default ; public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Game Loop Introduction"},{"location":"game_loop_and_sdl/game_loop_introduction/#game-loop-introduction","text":"","title":"Game Loop Introduction"},{"location":"game_loop_and_sdl/game_loop_introduction/#game-loop","text":"Before we start adding other systems to our game engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so.","title":"Game Loop"},{"location":"game_loop_and_sdl/game_loop_introduction/#logger","text":"As we add more functionality and systems to the game it will be useful to make logging statements for debugging, erorr, etc... The Logger class will be used for this purpose throughout the engine. #ifndef LOGGER_H #define LOGGER_H #include <string> typedef int LogLevel ; enum _LogLevel { LogLevel_DEBUG = 0 , LogLevel_WARN = 1 , LogLevel_INFO = 2 , LogLevel_ERROR = 3 , }; class Logger { private : Logger () = default ; public : LogLevel logLevel = LogLevel_DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel_DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel_WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel_INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel_ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel_DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel_WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel_INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel_ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs.","title":"Logger"},{"location":"game_loop_and_sdl/game_loop_introduction/#engine-context","text":"EngineContext will store engine related properties and state. There will be parts of our game engine that need access to properties such as if the game engine is running or the engine name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Simple\" ; bool running = false ; GameEngineContext () = default ; public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Engine Context"},{"location":"game_loop_and_sdl/initialize_sdl/","text":"Initialize SDL GameEngine Class The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include <game_lib/utils/logger.h> class GameEngine { private : GameEngineContext * engineContext = nullptr ; Logger * logger = nullptr ; void Initialize (); void InitializeSDL (); public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } void GameEngine :: Initialize () { InitializeSDL (); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); // engineContext->SetRunning(true); } void GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return ; } } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running. Main Loop Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Simple Engine v0.1.0 [INFO] Simple Engine has shut down! Measuring FPS Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes. Timer The Timer class is the straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { private : Uint32 waitTime ; bool loops ; Uint32 startTicks ; Uint32 pausedTicks ; bool isPaused ; bool hasStarted ; public : Timer ( Uint32 waitTimeInMilliseconds , bool loops = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); bool DoesLoop () const ; void SetLoop ( bool loops ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; }; #endif #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool loops ) { this -> waitTime = waitTimeInMilliseconds ; this -> loops = loops ; startTicks = 0 ; pausedTicks = 0 ; isPaused = false ; hasStarted = false ; } Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool loops ) { this -> loops = loops ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next! FPS Counter #ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./game_lib/utils/timer.h\" class FPSCounter { private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./game_lib/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we execute our game engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"Initialize SDL"},{"location":"game_loop_and_sdl/initialize_sdl/#initialize-sdl","text":"","title":"Initialize SDL"},{"location":"game_loop_and_sdl/initialize_sdl/#gameengine-class","text":"The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include <game_lib/utils/logger.h> class GameEngine { private : GameEngineContext * engineContext = nullptr ; Logger * logger = nullptr ; void Initialize (); void InitializeSDL (); public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } void GameEngine :: Initialize () { InitializeSDL (); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); // engineContext->SetRunning(true); } void GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return ; } } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running.","title":"GameEngine Class"},{"location":"game_loop_and_sdl/initialize_sdl/#main-loop","text":"Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Simple Engine v0.1.0 [INFO] Simple Engine has shut down!","title":"Main Loop"},{"location":"game_loop_and_sdl/initialize_sdl/#measuring-fps","text":"Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes.","title":"Measuring FPS"},{"location":"game_loop_and_sdl/initialize_sdl/#timer","text":"The Timer class is the straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { private : Uint32 waitTime ; bool loops ; Uint32 startTicks ; Uint32 pausedTicks ; bool isPaused ; bool hasStarted ; public : Timer ( Uint32 waitTimeInMilliseconds , bool loops = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); bool DoesLoop () const ; void SetLoop ( bool loops ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; }; #endif #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool loops ) { this -> waitTime = waitTimeInMilliseconds ; this -> loops = loops ; startTicks = 0 ; pausedTicks = 0 ; isPaused = false ; hasStarted = false ; } Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool loops ) { this -> loops = loops ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next!","title":"Timer"},{"location":"game_loop_and_sdl/initialize_sdl/#fps-counter","text":"#ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./game_lib/utils/timer.h\" class FPSCounter { private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./game_lib/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we execute our game engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"FPS Counter"},{"location":"implementing_audio/using_sdl_mixer/","text":"Using SDL_mixer Coming soon.","title":"Using SDL_mixer"},{"location":"implementing_audio/using_sdl_mixer/#using-sdl_mixer","text":"Coming soon.","title":"Using SDL_mixer"},{"location":"opengl_rendering/creating_a_renderer/","text":"Getting Started Coming soon.","title":"Creating A Renderer"},{"location":"opengl_rendering/creating_a_renderer/#getting-started","text":"Coming soon.","title":"Getting Started"},{"location":"serializing_with_json/parsing_json/","text":"Parsing JSON Coming soon.","title":"Parsing JSON"},{"location":"serializing_with_json/parsing_json/#parsing-json","text":"Coming soon.","title":"Parsing JSON"},{"location":"source_code/source_code/","text":"Source Code The full source code of the tutorials are on github and can be found here .","title":"Source Code"},{"location":"source_code/source_code/#source-code","text":"The full source code of the tutorials are on github and can be found here .","title":"Source Code"}]}