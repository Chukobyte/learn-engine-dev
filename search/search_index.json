{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome To Learn Engine Dev About Welcome to a tutorial series for creating a simple game engine, named Red Engine , from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future. Purpose The purpose of this tutorial series is to provide a step-by-step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with Red Engine to test it out! Prerequisites Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL. Structure Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Code will need to be shared between each project folder and a game library will be created in include/re . Typically, code that is created within a chapter is moved into the game library once it's implementation is completed within the sections. Tech Stack Red Engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code Work In Progress This tutorial series is not yet complete so expect incomplete chapters and sections. The source code for each chapter will come first followed by more detailed descriptions and information for each section. Also builds for windows are typically done first before linux, so expect delays in updating the Makefiles for linux in later chapters. Feedback Feedback is greatly appreciated! One way to submit feedback is to open up an issue in github and apply an appropriate label. If you like what this project is doing consider starring the Learn Engine Dev github repo .","title":"Introduction"},{"location":"#welcome-to-learn-engine-dev","text":"","title":"Welcome To Learn Engine Dev"},{"location":"#about","text":"Welcome to a tutorial series for creating a simple game engine, named Red Engine , from scratch! Making a game engine is no easy task and each system we create could have multiple tutorials of its own. But fear not, we will walk through building an engine each system at a time. This tutorial series currently supports windows and linux, but may expand to other platforms in the future.","title":"About"},{"location":"#purpose","text":"The purpose of this tutorial series is to provide a step-by-step approach to building a game engine. The end goal is to have a fully functional game engine that can be reused for multiple projects. There's a popular saying floating around that goes \"Make games, not engines\". To not disappoint the folks that usually mention this quote, we will be making 3 games with Red Engine to test it out!","title":"Purpose"},{"location":"#prerequisites","text":"Programming and technical skills of all levels are welcome, but to get the most out of this tutorial series you should have the following: A basic understanding of C++. This includes compiling and writing code. Proficiency with writing code in Python. A high level understanding of OpenGL.","title":"Prerequisites"},{"location":"#structure","text":"Each chapter of this tutorial series is broken up into sections which can be navigated to via the menu on the left. Each chapter and section has source code attributed to it which can be found within the github repo . Code will need to be shared between each project folder and a game library will be created in include/re . Typically, code that is created within a chapter is moved into the game library once it's implementation is completed within the sections.","title":"Structure"},{"location":"#tech-stack","text":"Red Engine will be built with the following technologies: C++ 14 - Core engine OpenGL 3.3 - Graphics API SDL2 - Windowing and input SDL2_mixer - Audio Python 3.7 - Scripting language for game logic AStyle - Used for formatting C++ code","title":"Tech Stack"},{"location":"#work-in-progress","text":"This tutorial series is not yet complete so expect incomplete chapters and sections. The source code for each chapter will come first followed by more detailed descriptions and information for each section. Also builds for windows are typically done first before linux, so expect delays in updating the Makefiles for linux in later chapters.","title":"Work In Progress"},{"location":"#feedback","text":"Feedback is greatly appreciated! One way to submit feedback is to open up an issue in github and apply an appropriate label. If you like what this project is doing consider starring the Learn Engine Dev github repo .","title":"Feedback"},{"location":"embedding_python/custom_python_module/","text":"Custom Python Module Creating a Game Library There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/re . With that being said we will move our python code (including from the previous section) into ./include/re/python . Python Modules Class We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining the api for Red Engine . To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents the version of Red Engine . Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./re/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Custom Python Module"},{"location":"embedding_python/custom_python_module/#custom-python-module","text":"","title":"Custom Python Module"},{"location":"embedding_python/custom_python_module/#creating-a-game-library","text":"There will be code shared between each lesson and we wouldn't want to copy and paste the same code again and again as that goes against the DRY principle. Moving forward, we will keep all code files that will be shared within the folder ./include/re . With that being said we will move our python code (including from the previous section) into ./include/re/python .","title":"Creating a Game Library"},{"location":"embedding_python/custom_python_module/#python-modules-class","text":"We have successfully called functions from python modules and class instances but we have yet to call C++ code from python. The best way to do that is to start defining the api for Red Engine . To keep things simple and concise for now we'll just define one python module named engine which contains two functions. The first function get_version doesn't take any parameters and will just return a hard coded string that represents the version of Red Engine . Our second function print_log will simply take a string as a parameter and print it out to the console. Now that we have an idea of what to do let's create our class for defining and implementing custom python modules. #ifndef PYTHON_MODULES_H #define PYTHON_MODULES_H #define PY_SSIZE_T_CLEAN #include <Python.h> #include <string> class EnginePythonModule { public : static PyObject * get_version ( PyObject * self , PyObject * args ); static PyObject * print_log ( PyObject * self , PyObject * args , PyObject * kwargs ); }; static struct PyMethodDef engineModuleMethods [] = { { \"get_version\" , EnginePythonModule :: get_version , METH_VARARGS , \"Gets version of the engine.\" }, { \"print_log\" , ( PyCFunction ) EnginePythonModule :: print_log , METH_VARARGS | METH_KEYWORDS , \"Logs a message to the console.\" }, { nullptr , nullptr , 0 , nullptr }, }; static struct PyModuleDef engineModuleDefinition = { PyModuleDef_HEAD_INIT , \"engine\" , nullptr , -1 , engineModuleMethods , nullptr , nullptr , nullptr , nullptr }; static char * enginePrintLogKWList [] = { \"message\" , nullptr }; static PyObject * PyInit_engine ( void ) { return PyModule_Create ( & engineModuleDefinition ); } #endif //PYTHON_MODULES_H The EnginePythonModule class defines the two functions that we went over earlier. Notice that print_log has an extra parameter for kwargs as the parameter will have a keyword named message . After that we define a struct which contains our module function definitions. Take note how print_log has to cast it's function to PyCFuntion to support keyword arguments. Next we define our module definition for engine which we passed in our previously created engineModuleMethods struct. enginePrintLogKWList contains the keywords for our print_log function. message is passed in by reference so we can set the value to what's passed in as the message keyword argument. Lastly PyInit_engine will be used to create our module. We will return to PyInit_engine later as we'll need to import the engine module before initializing the python interpreter. With the header out of the way let's write the implementation of our two functions. #include \"python_modules.h\" #include <iostream> PyObject * EnginePythonModule::get_version ( PyObject * self , PyObject * args ) { return Py_BuildValue ( \"s\" , \"v0.0.1\" ); } PyObject * EnginePythonModule::print_log ( PyObject * self , PyObject * args , PyObject * kwargs ) { char * message ; if ( PyArg_ParseTupleAndKeywords ( args , kwargs , \"s\" , enginePrintLogKWList , & message )) { std :: cout << \"[INFO] \" << message << std :: endl ; Py_RETURN_NONE ; } return nullptr ; } get_version is really simple as it is just returning a string which contain 'v0.0.1' with Py_BuildValue . The next function print_log is slightly more complicated but not by much. We use PyArg_ParseTupleKeywords to get the values of the argument passed in. enginePrintLogKWList is passed in as we have the defined message as a keyword argument. With our new module defined and implemented, we have to now import it into the python interpreter. Update the construtor in pyhelper.hpp to add our newly created module with PyImport_AppendInittab . This should be called before Py_Initialize . CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); PyImport_AppendInittab ( \"engine\" , & PyInit_engine ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } Don't forget to include the header for python_modules.h ! We can finally call C++ code from python. Let's update our game.py script to import the engine module and call the two functions we defined in C++ earlier. import engine class Player : def talk ( self , message : str ) -> None : engine_version = engine . get_version () engine . print_log ( message = f \"Engine version = { engine_version } \" ) We're going to keep things easy and just use the same function talk that was used in the previous section. There are a few differences now, the first line imports our engine module to be used by the python script. We're going to ignore the message parameter of the talk function. Next we call engine.get_version() which returns from our C++ function we defined early a hard coded version string. We then call engine.print_log() to print a log statement to the console. We will keep our main function defined in our C++ code the same as changes aren't needed except to update the path of PythonObjectManager header: #include \"./re/python/python_object_manager.h\" The Final output when we run the engine will be [INFO] Engine version = v0.0.1 . All the code for this section can be found here . Now that we have a good foundation for the scripting system, it's time to focus next on creating the game loop.","title":"Python Modules Class"},{"location":"embedding_python/embedding_further/","text":"Embedding Further PyHelper Class So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } private : PyObject * pyObj ; }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here . Creating A Python Instance in C++ We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call the Red Engine api from within python scripts.","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#embedding-further","text":"","title":"Embedding Further"},{"location":"embedding_python/embedding_further/#pyhelper-class","text":"So far we need to: Initialize the python interpreter. Create python objects. Increment and decrement the reference count for python objects as needed. Close the python interpreter once we're finished with it. With that said, let's create PyHelper.hpp which encapsulates this functionality. #ifndef PYHELPER_HPP #define PYHELPER_HPP #pragma once #define PY_SSIZE_T_CLEAN #include <Python.h> #include <iostream> class CPyInstance { public : CPyInstance () { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); } ~ CPyInstance () { Py_Finalize (); } }; class CPyObject { public : CPyObject () : pyObj ( nullptr ) {} CPyObject ( PyObject * p ) : pyObj ( p ) {} ~ CPyObject () { Release (); } PyObject * GetObj () { return pyObj ; } PyObject * SetObj ( PyObject * p ) { return ( pyObj = p ); } PyObject * AddRef () { if ( pyObj ) { Py_INCREF ( pyObj ); } return pyObj ; } void Release () { if ( pyObj ) { Py_DECREF ( pyObj ); } pyObj = nullptr ; } PyObject * operator -> () { return pyObj ; } bool Is () const { return pyObj ? true : false ; } operator PyObject * () { return pyObj ; } PyObject * operator = ( PyObject * p ) { pyObj = p ; return pyObj ; } private : PyObject * pyObj ; }; #endif //PYHELPER_HPP There are two classes created in PyHelper.hpp . CPyInstance responsibility is to initialize the python interpreter, perform any additional setup, and shutdown the intepreter once finished. CPyObject is a wrapper class for PyObject which is a python object. Instead of having to explicitly decrement with Py_DECREF we instead use this CPyObject which decrements the reference count once the object is out of scope. Now that we have a helper class, let's put it to use. def play ( message : str ) -> int : print ( f \" { message } (from python)!\" ) return 0 We have updated our python function to now accept an argument. #include \"./scripting/pyhelper.hpp\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; // Load Module CPyObject pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function CPyObject pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); CPyObject pArgs = Py_BuildValue ( \"(s)\" , \"hello world!\" ); assert ( pArgs != nullptr ); CPyObject pValue = PyObject_CallObject ( pFunc , pArgs ); return 0 ; } This is similar to the code snippet we've created in the previous section, but instead of using PyObject we are using CPyObject . Py_BuildValue builds a tuple of arguements that we can then pass to a python function. With the argument defined, we can now call PyObject_CallObject with an argument. If you would like to double check your code you can view the source code for this section here .","title":"PyHelper Class"},{"location":"embedding_python/embedding_further/#creating-a-python-instance-in-c","text":"We're able to import modules and call functions, but there may be times where we'll want to interact with an instance of a python class. Furthermore, we don't want to have to import a module and query its attributes each time we want to use a function as that will affect performance. In this section we'll create a class to manage active python objects. #ifndef PYTHON_OBJECT_MANAGER_H #define PYTHON_OBJECT_MANAGER_H #include <string> #include <unordered_map> #include \"./pyhelper.hpp\" struct PythonModuleObject { CPyObject module ; std :: unordered_map < std :: string , CPyObject > classes ; }; class PythonObjectManager { public : CPyObject CreateClassInstance ( const std :: string & classPath , const std :: string & className ) { CPyObject pClass = GetClass ( classPath , className ); CPyObject pClassInstance = PyObject_CallObject ( pClass , nullptr ); assert ( pClassInstance != nullptr && \"Class instance is NULL!\" ); pClassInstance . AddRef (); return pClassInstance ; } private : std :: unordered_map < std :: string , PythonModuleObject > modules ; CPyObject GetClass ( const std :: string & classPath , const std :: string & className ) { if ( modules . find ( classPath ) == modules . end ()) { CPyObject pModuleName = PyUnicode_FromString ( classPath . c_str ()); CPyObject pModule = PyImport_Import ( pModuleName ); assert ( pModule != nullptr && \"Python module is NULL!\" ); modules . emplace ( classPath , PythonModuleObject { . module = pModule , . classes = {} }); } if ( modules [ classPath ]. classes . find ( className ) == modules [ classPath ]. classes . end ()) { CPyObject pModuleDict = PyModule_GetDict ( modules [ classPath ]. module ); CPyObject pClass = PyDict_GetItemString ( pModuleDict , className . c_str ()); assert ( pClass != nullptr && \"Python class is NULL!\" ); modules [ classPath ]. classes . emplace ( className , pClass ); } return modules [ classPath ]. classes [ className ]; } }; #endif // PYTHON_OBJECT_MANAGER_H Within python_object_manager.h we first create PythonModuleObject which is a struct to hold a python module's object data. It will hold all the python class objects loaded for the module. Next is the main class which is PythonObjectManager . The GetClass function will return a class object for a module. We use this within CreateClassInstance to create a python instance of a class. class Player : def talk ( self , message : str ) -> None : print ( f \"Player says ' { message } '!\" ) The script game.py has been updated to include a class named Player . We can finally create an instance of this class and call a function from this instance from c++. #include \"./scripting/python_object_manager.h\" int main ( int argv , char ** args ) { CPyInstance pyInstance ; PythonObjectManager pObjectManager ; CPyObject pClassInstance = pObjectManager . CreateClassInstance ( \"assets.scripts.game\" , \"Player\" ); PyObject_CallMethod ( pClassInstance , \"talk\" , \"(s)\" , \"Hello!\" ); return 0 ; } There is even less code in main even though we're creating an instance! The only thing to really point out is PyObject_CallMethod which calls a function on an instance of a class. Source code for this section can be viewed here . Now that we have a solid grasp on how to create python instances and call functions on them it's time to create our own modules in C++ in order to call the Red Engine api from within python scripts.","title":"Creating A Python Instance in C++"},{"location":"embedding_python/hello_python/","text":"Hello Python Dependencies For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the red_engine executable. Build For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := red_engine # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : ./ $( BUILD_OBJECT ) format : astyle -n --style = google --recursive src/*.cpp Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55. Hello World It's time to finally write python code within Red Engine ! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from Red Engine and also be able to call C++ functions from a python script. Let's work on that next! Execute A Python Function From C++ Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into Red Engine and create classes to generalize some of our usages of the Python API.","title":"Hello Python"},{"location":"embedding_python/hello_python/#hello-python","text":"","title":"Hello Python"},{"location":"embedding_python/hello_python/#dependencies","text":"For this tutorial, we'll be using Python 3.7 but feel free to try other versions as well. Python must be downloaded and installed locally before continuing. Windows users be sure to include the python37.dll in the same directory as the red_engine executable.","title":"Dependencies"},{"location":"embedding_python/hello_python/#build","text":"For building the engine in a cross platform way we will be using make . I won't being going into the specifics of Makefiles in this series, but you can find a pretty solid tutorial here . To make the paths for dependencies configurable we'll set environment variables throughout the tutorial, but feel free to hardcode these values for your convenience. For python there are two environment variables: PYTHON_INCLUDE The python installation's include folder. Should contain Python.h . PYTHON_LIBS The python installation's lib folder. Should contain the python a. file used during linking. PROJECT_NAME := red_engine # OS Specific Stuff ifeq ($(OS),Windows_NT) OS_TYPE : = windows BUILD_OBJECT : = $( PROJECT_NAME ) .exe L_FLAGS : = -lmingw32 -lpython37 -static-libgcc -static-libstdc++ DELETE_CMD : = del else OS_TYPE : = linux BUILD_OBJECT : = $( PROJECT_NAME ) L_FLAGS : = -lpython3.7m -lcrypt -lpthread -ldl -lutil -lm -static-libgcc -static-libstdc++ DELETE_CMD : = rm endif CC := gcc # C Compiler CXX := g++ # C++ compiler I_FLAGS := -I \" ${ PYTHON_INCLUDE } \" LIBRARIES := -L \" ${ PYTHON_LIBS } \" CPP_FLAGS := -w -std = c++14 -Wfatal-errors SRC = $( wildcard src/*.cpp ) OBJ = $( SRC:.cpp = .o ) # MAIN .PHONY : all build clean all : clean format build # Compiles if .o is missing or changes to the .cpp file %.o : %. cpp @echo \"Compiling \" $< \" into \" $@ @ $( CXX ) -c $( CPP_FLAGS ) $< -o $@ $( I_FLAGS ) build : $( OBJ ) @echo \"Linking \" $@ @ $( CXX ) -o $( BUILD_OBJECT ) $^ $( I_FLAGS ) $( L_FLAGS ) $( LIBRARIES ) clean : ifneq (\"$(wildcard $(BUILD_OBJECT))\",\"\") $( DELETE_CMD ) $( BUILD_OBJECT ) endif ifeq ($(OS_TYPE),windows) $( foreach object, $( OBJ ) , del $( subst /, \\, $( object )) ; ) else $( foreach object, $( OBJ ) , rm $( object ) ; ) endif run : ./ $( BUILD_OBJECT ) format : astyle -n --style = google --recursive src/*.cpp Note: You can echo the full compile and linking commands to the console by removing @ on lines 51 and 55.","title":"Build"},{"location":"embedding_python/hello_python/#hello-world","text":"It's time to finally write python code within Red Engine ! Before we start diving deeper into creating a scripting system for python, let's first obtain a small win by having out engine print out a statement via python. Full documentation for embedding python within a c++ application can be found here . #define PY_SSIZE_T_CLEAN #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"print('hello world (from python)')\" ); Py_Finalize (); return 0 ; } This should print out 'hello world (from python)' . There's other things we can setup before initializing the python interpreter but for now we'll just set the python application name with Py_SetProgramName . Py_Initialize initializes the python interpreter. Next we call PyRun_SimpleString to execute this python statement: print ( 'hello world (from python)' ) Last but not least we terminate the python interpreter by calling Py_Finalize() . Not too bad of a start but we can definitely do better! You view the code by looking at the source here . We will want to execute scripts and python functions from Red Engine and also be able to call C++ functions from a python script. Let's work on that next!","title":"Hello World"},{"location":"embedding_python/hello_python/#execute-a-python-function-from-c","text":"Executing python statements with PyRun_SimpleString is simple but it won't scale very well once we start adding more logic in python. Let's create a new python script and call a function from it! def play () -> int : print ( \"Game played!\" ) return 0 A simple python function that prints the statement 'Game played!' to the console. Next let's call this function in C++. #define PY_SSIZE_T_CLEAN #include <iostream> #include <Python.h> int main ( int argv , char ** args ) { Py_SetProgramName ( L \"red_engine\" ); Py_Initialize (); PyRun_SimpleString ( \"import sys\" ); PyRun_SimpleString ( \"sys.path.append( \\\" . \\\" )\" ); // Load Module PyObject * pModuleName = PyUnicode_FromString ( \"assets.scripts.game\" ); PyObject * pModule = PyImport_Import ( pModuleName ); Py_DECREF ( pModuleName ); assert ( pModule != nullptr && \"Not able to load python module!\" ); // Function PyObject * pFunc = PyObject_GetAttrString ( pModule , \"play\" ); assert ( pFunc != nullptr && \"Not able to find function named 'play'!\" ); PyObject * pValue = PyObject_CallObject ( pFunc , nullptr ); std :: cout << \"Python script exit code = \" << PyLong_AsLong ( pValue ) << std :: endl ; Py_DECREF ( pValue ); Py_DECREF ( pFunc ); Py_DECREF ( pModule ); Py_Finalize (); return 0 ; } This is pretty straightforward, the first things to point out are the two PyRun_SimpleString calls. The first python statement: import sys Simply imports the sys module into the interpreter. The next python statement: sys . path . append ( \".\" ) This adds the current path to the system path in order for python modules to be imported based on the current path. We would have to provide the full path otherwise. Next we're getting a python string object with PyUnicode_FromString as we'll need that to import the python module from our script. The folder path is assets/scripts and the python script is game.py . After getting the module name we'll now import the module it's pointing to with PyImport_Import . Py_DECREF is called as we'll need to decrement the reference count of python objects to delete them within python interpreter and prevent memory leaks! Now that we have imported the module we can get the reference to a function with PyObject_GetAttrString . With this reference we'll call the function with PyObject_CallObject . The function play returns an integer and we store this within pValue . After that we just decrement the remaining python objects we no longer need. The source for this section can be found here . We're able to call a python function from c++ and receive its return value, but incrementing and decrementing the reference count will become tedious. In the next section we will embed python further into Red Engine and create classes to generalize some of our usages of the Python API.","title":"Execute A Python Function From C++"},{"location":"entity_component_system/building_an_ecs/","text":"Building An ECS Coming soon.","title":"Building An ECS"},{"location":"entity_component_system/building_an_ecs/#building-an-ecs","text":"Coming soon.","title":"Building An ECS"},{"location":"game_loop_and_sdl/game_loop_introduction/","text":"Game Loop Introduction Game Loop Before we start adding other systems to Red Engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so. Logger As we add more functionality and systems to the game it will be useful to make logging statements for debugging, error, etc... The Logger class will be used for this purpose throughout Red Engine . #ifndef LOGGER_H #define LOGGER_H #include <string> enum class LogLevel : unsigned int { DEBUG = 0 , WARN = 1 , INFO = 2 , ERROR = 3 , }; class Logger { public : LogLevel logLevel = LogLevel :: DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; private : Logger () = default ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel :: DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel :: WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel :: INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel :: ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs. Engine Context EngineContext will store engine related properties and state. There will be parts of Red Engine that need access to properties such as if the game engine is running or the engine's name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Red\" ; bool running = false ; GameEngineContext () = default ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Game Loop Introduction"},{"location":"game_loop_and_sdl/game_loop_introduction/#game-loop-introduction","text":"","title":"Game Loop Introduction"},{"location":"game_loop_and_sdl/game_loop_introduction/#game-loop","text":"Before we start adding other systems to Red Engine we should first create the game loop. The game loop will be responsible for tasks such as processing input, updating game state (physics, A.I., etc...), and rendering. Below is how our game loop will look: while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } In the next section we will define a GameEngine class, but we have a few more things to cover before we do so.","title":"Game Loop"},{"location":"game_loop_and_sdl/game_loop_introduction/#logger","text":"As we add more functionality and systems to the game it will be useful to make logging statements for debugging, error, etc... The Logger class will be used for this purpose throughout Red Engine . #ifndef LOGGER_H #define LOGGER_H #include <string> enum class LogLevel : unsigned int { DEBUG = 0 , WARN = 1 , INFO = 2 , ERROR = 3 , }; class Logger { public : LogLevel logLevel = LogLevel :: DEBUG ; static Logger * GetInstance (); void SetLogLevel ( LogLevel level ); bool SetLogLevelFromString ( std :: string logLevelString ); LogLevel GetLogLevel () const ; void Debug ( const char * fmt , ...) const ; void Warn ( const char * fmt , ...) const ; void Info ( const char * fmt , ...) const ; void Error ( const char * fmt , ...) const ; private : Logger () = default ; }; #endif //LOGGER_H #include \"logger.h\" #include <bits/stdc++.h> Logger * Logger::GetInstance () { static Logger * instance = new Logger (); return instance ; } void Logger::SetLogLevel ( LogLevel level ) { logLevel = level ; } bool Logger::SetLogLevelFromString ( std :: string logLevelString ) { transform ( logLevelString . begin (), logLevelString . end (), logLevelString . begin (), :: tolower ); if ( logLevelString == \"debug\" ) { logLevel = LogLevel :: DEBUG ; return true ; } else if ( logLevelString == \"warn\" ) { logLevel = LogLevel :: WARN ; return true ; } else if ( logLevelString == \"info\" ) { logLevel = LogLevel :: INFO ; return true ; } else if ( logLevelString == \"error\" ) { logLevel = LogLevel :: ERROR ; return true ; } return false ; } LogLevel Logger::GetLogLevel () const { return logLevel ; } void Logger::Debug ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: DEBUG ) { const std :: string & logMessage = \"[DEBUG] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Warn ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: WARN ) { const std :: string & logMessage = \"[WARN] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Info ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: INFO ) { const std :: string & logMessage = \"[INFO] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } void Logger::Error ( const char * fmt , ...) const { if ( logLevel <= LogLevel :: ERROR ) { const std :: string & logMessage = \"[ERROR] \" + std :: string ( fmt ) + \" \\n \" ; va_list args ; va_start ( args , fmt ); vprintf ( logMessage . c_str (), args ); va_end ( args ); } } Right off the bat, the first thing to mention is that the Logger class is a singleton . This means there can only be one instance of the Logger class can be active throughout the life of the application. We will be using this pattern for other classes as well. The function GetInstance() is used to obtain the single instance of Logger . The functions Error , Warn , Info , and Debug are essentially wrappers for the printf function and are used to print logging statements matching the log level of the function name. Log level can be set with either SetLogLevel or SetLogLevelFromString . More details about the 4 log levels can be found below: Log Level Description Priority DEBUG Most verbose logging, will print debug related logs. 3 INFO Will print non-important but potentially useful information. 2 WARN Problems that should be fixed but aren't fatal. 1 ERROR Fatal errors that will most likely cause application errors. 0 Using log levels with a higher priority will print all logs for that level and below. For example, a log level of ERROR will only print error logs and a log level of INFO will print info, warn, and error logs.","title":"Logger"},{"location":"game_loop_and_sdl/game_loop_introduction/#engine-context","text":"EngineContext will store engine related properties and state. There will be parts of Red Engine that need access to properties such as if the game engine is running or the engine's name. We wouldn't want to have to pass the top level GameEngine class (that we haven't defined yet) to places that need it, so we're going to separate engine properties and state into it's own class GameEngineContext . GameEngineContext will also be a singleton just like our Logger class. #ifndef GAME_ENGINE_CONTEXT_H #define GAME_ENGINE_CONTEXT_H class GameEngineContext { public : static GameEngineContext * GetInstance (); const char * GetEngineVersion () const ; const char * GetEngineName () const ; void SetRunning ( bool value ); bool IsRunning () const ; private : const char * engineVersion = \"0.1.0\" ; const char * engineName = \"Red\" ; bool running = false ; GameEngineContext () = default ; }; #endif //GAME_ENGINE_CONTEXT_H #include \"game_engine_context.h\" GameEngineContext * GameEngineContext::GetInstance () { static GameEngineContext * instance = new GameEngineContext (); return instance ; } const char * GameEngineContext::GetEngineVersion () const { return engineVersion ; } const char * GameEngineContext::GetEngineName () const { return engineName ; } void GameEngineContext::SetRunning ( bool value ) { running = value ; } bool GameEngineContext::IsRunning () const { return running ; } Nothing much to explain here. The public functions are used to get the game engine version, name, and set/get whether the engine is running. Now that we have a few classes defined, it's time to tackle setting up SDL!","title":"Engine Context"},{"location":"game_loop_and_sdl/initialize_sdl/","text":"Initialize SDL GameEngine Class The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include <game_lib/utils/logger.h> class GameEngine { public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; private : GameEngineContext * engineContext = nullptr ; Logger * logger = nullptr ; void Initialize (); void InitializeSDL (); }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } void GameEngine :: Initialize () { InitializeSDL (); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); // engineContext->SetRunning(true); } void GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return ; } } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running. Main Loop Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Red Engine v0.1.0 [INFO] Red Engine has shut down! Measuring FPS Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes. Timer The Timer class is straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { public : Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); bool DoesLoop () const ; void SetLoop ( bool doesLoop ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; private : Uint32 waitTime ; bool loops ; Uint32 startTicks ; Uint32 pausedTicks ; bool isPaused ; bool hasStarted ; }; #endif #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop ) { waitTime = waitTimeInMilliseconds ; loops = doesLoop ; startTicks = 0 ; pausedTicks = 0 ; isPaused = false ; hasStarted = false ; } Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool doesLoop ) { loops = doesLoop ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next! FPS Counter #ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./re/utils/timer.h\" class FPSCounter { public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./re/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we run Red Engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"Initialize SDL"},{"location":"game_loop_and_sdl/initialize_sdl/#initialize-sdl","text":"","title":"Initialize SDL"},{"location":"game_loop_and_sdl/initialize_sdl/#gameengine-class","text":"The GameEngine class will tie the game loop and engine systems together. #ifndef GAME_ENGINE_H #define GAME_ENGINE_H #include \"game_engine_context.h\" #include <game_lib/utils/logger.h> class GameEngine { public : GameEngine (); ~ GameEngine (); void ProcessInput (); void Update (); void Render (); bool IsRunning () const ; private : GameEngineContext * engineContext = nullptr ; Logger * logger = nullptr ; void Initialize (); void InitializeSDL (); }; #endif //GAME_ENGINE_H #include \"game_engine.h\" #include <SDL2/SDL.h> GameEngine :: GameEngine () : engineContext ( GameEngineContext :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } GameEngine ::~ GameEngine () { SDL_Quit (); logger -> Info ( \"%s Engine has shut down!\" , engineContext -> GetEngineName ()); } void GameEngine :: Initialize () { InitializeSDL (); logger -> Info ( \"%s Engine v%s\" , engineContext -> GetEngineName (), engineContext -> GetEngineVersion ()); // engineContext->SetRunning(true); } void GameEngine :: InitializeSDL () { if ( SDL_Init ( SDL_INIT_EVERYTHING ) != 0 ) { logger -> Error ( \"Error on initializing SDL \\n %s\" , SDL_GetError ()); return ; } } void GameEngine :: ProcessInput () {} void GameEngine :: Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } lastFrameTime = SDL_GetTicks (); } void GameEngine :: Render () {} bool GameEngine :: IsRunning () const { return engineContext -> IsRunning (); } The constructor calls the Initialize function which initializes SDL via SDL_Init . We pass in SDL_INIT_EVERYTHING which initializes all SDL subsystems. After initializing the engine we will set GameEngineContext running property to true in the next section, but for now we are commenting it out. The destructor calls SDL_Quit which shuts down all SDL subsystems. The Update function will be used to update things such as physics, A.I., game state, etc... We will want our game to run at a target frames per second and the current TARGET_FPS variable controls that. lastFrameTime is used to keep track of what the frame time was the previous frame. SDL_Delay is used to not completely occupy the cpu during a game loop. Experiment by commenting out SDL_Delay and compare the cpu utilization with and without using it. Last but not least the IsRunning function just returns the value of GameEngineContext running.","title":"GameEngine Class"},{"location":"game_loop_and_sdl/initialize_sdl/#main-loop","text":"Now that we have our GameEngine class defined, we can now test it to make sure everything works. #include \"game_engine.h\" int main ( int argv , char ** args ) { GameEngine gameEngine ; while ( gameEngine . IsRunning ()) { gameEngine . ProcessInput (); gameEngine . Update (); gameEngine . Render (); } return 0 ; } After executing the above the following two log statements should be printed to the terminal: [INFO] Red Engine v0.1.0 [INFO] Red Engine has shut down!","title":"Main Loop"},{"location":"game_loop_and_sdl/initialize_sdl/#measuring-fps","text":"Last but not least, we should check performance to ensure we are getting the frames per second that we are expecting. We will first start by defining a Timer class that will be used by the FPSCounter and other classes.","title":"Measuring FPS"},{"location":"game_loop_and_sdl/initialize_sdl/#timer","text":"The Timer class is straight forward. #ifndef TIMER_H #define TIMER_H #include <SDL2/SDL.h> class Timer { public : Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop = false ); Uint32 GetWaitTime () const ; Uint32 GetTimeLeft () const ; void SetWaitTime ( Uint32 waitTimeInMilliseconds ); bool DoesLoop () const ; void SetLoop ( bool doesLoop ); void Start (); void Stop (); void Pause (); void UnPause (); bool HasStopped () const ; bool HasReachedTimeOut () const ; Uint32 GetTicks () const ; bool HasStarted () const ; bool IsPaused () const ; private : Uint32 waitTime ; bool loops ; Uint32 startTicks ; Uint32 pausedTicks ; bool isPaused ; bool hasStarted ; }; #endif #include \"timer.h\" #include <iostream> Timer :: Timer ( Uint32 waitTimeInMilliseconds , bool doesLoop ) { waitTime = waitTimeInMilliseconds ; loops = doesLoop ; startTicks = 0 ; pausedTicks = 0 ; isPaused = false ; hasStarted = false ; } Uint32 Timer :: GetWaitTime () const { return waitTime ; } Uint32 Timer :: GetTimeLeft () const { if ( ! hasStarted ) { return 0 ; } Uint32 timeLeft = waitTime - ( SDL_GetTicks () - startTicks ); return timeLeft > 0 && timeLeft < waitTime ? timeLeft : 0 ; } void Timer :: SetWaitTime ( Uint32 waitTimeInMilliseconds ) { waitTime = waitTimeInMilliseconds ; } bool Timer :: DoesLoop () const { return loops ; } void Timer :: SetLoop ( bool doesLoop ) { loops = doesLoop ; } void Timer :: Start () { hasStarted = true ; isPaused = false ; startTicks = SDL_GetTicks (); pausedTicks = 0 ; } void Timer :: Stop () { hasStarted = false ; isPaused = false ; startTicks = 0 ; pausedTicks = 0 ; } void Timer :: Pause () { if ( hasStarted && ! isPaused ) { isPaused = true ; pausedTicks = SDL_GetTicks () - startTicks ; startTicks = 0 ; } } void Timer :: UnPause () { if ( hasStarted && isPaused ) { isPaused = false ; startTicks = SDL_GetTicks () - pausedTicks ; pausedTicks = 0 ; } } bool Timer :: HasStopped () const { return ! hasStarted && ! isPaused ; } bool Timer :: HasReachedTimeOut () const { Uint32 time = GetTicks (); if ( time >= waitTime ) { return true ; } return false ; } Uint32 Timer :: GetTicks () const { Uint32 time = 0 ; if ( hasStarted ) { if ( isPaused ) { time = pausedTicks ; } else { time = SDL_GetTicks () - startTicks ; } } return time ; } bool Timer :: HasStarted () const { return hasStarted ; } bool Timer :: IsPaused () const { return isPaused && hasStarted ; } waitTime refers to how long the timer will run for and loops determines if the timer restarts after timing out. I think all the functions are self-explanatory and we will see the Timer class in use next!","title":"Timer"},{"location":"game_loop_and_sdl/initialize_sdl/#fps-counter","text":"#ifndef FPS_COUNTER_H #define FPS_COUNTER_H #include \"./re/utils/timer.h\" class FPSCounter { public : ~ FPSCounter (); static FPSCounter * GetInstance (); void Update (); unsigned int GetFPS () const ; private : unsigned int fps ; unsigned int fpsCount ; Timer * timer = nullptr ; FPSCounter (); }; #endif //FPS_COUNTER_H #include \"fps_counter.h\" #include \"./re/utils/logger.h\" FPSCounter :: FPSCounter () : timer ( new Timer ( 1000 , true )) { timer -> Start (); } FPSCounter ::~ FPSCounter () { delete timer ; } FPSCounter * FPSCounter :: GetInstance () { static FPSCounter * instance = new FPSCounter (); return instance ; } void FPSCounter :: Update () { if ( timer -> HasReachedTimeOut ()) { timer -> Stop (); fps = fpsCount ; fpsCount = 0 ; Logger :: GetInstance () -> Debug ( \"fps = %d\" , fps ); timer -> Start (); } fpsCount ++ ; } unsigned int FPSCounter :: GetFPS () const { return fps ; } The first thing to note about the FPSCounter class is that it is also a singleton. The Update function uses the timer to determine if a second has passed. Once a second has passed, we update the fps member variable and log the fps to the console temporarily as we'll use the GetFPS function to obtain the value in a future section. Now that we have the FPS Counter class defined, let's use it within the Update function in our game loop. void GameEngine::Update () { // Sleep until FRAME_TARGET_TIME has elapsed since last frame const unsigned int MILLISECONDS_PER_TICK = 1000 ; const unsigned int TARGET_FPS = 60 ; static Uint32 lastFrameTime = 0 ; const unsigned int FRAME_TARGET_TIME = MILLISECONDS_PER_TICK / TARGET_FPS ; unsigned int timeToWait = FRAME_TARGET_TIME - ( SDL_GetTicks () - lastFrameTime ); if ( timeToWait > 0 && timeToWait <= FRAME_TARGET_TIME ) { SDL_Delay ( timeToWait ); } fpsCounter -> Update (); lastFrameTime = SDL_GetTicks (); } Also in the Initialize function uncomment setting GameEngineContext running to true . engineContext -> SetRunning ( true ); If we run Red Engine now, it should print to the terminal the fps of our game loop once per second. All the source code for this chapter can be found here . We have now finished setting up SDL2 and our game loop! Next we'll tackle creating a renderer to draw things to the screen!","title":"FPS Counter"},{"location":"implementing_audio/using_sdl_mixer/","text":"Using SDL_mixer Coming soon.","title":"Using SDL_mixer"},{"location":"implementing_audio/using_sdl_mixer/#using-sdl_mixer","text":"Coming soon.","title":"Using SDL_mixer"},{"location":"opengl_rendering/asset_management/","text":"Asset Management Textures Glad As you already know, we will be using the OpenGL graphics API for our renderer. Glad , which is an OpenGL loading library, will be used to by Red Engine to access OpenGL functions. We will modify the build of the engine by adding the generated glad.c file to Makefile. SRC_C = $( wildcard $( INCLUDE_DIR ) /glad/glad.c ) stb_image stb_image is an image loading library which is part of a larger library named stb . All functions from the stb_image library will have the prefix stbi_ . Texture Class Instances of the Texture class will be used to render sprites to the screen. #ifndef TEXTURE_H #define TEXTURE_H #include <glad/glad.h> #include \"../utils/logger.h\" class Texture { public : Texture ( const char * filePath ); Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ); Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ); ~ Texture (); void Bind () const ; std :: string GetFilePath () const ; int GetWidth () const ; int GetHeight () const ; unsigned int GetImageFormat () const ; unsigned char * GetData () const ; bool IsValid () const ; private : Logger * logger = nullptr ; std :: string fileName ; GLuint ID = 0 ; unsigned char * data = nullptr ; int width = 0 ; int height = 0 ; int nrChannels = 0 ; // format unsigned int internalFormat = GL_RGBA ; unsigned int imageFormat = GL_RGBA ; // configuration unsigned int wrapS = GL_CLAMP_TO_BORDER ; unsigned int wrapT = GL_CLAMP_TO_BORDER ; unsigned int filterMin = GL_NEAREST ; unsigned int filterMag = GL_NEAREST ; void Initialize ( const char * filePath ); void Generate (); unsigned int GetWrapFromString ( const std :: string & wrap ) const ; unsigned int GetFilterFromString ( const std :: string & filter ) const ; }; #endif //TEXTURE_H #include \"texture.h\" #include <stb_image/stb_image.h> Texture :: Texture ( const char * filePath ) : logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture :: Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ) : wrapS ( wrapS ), wrapT ( wrapT ), filterMin ( filterMin ), filterMag ( filterMag ), logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture :: Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ) : wrapS ( GetWrapFromString ( wrapS )), wrapT ( GetWrapFromString ( wrapT )), filterMin ( GetFilterFromString ( filterMin )), filterMag ( GetFilterFromString ( filterMag )), logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture ::~ Texture () { stbi_image_free ( data ); data = nullptr ; } void Texture :: Initialize ( const char * filePath ) { fileName = std :: string ( filePath ); // load image, create texture, and generate mipmaps stbi_set_flip_vertically_on_load ( false ); data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); if ( IsValid ()) { Generate (); } else { logger -> Error ( \"Texture failed to load at: %s\" , filePath ); } } void Texture :: Generate () { if ( nrChannels == 1 ) { imageFormat = GL_RED ; } else if ( nrChannels == 3 ) { imageFormat = GL_RGB ; } else if ( nrChannels == 4 ) { imageFormat = GL_RGBA ; } // Create texture glGenTextures ( 1 , & ID ); Bind (); glTexImage2D ( GL_TEXTURE_2D , 0 , internalFormat , width , height , 0 , imageFormat , GL_UNSIGNED_BYTE , data ); glGenerateMipmap ( GL_TEXTURE_2D ); // Wrap and filter modes glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , wrapS ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , wrapT ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , filterMin ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , filterMag ); // Unbind texture glBindTexture ( GL_TEXTURE_2D , 0 ); } unsigned int Texture :: GetWrapFromString ( const std :: string & wrap ) const { if ( wrap == \"clamp_to_border\" ) { return GL_CLAMP_TO_BORDER ; } else if ( wrap == \"clamp_to_edge\" ) { return GL_CLAMP_TO_EDGE ; } else if ( wrap == \"repeat\" ) { return GL_REPEAT ; } else if ( wrap == \"mirrored_repeat\" ) { return GL_MIRRORED_REPEAT ; } logger -> Error ( \"'%s' is an invalid wrap value!\" , wrap . c_str ()); return wrapS ; } unsigned int Texture :: GetFilterFromString ( const std :: string & filter ) const { if ( filter == \"nearest\" ) { return GL_NEAREST ; } else if ( filter == \"linear\" ) { return GL_LINEAR ; } logger -> Error ( \"'%s' is an invalid filter value!\" , filter . c_str ()); return filterMin ; } void Texture :: Bind () const { glBindTexture ( GL_TEXTURE_2D , ID ); } std :: string Texture :: GetFilePath () const { return fileName ; } int Texture :: GetWidth () const { return width ; } int Texture :: GetHeight () const { return height ; } unsigned int Texture :: GetImageFormat () const { return imageFormat ; } unsigned char * Texture :: GetData () const { return data ; } bool Texture :: IsValid () const { if ( data ) { return true ; } return false ; } The Texture class has quite a few member variables. fileName is just the file path of the texture file. data is the texture data in memory. width and height are self explanatory. nrChannels represent the number of color channels. internalFormat specifies the number of color components in the texture. imageFormat is set based on the number of color channels for the loaded texture. wrapS and wrapT refers to the texture wrapping mode applied to the S and T axis. Below are the 4 possible values: GL_REPEAT : The default behavior for textures. Repeats the texture image. GL_MIRRORED_REPEAT : Same as GL_REPEAT but mirrors the image with each repeat. GL_CLAMP_TO_EDGE : Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern. GL_CLAMP_TO_BORDER : Coordinates outside the range are now given a user-specified border color. filterMin and filterMax refers to the texture filtering mode. Below are the possible values: GL_NEAREST : OpenGL selects the texel that center is closest to the texture coordinate. Ideal for pixel art games. GL_LINEAR : OpenGL takes an interpolated value from the texture coordinate's neighboring texel. The Initialize function is called by both constructors. Texture data is loaded by stb_image library with the following line: data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); If the texture is loaded successfully, the Generate function is called. This function configures the texture for OpenGL. The only other function to point out is the Bind function which we'll get into once we start rendering textures. Asset Manager Now that we have the concept of a texture defined in Red Engine , we will need something to maintain textures as well as other assets. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" class AssetManager { public : static AssetManager * GetInstance (); void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; private : std :: unordered_map < std :: string , Texture *> textures ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H #include \"asset_manager.h\" #include <cassert> AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()) {} AssetManager * AssetManager :: GetInstance () { static AssetManager * instance = new AssetManager (); return instance ; } void AssetManager :: LoadTexture ( const std :: string & id , const std :: string & filePath ) { Texture * texture = new Texture ( filePath . c_str ()); assert ( texture -> IsValid () && \"Failed to load texture!\" ); if ( HasTexture ( id )) { logger -> Warn ( \"Already have texture, not loading...\" ); return ; } textures . emplace ( id , texture ); } Texture * AssetManager :: GetTexture ( const std :: string & id ) { assert ( HasTexture ( id ) && \"Failed to get texture!\" ); return textures [ id ]; } bool AssetManager :: HasTexture ( const std :: string & id ) const { return textures . count ( id ) > 0 ; } The AssetManager class is a singleton with 3 functions to pay attention to. LoadTexture loads a new instance of the Texture class and places it in the textures map. GetTexture just retrieves a texture by id from the map. And HasTexture checks to see if the texture is stored by AssetManager . Other assets will follow the same 3 function pattern as textures and will be discussed in a later section.","title":"Asset Management"},{"location":"opengl_rendering/asset_management/#asset-management","text":"","title":"Asset Management"},{"location":"opengl_rendering/asset_management/#textures","text":"","title":"Textures"},{"location":"opengl_rendering/asset_management/#glad","text":"As you already know, we will be using the OpenGL graphics API for our renderer. Glad , which is an OpenGL loading library, will be used to by Red Engine to access OpenGL functions. We will modify the build of the engine by adding the generated glad.c file to Makefile. SRC_C = $( wildcard $( INCLUDE_DIR ) /glad/glad.c )","title":"Glad"},{"location":"opengl_rendering/asset_management/#stb_image","text":"stb_image is an image loading library which is part of a larger library named stb . All functions from the stb_image library will have the prefix stbi_ .","title":"stb_image"},{"location":"opengl_rendering/asset_management/#texture-class","text":"Instances of the Texture class will be used to render sprites to the screen. #ifndef TEXTURE_H #define TEXTURE_H #include <glad/glad.h> #include \"../utils/logger.h\" class Texture { public : Texture ( const char * filePath ); Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ); Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ); ~ Texture (); void Bind () const ; std :: string GetFilePath () const ; int GetWidth () const ; int GetHeight () const ; unsigned int GetImageFormat () const ; unsigned char * GetData () const ; bool IsValid () const ; private : Logger * logger = nullptr ; std :: string fileName ; GLuint ID = 0 ; unsigned char * data = nullptr ; int width = 0 ; int height = 0 ; int nrChannels = 0 ; // format unsigned int internalFormat = GL_RGBA ; unsigned int imageFormat = GL_RGBA ; // configuration unsigned int wrapS = GL_CLAMP_TO_BORDER ; unsigned int wrapT = GL_CLAMP_TO_BORDER ; unsigned int filterMin = GL_NEAREST ; unsigned int filterMag = GL_NEAREST ; void Initialize ( const char * filePath ); void Generate (); unsigned int GetWrapFromString ( const std :: string & wrap ) const ; unsigned int GetFilterFromString ( const std :: string & filter ) const ; }; #endif //TEXTURE_H #include \"texture.h\" #include <stb_image/stb_image.h> Texture :: Texture ( const char * filePath ) : logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture :: Texture ( const char * filePath , unsigned int wrapS , unsigned int wrapT , unsigned int filterMin , unsigned int filterMag ) : wrapS ( wrapS ), wrapT ( wrapT ), filterMin ( filterMin ), filterMag ( filterMag ), logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture :: Texture ( const char * filePath , const std :: string & wrapS , const std :: string & wrapT , const std :: string & filterMin , const std :: string & filterMag ) : wrapS ( GetWrapFromString ( wrapS )), wrapT ( GetWrapFromString ( wrapT )), filterMin ( GetFilterFromString ( filterMin )), filterMag ( GetFilterFromString ( filterMag )), logger ( Logger :: GetInstance ()) { Initialize ( filePath ); } Texture ::~ Texture () { stbi_image_free ( data ); data = nullptr ; } void Texture :: Initialize ( const char * filePath ) { fileName = std :: string ( filePath ); // load image, create texture, and generate mipmaps stbi_set_flip_vertically_on_load ( false ); data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); if ( IsValid ()) { Generate (); } else { logger -> Error ( \"Texture failed to load at: %s\" , filePath ); } } void Texture :: Generate () { if ( nrChannels == 1 ) { imageFormat = GL_RED ; } else if ( nrChannels == 3 ) { imageFormat = GL_RGB ; } else if ( nrChannels == 4 ) { imageFormat = GL_RGBA ; } // Create texture glGenTextures ( 1 , & ID ); Bind (); glTexImage2D ( GL_TEXTURE_2D , 0 , internalFormat , width , height , 0 , imageFormat , GL_UNSIGNED_BYTE , data ); glGenerateMipmap ( GL_TEXTURE_2D ); // Wrap and filter modes glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , wrapS ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , wrapT ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , filterMin ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , filterMag ); // Unbind texture glBindTexture ( GL_TEXTURE_2D , 0 ); } unsigned int Texture :: GetWrapFromString ( const std :: string & wrap ) const { if ( wrap == \"clamp_to_border\" ) { return GL_CLAMP_TO_BORDER ; } else if ( wrap == \"clamp_to_edge\" ) { return GL_CLAMP_TO_EDGE ; } else if ( wrap == \"repeat\" ) { return GL_REPEAT ; } else if ( wrap == \"mirrored_repeat\" ) { return GL_MIRRORED_REPEAT ; } logger -> Error ( \"'%s' is an invalid wrap value!\" , wrap . c_str ()); return wrapS ; } unsigned int Texture :: GetFilterFromString ( const std :: string & filter ) const { if ( filter == \"nearest\" ) { return GL_NEAREST ; } else if ( filter == \"linear\" ) { return GL_LINEAR ; } logger -> Error ( \"'%s' is an invalid filter value!\" , filter . c_str ()); return filterMin ; } void Texture :: Bind () const { glBindTexture ( GL_TEXTURE_2D , ID ); } std :: string Texture :: GetFilePath () const { return fileName ; } int Texture :: GetWidth () const { return width ; } int Texture :: GetHeight () const { return height ; } unsigned int Texture :: GetImageFormat () const { return imageFormat ; } unsigned char * Texture :: GetData () const { return data ; } bool Texture :: IsValid () const { if ( data ) { return true ; } return false ; } The Texture class has quite a few member variables. fileName is just the file path of the texture file. data is the texture data in memory. width and height are self explanatory. nrChannels represent the number of color channels. internalFormat specifies the number of color components in the texture. imageFormat is set based on the number of color channels for the loaded texture. wrapS and wrapT refers to the texture wrapping mode applied to the S and T axis. Below are the 4 possible values: GL_REPEAT : The default behavior for textures. Repeats the texture image. GL_MIRRORED_REPEAT : Same as GL_REPEAT but mirrors the image with each repeat. GL_CLAMP_TO_EDGE : Clamps the coordinates between 0 and 1. The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern. GL_CLAMP_TO_BORDER : Coordinates outside the range are now given a user-specified border color. filterMin and filterMax refers to the texture filtering mode. Below are the possible values: GL_NEAREST : OpenGL selects the texel that center is closest to the texture coordinate. Ideal for pixel art games. GL_LINEAR : OpenGL takes an interpolated value from the texture coordinate's neighboring texel. The Initialize function is called by both constructors. Texture data is loaded by stb_image library with the following line: data = stbi_load ( filePath , & width , & height , & nrChannels , 0 ); If the texture is loaded successfully, the Generate function is called. This function configures the texture for OpenGL. The only other function to point out is the Bind function which we'll get into once we start rendering textures.","title":"Texture Class"},{"location":"opengl_rendering/asset_management/#asset-manager","text":"Now that we have the concept of a texture defined in Red Engine , we will need something to maintain textures as well as other assets. #ifndef ASSET_MANAGER_H #define ASSET_MANAGER_H #include <unordered_map> #include <string> #include \"./re/utils/logger.h\" #include \"./re/rendering/texture.h\" class AssetManager { public : static AssetManager * GetInstance (); void LoadTexture ( const std :: string & id , const std :: string & filePath ); Texture * GetTexture ( const std :: string & id ); bool HasTexture ( const std :: string & id ) const ; private : std :: unordered_map < std :: string , Texture *> textures ; Logger * logger = nullptr ; AssetManager (); }; #endif //ASSET_MANAGER_H #include \"asset_manager.h\" #include <cassert> AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()) {} AssetManager * AssetManager :: GetInstance () { static AssetManager * instance = new AssetManager (); return instance ; } void AssetManager :: LoadTexture ( const std :: string & id , const std :: string & filePath ) { Texture * texture = new Texture ( filePath . c_str ()); assert ( texture -> IsValid () && \"Failed to load texture!\" ); if ( HasTexture ( id )) { logger -> Warn ( \"Already have texture, not loading...\" ); return ; } textures . emplace ( id , texture ); } Texture * AssetManager :: GetTexture ( const std :: string & id ) { assert ( HasTexture ( id ) && \"Failed to get texture!\" ); return textures [ id ]; } bool AssetManager :: HasTexture ( const std :: string & id ) const { return textures . count ( id ) > 0 ; } The AssetManager class is a singleton with 3 functions to pay attention to. LoadTexture loads a new instance of the Texture class and places it in the textures map. GetTexture just retrieves a texture by id from the map. And HasTexture checks to see if the texture is stored by AssetManager . Other assets will follow the same 3 function pattern as textures and will be discussed in a later section.","title":"Asset Manager"},{"location":"opengl_rendering/rendering_sprites/","text":"Rendering Sprites Math Lib GLM GLM is a header only math library based on the OpenGL Shading Language (GLSL) specifications. Most things related to math such as vectors, matrices, etc... will be handled by GLM. Rectangle The Rectangle class will mostly be used for defining the bounds of a sprite's draw source and draw destination which we'll get to later. #ifndef RECTANGLE_H #define RECTANGLE_H #include <iostream> #include <glm/glm.hpp> class Rectangle { public : float x ; float y ; float w ; float h ; Rectangle () : x ( 0.0f ), y ( 0.0f ), w ( 0.0f ), h ( 0.0f ) {} Rectangle ( float x , float y , float w , float h ) : x ( x ), y ( y ), w ( w ), h ( h ) {} Rectangle ( float x , float y , glm :: vec2 size ) : x ( x ), y ( y ), w ( size . x ), h ( size . y ) {} Rectangle ( glm :: vec2 position , glm :: vec2 size ) : x ( position . x ), y ( position . y ), w ( size . x ), h ( size . y ) {} bool operator == ( const Rectangle & otherRect2 ) const { return this -> x == otherRect2 . x && this -> y == otherRect2 . y && this -> w == otherRect2 . w && this -> h == otherRect2 . h ; } bool operator != ( const Rectangle & otherRect2 ) const { return ! ( * this == otherRect2 ); } friend std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ); }; #endif //RECTANGLE_H #include \"rectangle.h\" std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ) { os << \"(\" << r . x << \", \" << r . y << \", \" << r . w << \", \" << r . h << \")\" ; return os ; } Custom Math Header Red Engine will use GLM, but we may want to use another math library or write our own in the future. To make this easier, will we define type aliases for math related classes. #ifndef MATH_H #define MATH_H #include \"rectangle.h\" using Vector2 = glm :: vec2 ; using IVector2 = glm :: ivec2 ; using Vector3 = glm :: vec3 ; using Matrix4 = glm :: mat4 ; using Rect2 = Rectangle ; #endif //MATH_H Color Not much to explain other than needing a concept of color within the engine. #ifndef COLOR_H #define COLOR_H #include <glad/glad.h> class Color { public : float r = 1.0f ; float g = 1.0f ; float b = 1.0f ; float a = 1.0f ; Color () {} Color ( GLfloat red , GLfloat green , GLfloat blue ) : r ( red ), g ( green ), b ( blue ), a ( 1.0f ) {} Color ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) : r ( red ), g ( green ), b ( blue ), a ( alpha ) {} Color operator * ( float value ) { return Color ( this -> r * value , this -> g * value , this -> b * value , this -> a ); } }; #endif //COLOR_H Renderer Batcher The RendererBatcher class will be used to take draw calls and batch them to be used during rendering. Typically, batching is done to limit draw calls for efficiency and performance reasons but for simplicity\u2019s sake this batcher will be designed to just defer and submit draw calls during the Render phase. #ifndef RENDERER_BATCHER_H #define RENDERER_BATCHER_H #include <vector> #include <map> #include <string> #include <functional> #include \"./re/rendering/color.h\" #include \"./re/rendering/texture.h\" #include \"./re/math/math.h\" struct SpriteBatchItem { Texture * texture2D = nullptr ; Rect2 sourceRectangle ; Rect2 destinationRectangle ; float rotation = 0.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); bool flipX = false ; bool flipY = false ; }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; }; using RenderFlushFunction = std :: function < void ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) > ; class RendererBatcher { public : void BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ); void Flush ( const RenderFlushFunction & renderFlushFunction ); private : std :: map < int , ZIndexDrawBatch > drawBatches ; }; #endif //RENDERER_BATCHER_H #include \"./renderer_batcher.h\" void RendererBatcher::BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. spriteDrawBatches . emplace_back ( spriteBatchItem ); } void RendererBatcher::Flush ( const RenderFlushFunction & renderFlushFunction ) { for ( const auto & pair : drawBatches ) { const int zIndex = pair . first ; const ZIndexDrawBatch & zIndexDrawBatch = pair . second ; renderFlushFunction ( zIndex , zIndexDrawBatch ); } drawBatches . clear (); } The first thing to point out is the SpriteBatchItem struct as this will be used to determine what to render for a sprite. Red Engine will group draw batches by their z indices. The ZIndexDrawBatch struct will represent a draw batch for a particular z index. We also define an alias RenderFlushFunction to be used as a lambda function to render flushed draw batches by the Renderer which we'll get to later. RendererBatcher class is currently simple as it has one map and two functions. The drawBatches map maintains the order of draw batches based on their z indices. BatchDrawSprite will submit a batch item to the batcher to draw during the render phase. The Flush function is called during the render phase to render batch items submitted and will clear them when completed. 2D Rendering Shaders What are shaders? They are simply GPU programs, in the case of OpenGL written in GLSL (OpenGL Shading Language). Before we write the renderer for Red Engine we'll first implement the Shader class which will compile shaders, install the shaders for use, and set uniform variables . A shader can be written for each of the shader stages , but we will only use vertex and fragment shaders in Red Engine . #ifndef SHADER_H #define SHADER_H #include <string> #include <fstream> #include <sstream> #include <iostream> #include <glad/glad.h> #include \"../math/math.h\" #include \"./color.h\" #include \"../utils/logger.h\" struct OpenGLShaderSourceCode { std :: string vertex ; std :: string fragment ; }; class Shader { public : Shader (); Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ); Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ); ~ Shader (); OpenGLShaderSourceCode GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ); void Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ); void Use (); void SetBool ( const std :: string & name , bool value ) const ; void SetInt ( const std :: string & name , int value ) const ; void SetFloat ( const std :: string & name , float value ) const ; void SetVec2Float ( const std :: string & name , float v1 , float v2 ) const ; void SetVec2Float ( const std :: string & name , const Vector2 & value ) const ; void SetVec3Float ( const std :: string & name , const Color & value ) const ; void SetVec3Float ( const std :: string & name , const Vector3 & value ) const ; void SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const ; void SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const ; void SetVec4Float ( const std :: string & name , const Color & value ) const ; void SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const ; private : unsigned int ID ; Logger * logger = nullptr ; bool IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ); void CheckCompileErrors ( unsigned int shader , const std :: string & type ); }; #endif //SHADER_H #include \"shader.h\" #include <cassert> #include <glm/gtc/type_ptr.hpp> #include \"../utils/file_helper.h\" Shader :: Shader () : logger ( Logger :: GetInstance ()) {} Shader :: Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ) : logger ( Logger :: GetInstance ()) { Compile ( GetOpenGLShaderSourceFromPaths ( vertexPath , fragmentPath )); } Shader :: Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ) : logger ( Logger :: GetInstance ()) { Compile ( openGlShaderSourceCode ); } Shader ::~ Shader () {} OpenGLShaderSourceCode Shader :: GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ) { OpenGLShaderSourceCode openGlShaderSourceCode ; if ( IsShaderFilesValid ( vertexPath , fragmentPath )) { std :: ifstream vertexShaderFile ; std :: ifstream fragmentShaderFile ; vertexShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); fragmentShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); try { vertexShaderFile . open ( vertexPath . c_str ()); fragmentShaderFile . open ( fragmentPath . c_str ()); std :: stringstream vertexShaderStream , fragmentShaderStream ; vertexShaderStream << vertexShaderFile . rdbuf (); fragmentShaderStream << fragmentShaderFile . rdbuf (); vertexShaderFile . close (); fragmentShaderFile . close (); openGlShaderSourceCode . vertex = vertexShaderStream . str (); openGlShaderSourceCode . fragment = fragmentShaderStream . str (); } catch ( std :: ifstream :: failure & e ) { logger -> Error ( \"Error reading shader files! \\n \" \"vertex path = '%s' \\n fragment path = '%s'!\" , vertexPath . c_str (), fragmentPath . c_str ()); } } return openGlShaderSourceCode ; } void Shader :: Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ) { unsigned int vertex , fragment ; const char * vertexSource = openGlShaderSourceCode . vertex . c_str (); const char * fragmentSource = openGlShaderSourceCode . fragment . c_str (); // vertex vertex = glCreateShader ( GL_VERTEX_SHADER ); glShaderSource ( vertex , 1 , & vertexSource , nullptr ); glCompileShader ( vertex ); CheckCompileErrors ( vertex , \"VERTEX\" ); // fragment fragment = glCreateShader ( GL_FRAGMENT_SHADER ); glShaderSource ( fragment , 1 , & fragmentSource , nullptr ); glCompileShader ( fragment ); CheckCompileErrors ( fragment , \"FRAGMENT\" ); // shader ID = glCreateProgram (); glAttachShader ( ID , vertex ); glAttachShader ( ID , fragment ); glLinkProgram ( ID ); CheckCompileErrors ( ID , \"PROGRAM\" ); glDeleteShader ( vertex ); glDeleteShader ( fragment ); } void Shader :: Use () { glUseProgram ( ID ); } void Shader :: SetBool ( const std :: string & name , bool value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), ( int ) value ); } void Shader :: SetInt ( const std :: string & name , int value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetFloat ( const std :: string & name , float value ) const { glUniform1f ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetVec2Float ( const std :: string & name , float v1 , float v2 ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 ); } void Shader :: SetVec2Float ( const std :: string & name , const Vector2 & value ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y ); } void Shader :: SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 ); } void Shader :: SetVec3Float ( const std :: string & name , const Color & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b ); } void Shader :: SetVec3Float ( const std :: string & name , const Vector3 & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y , value . z ); } void Shader :: SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 , v4 ); } void Shader :: SetVec4Float ( const std :: string & name , const Color & value ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b , value . a ); } void Shader :: SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const { glUniformMatrix4fv ( glGetUniformLocation ( this -> ID , name . c_str ()), 1 , GL_FALSE , glm :: value_ptr ( mat )); } bool Shader :: IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ) { bool isValid = true ; if ( ! FileHelper :: DoesFileExist ( vertexPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } if ( ! FileHelper :: DoesFileExist ( fragmentPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } return isValid ; } void Shader :: CheckCompileErrors ( unsigned int shader , const std :: string & type ) { int success ; char infoLog [ 1024 ]; if ( type == \"PROGRAM\" ) { glGetProgramiv ( shader , GL_LINK_STATUS , & success ); if ( ! success ) { glGetProgramInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' linking failed! \\n %s\" , type . c_str (), infoLog ); } } else { glGetShaderiv ( shader , GL_COMPILE_STATUS , & success ); if ( ! success ) { glGetShaderInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' compilation failed! \\n %s\" , type . c_str (), infoLog ); } } } First, the OpenGLShaderSourceCode struct is used to hold a string representation of the shader code. The Shader class has two constructors, one that accepts OpenGLShaderSourceCode and another that accepts the file paths of the vertex and fragment shaders file paths as parameters which we won't use for this tutorial series. The Compile function compiles the vertex and fragment shaders, attaches the shader objects to the shader program, and links the shader program. We will call the Use function whenever we need to install a shader for use which we'll see an example of later. Other than that, the last thing to mention is the multiple Set$TYPE functions. These are used to set uniform variables within the shaders and we will see how they are used in the next section. SpriteRenderer #ifndef SPRITE_RENDERER_H #define SPRITE_RENDERER_H #include <glad/glad.h> #include \"./re/rendering/shader.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/color.h\" #include \"./re/math/math.h\" #include \"project_properties.h\" static const std :: string & OPENGL_SHADER_SOURCE_VERTEX_SPRITE = \"#version 330 core \\n \" \" \\n \" \"layout (location = 0) in vec4 vertex; \\n \" \" \\n \" \"out vec2 texCoord; \\n \" \" \\n \" \"uniform mat4 projection; \\n \" \"uniform mat4 model; \\n \" \" \\n \" \"void main() { \\n \" \" texCoord = vertex.zw; \\n \" \" gl_Position = projection * model * vec4(vertex.xy, 0.0f, 1.0f); \\n \" \"} \\n \" \"\" ; static const std :: string & OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE = \"#version 330 core \\n \" \" \\n \" \"in vec2 texCoord; \\n \" \"out vec4 color; \\n \" \" \\n \" \"uniform sampler2D sprite; \\n \" \"uniform vec4 spriteColor; \\n \" \" \\n \" \"void main() { \\n \" \" color = spriteColor * texture(sprite, texCoord); \\n \" \"} \\n \" \"\" ; static const OpenGLShaderSourceCode OPENGL_SHADER_SOURCE_SPRITE = OpenGLShaderSourceCode { . vertex = OPENGL_SHADER_SOURCE_VERTEX_SPRITE , . fragment = OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE }; class SpriteRenderer { public : SpriteRenderer (); void Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ); private : Shader shader ; GLuint quadVAO ; GLuint quadVBO ; ProjectProperties * projectProperties = nullptr ; }; #endif //SPRITE_RENDERER_H #include \"sprite_renderer.h\" #include <glm/gtc/matrix_transform.hpp> SpriteRenderer :: SpriteRenderer () : projectProperties ( ProjectProperties :: GetInstance ()) { GLfloat vertices [] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; glGenVertexArrays ( 1 , & quadVAO ); glGenBuffers ( 1 , & quadVBO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( vertices ), vertices , GL_STATIC_DRAW ); glBindVertexArray ( quadVAO ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), ( void * ) nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); shader = Shader ( OPENGL_SHADER_SOURCE_SPRITE ); shader . Use (); shader . SetInt ( \"sprite\" , 0 ); Matrix4 projection = glm :: ortho ( 0.0f , static_cast < float > ( projectProperties -> GetWindowWidth ()), static_cast < float > ( projectProperties -> GetWindowHeight ()), 0.0f , -1.0f , 1.0f ); shader . SetMatrix4Float ( \"projection\" , projection ); } void SpriteRenderer :: Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ) { // 1. Translation Matrix4 model = glm :: mat4 ( 1.0f ); model = glm :: translate ( model , glm :: vec3 ( destinationRectangle . x , destinationRectangle . y , 0.0f )); // first translate (transformations are: scale happens first, then rotation, and then final translation happens; reversed order) // 2. Rotation model = glm :: translate ( model , Vector3 ( 0.5f * destinationRectangle . w , 0.5f * destinationRectangle . h , 0.0f )); // move origin of rotation to center of quad model = glm :: rotate ( model , glm :: radians ( rotation ), Vector3 ( 0.0f , 0.0f , 1.0f )); // then rotate model = glm :: translate ( model , Vector3 ( -0.5f * destinationRectangle . w , -0.5f * destinationRectangle . h , 0.0f )); // move origin back // 3. Scaling model = glm :: scale ( model , Vector3 ( destinationRectangle . w , destinationRectangle . h , 1.0f )); // last scale glBindVertexArray ( quadVAO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); shader . Use (); shader . SetMatrix4Float ( \"model\" , model ); shader . SetVec4Float ( \"spriteColor\" , color . r , color . g , color . b , color . a ); glActiveTexture ( GL_TEXTURE0 ); texture2D -> Bind (); // render subimage based on source rectangle glPixelStorei ( GL_UNPACK_ROW_LENGTH , texture2D -> GetWidth ()); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , sourceRectangle . x ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , sourceRectangle . y ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RGBA , sourceRectangle . w , sourceRectangle . h , 0 , texture2D -> GetImageFormat (), GL_UNSIGNED_BYTE , texture2D -> GetData ()); glPixelStorei ( GL_UNPACK_ROW_LENGTH , 0 ); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , 0 ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , 0 ); // Render Container GLfloat vertices [ 6 ][ 4 ] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; static const int VERT_X = 2 ; static const int VERT_Y = 3 ; if ( flipX ) { vertices [ 0 ][ VERT_X ] = 1.0f ; vertices [ 1 ][ VERT_X ] = 0.0f ; vertices [ 2 ][ VERT_X ] = 1.0f ; vertices [ 3 ][ VERT_X ] = 1.0f ; vertices [ 4 ][ VERT_X ] = 0.0f ; vertices [ 5 ][ VERT_X ] = 0.0f ; } if ( flipY ) { vertices [ 0 ][ VERT_Y ] = 0.0f ; vertices [ 1 ][ VERT_Y ] = 1.0f ; vertices [ 2 ][ VERT_Y ] = 1.0f ; vertices [ 3 ][ VERT_Y ] = 0.0f ; vertices [ 4 ][ VERT_Y ] = 0.0f ; vertices [ 5 ][ VERT_Y ] = 1.0f ; } glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( vertices ), vertices ); glDrawArrays ( GL_TRIANGLES , 0 , 6 ); glBindVertexArray ( 0 ); } Shader Code Vertex #version 330 core layout ( location = 0 ) in vec4 vertex ; out vec2 texCoord uniform mat4 projection ; uniform mat4 model ; void main () { texCoord = vertex . zw ; gl_Position = projection * model * vec4 ( vertex . xy , 0.0 f , 1.0 f ); } Fragment #version 330 core in vec2 texCoord ; out vec4 color ; uniform sampler2D sprite ; uniform vec4 spriteColor ; void main () { color = spriteColor * texture ( sprite , texCoord ); } SpriteRenderer Class Explanation coming soon... Renderer2D #ifndef RENDERER_2D_H #define RENDERER_2D_H #include \"renderer_batcher.h\" #include \"sprite_renderer.h\" class Renderer2D { public : Renderer2D () = default ; ~ Renderer2D (); void Initialize (); void SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation = 0.0f , Color color = Color ( 1.0f , 1.0f , 1.0f ), bool flipX = false , bool flipY = false ); void FlushBatches (); private : RendererBatcher rendererBatcher ; SpriteRenderer * spriteRenderer = nullptr ; }; #endif //RENDERER_2D_H #include \"renderer_2d.h\" #include <cassert> #include <glad/glad.h> Renderer2D ::~ Renderer2D () { if ( spriteRenderer != nullptr ) { delete spriteRenderer ; } } void Renderer2D :: Initialize () { glEnable ( GL_BLEND ); glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ); spriteRenderer = new SpriteRenderer (); } void Renderer2D :: SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation , Color color , bool flipX , bool flipY ) { SpriteBatchItem spriteBatchItem = { texture2D , sourceRectangle , destinationRectangle , rotation , color , flipX , flipY }; rendererBatcher . BatchDrawSprite ( spriteBatchItem , zIndex ); } void Renderer2D :: FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } }; rendererBatcher . Flush ( renderFlushFunction ); } Explanation coming soon... Render Sprites Updating constructor to initialize member pointer variables. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } Implementing the private InitializeRendering function. void GameEngine::InitializeRendering () { // OpenGL attributes SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); renderContext -> window = SDL_CreateWindow ( projectProperties -> GetGameTitle (). c_str (), SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , projectProperties -> GetWindowWidth (), projectProperties -> GetWindowHeight (), renderContext -> windowFlags ); renderContext -> glContext = SDL_GL_CreateContext ( renderContext -> window ); renderContext -> currentWindowWidth = projectProperties -> GetWindowWidth (); renderContext -> currentWindowHeight = projectProperties -> GetWindowHeight (); if ( ! gladLoadGLLoader (( GLADloadproc ) SDL_GL_GetProcAddress )) { logger -> Error ( \"Couldn't initialize glad\" ); } renderer2D . Initialize (); // Temp Load Assets assetManager -> LoadTexture ( \"assets/images/melissa_walk_animation.png\" , \"assets/images/melissa_walk_animation.png\" ); } Now we will implement the Render function. void GameEngine::Render () { glClearColor ( projectProperties -> backgroundClearColor . r , projectProperties -> backgroundClearColor . g , projectProperties -> backgroundClearColor . b , projectProperties -> backgroundClearColor . a ); glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT ); // Render Sprites static Texture * mellisaWalkTexture = assetManager -> GetTexture ( \"assets/images/melissa_walk_animation.png\" ); static Rect2 drawSourceRect = Rect2 ( 0 , 0 , 32 , 32 ); static Rect2 drawDestinationRect = Rect2 ( windowCenter . x , windowCenter . y , drawSourceRect . w , drawSourceRect . h ); renderer2D . SubmitSpriteBatchItem ( mellisaWalkTexture , drawSourceRect , drawDestinationRect , 0 ); // Flush renderer2D . FlushBatches (); SDL_GL_SwapWindow ( renderContext -> window ); } Lastly we are going to process input by checking if an SDL_QUIT event type was triggered. If we click the 'X' in the top right part of the window, we will now close the window and shutdown the engine. void GameEngine::ProcessInput () { SDL_Event event ; while ( SDL_PollEvent ( & event )) { switch ( event . type ) { case SDL_QUIT : engineContext -> SetRunning ( false ); break ; case SDL_WINDOWEVENT : switch ( event . window . event ) { case SDL_WINDOWEVENT_RESIZED : renderContext -> currentWindowWidth = event . window . data1 ; renderContext -> currentWindowHeight = event . window . data2 ; glViewport ( 0 , 0 , renderContext -> currentWindowWidth , renderContext -> currentWindowHeight ); break ; } break ; } } } After executing the code, this will be rendered to the screen: The source code for this section can be found here . Now that we have rendered a sprite it's now time to render font.","title":"Rendering Sprites"},{"location":"opengl_rendering/rendering_sprites/#rendering-sprites","text":"","title":"Rendering Sprites"},{"location":"opengl_rendering/rendering_sprites/#math-lib","text":"","title":"Math Lib"},{"location":"opengl_rendering/rendering_sprites/#glm","text":"GLM is a header only math library based on the OpenGL Shading Language (GLSL) specifications. Most things related to math such as vectors, matrices, etc... will be handled by GLM.","title":"GLM"},{"location":"opengl_rendering/rendering_sprites/#rectangle","text":"The Rectangle class will mostly be used for defining the bounds of a sprite's draw source and draw destination which we'll get to later. #ifndef RECTANGLE_H #define RECTANGLE_H #include <iostream> #include <glm/glm.hpp> class Rectangle { public : float x ; float y ; float w ; float h ; Rectangle () : x ( 0.0f ), y ( 0.0f ), w ( 0.0f ), h ( 0.0f ) {} Rectangle ( float x , float y , float w , float h ) : x ( x ), y ( y ), w ( w ), h ( h ) {} Rectangle ( float x , float y , glm :: vec2 size ) : x ( x ), y ( y ), w ( size . x ), h ( size . y ) {} Rectangle ( glm :: vec2 position , glm :: vec2 size ) : x ( position . x ), y ( position . y ), w ( size . x ), h ( size . y ) {} bool operator == ( const Rectangle & otherRect2 ) const { return this -> x == otherRect2 . x && this -> y == otherRect2 . y && this -> w == otherRect2 . w && this -> h == otherRect2 . h ; } bool operator != ( const Rectangle & otherRect2 ) const { return ! ( * this == otherRect2 ); } friend std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ); }; #endif //RECTANGLE_H #include \"rectangle.h\" std :: ostream & operator << ( std :: ostream & os , const Rectangle & r ) { os << \"(\" << r . x << \", \" << r . y << \", \" << r . w << \", \" << r . h << \")\" ; return os ; }","title":"Rectangle"},{"location":"opengl_rendering/rendering_sprites/#custom-math-header","text":"Red Engine will use GLM, but we may want to use another math library or write our own in the future. To make this easier, will we define type aliases for math related classes. #ifndef MATH_H #define MATH_H #include \"rectangle.h\" using Vector2 = glm :: vec2 ; using IVector2 = glm :: ivec2 ; using Vector3 = glm :: vec3 ; using Matrix4 = glm :: mat4 ; using Rect2 = Rectangle ; #endif //MATH_H","title":"Custom Math Header"},{"location":"opengl_rendering/rendering_sprites/#color","text":"Not much to explain other than needing a concept of color within the engine. #ifndef COLOR_H #define COLOR_H #include <glad/glad.h> class Color { public : float r = 1.0f ; float g = 1.0f ; float b = 1.0f ; float a = 1.0f ; Color () {} Color ( GLfloat red , GLfloat green , GLfloat blue ) : r ( red ), g ( green ), b ( blue ), a ( 1.0f ) {} Color ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) : r ( red ), g ( green ), b ( blue ), a ( alpha ) {} Color operator * ( float value ) { return Color ( this -> r * value , this -> g * value , this -> b * value , this -> a ); } }; #endif //COLOR_H","title":"Color"},{"location":"opengl_rendering/rendering_sprites/#renderer-batcher","text":"The RendererBatcher class will be used to take draw calls and batch them to be used during rendering. Typically, batching is done to limit draw calls for efficiency and performance reasons but for simplicity\u2019s sake this batcher will be designed to just defer and submit draw calls during the Render phase. #ifndef RENDERER_BATCHER_H #define RENDERER_BATCHER_H #include <vector> #include <map> #include <string> #include <functional> #include \"./re/rendering/color.h\" #include \"./re/rendering/texture.h\" #include \"./re/math/math.h\" struct SpriteBatchItem { Texture * texture2D = nullptr ; Rect2 sourceRectangle ; Rect2 destinationRectangle ; float rotation = 0.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); bool flipX = false ; bool flipY = false ; }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; }; using RenderFlushFunction = std :: function < void ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) > ; class RendererBatcher { public : void BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ); void Flush ( const RenderFlushFunction & renderFlushFunction ); private : std :: map < int , ZIndexDrawBatch > drawBatches ; }; #endif //RENDERER_BATCHER_H #include \"./renderer_batcher.h\" void RendererBatcher::BatchDrawSprite ( SpriteBatchItem spriteBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. spriteDrawBatches . emplace_back ( spriteBatchItem ); } void RendererBatcher::Flush ( const RenderFlushFunction & renderFlushFunction ) { for ( const auto & pair : drawBatches ) { const int zIndex = pair . first ; const ZIndexDrawBatch & zIndexDrawBatch = pair . second ; renderFlushFunction ( zIndex , zIndexDrawBatch ); } drawBatches . clear (); } The first thing to point out is the SpriteBatchItem struct as this will be used to determine what to render for a sprite. Red Engine will group draw batches by their z indices. The ZIndexDrawBatch struct will represent a draw batch for a particular z index. We also define an alias RenderFlushFunction to be used as a lambda function to render flushed draw batches by the Renderer which we'll get to later. RendererBatcher class is currently simple as it has one map and two functions. The drawBatches map maintains the order of draw batches based on their z indices. BatchDrawSprite will submit a batch item to the batcher to draw during the render phase. The Flush function is called during the render phase to render batch items submitted and will clear them when completed.","title":"Renderer Batcher"},{"location":"opengl_rendering/rendering_sprites/#2d-rendering","text":"","title":"2D Rendering"},{"location":"opengl_rendering/rendering_sprites/#shaders","text":"What are shaders? They are simply GPU programs, in the case of OpenGL written in GLSL (OpenGL Shading Language). Before we write the renderer for Red Engine we'll first implement the Shader class which will compile shaders, install the shaders for use, and set uniform variables . A shader can be written for each of the shader stages , but we will only use vertex and fragment shaders in Red Engine . #ifndef SHADER_H #define SHADER_H #include <string> #include <fstream> #include <sstream> #include <iostream> #include <glad/glad.h> #include \"../math/math.h\" #include \"./color.h\" #include \"../utils/logger.h\" struct OpenGLShaderSourceCode { std :: string vertex ; std :: string fragment ; }; class Shader { public : Shader (); Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ); Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ); ~ Shader (); OpenGLShaderSourceCode GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ); void Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ); void Use (); void SetBool ( const std :: string & name , bool value ) const ; void SetInt ( const std :: string & name , int value ) const ; void SetFloat ( const std :: string & name , float value ) const ; void SetVec2Float ( const std :: string & name , float v1 , float v2 ) const ; void SetVec2Float ( const std :: string & name , const Vector2 & value ) const ; void SetVec3Float ( const std :: string & name , const Color & value ) const ; void SetVec3Float ( const std :: string & name , const Vector3 & value ) const ; void SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const ; void SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const ; void SetVec4Float ( const std :: string & name , const Color & value ) const ; void SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const ; private : unsigned int ID ; Logger * logger = nullptr ; bool IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ); void CheckCompileErrors ( unsigned int shader , const std :: string & type ); }; #endif //SHADER_H #include \"shader.h\" #include <cassert> #include <glm/gtc/type_ptr.hpp> #include \"../utils/file_helper.h\" Shader :: Shader () : logger ( Logger :: GetInstance ()) {} Shader :: Shader ( const std :: string & vertexPath , const std :: string & fragmentPath ) : logger ( Logger :: GetInstance ()) { Compile ( GetOpenGLShaderSourceFromPaths ( vertexPath , fragmentPath )); } Shader :: Shader ( OpenGLShaderSourceCode openGlShaderSourceCode ) : logger ( Logger :: GetInstance ()) { Compile ( openGlShaderSourceCode ); } Shader ::~ Shader () {} OpenGLShaderSourceCode Shader :: GetOpenGLShaderSourceFromPaths ( const std :: string & vertexPath , const std :: string & fragmentPath ) { OpenGLShaderSourceCode openGlShaderSourceCode ; if ( IsShaderFilesValid ( vertexPath , fragmentPath )) { std :: ifstream vertexShaderFile ; std :: ifstream fragmentShaderFile ; vertexShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); fragmentShaderFile . exceptions ( std :: ifstream :: failbit | std :: ifstream :: badbit ); try { vertexShaderFile . open ( vertexPath . c_str ()); fragmentShaderFile . open ( fragmentPath . c_str ()); std :: stringstream vertexShaderStream , fragmentShaderStream ; vertexShaderStream << vertexShaderFile . rdbuf (); fragmentShaderStream << fragmentShaderFile . rdbuf (); vertexShaderFile . close (); fragmentShaderFile . close (); openGlShaderSourceCode . vertex = vertexShaderStream . str (); openGlShaderSourceCode . fragment = fragmentShaderStream . str (); } catch ( std :: ifstream :: failure & e ) { logger -> Error ( \"Error reading shader files! \\n \" \"vertex path = '%s' \\n fragment path = '%s'!\" , vertexPath . c_str (), fragmentPath . c_str ()); } } return openGlShaderSourceCode ; } void Shader :: Compile ( OpenGLShaderSourceCode openGlShaderSourceCode ) { unsigned int vertex , fragment ; const char * vertexSource = openGlShaderSourceCode . vertex . c_str (); const char * fragmentSource = openGlShaderSourceCode . fragment . c_str (); // vertex vertex = glCreateShader ( GL_VERTEX_SHADER ); glShaderSource ( vertex , 1 , & vertexSource , nullptr ); glCompileShader ( vertex ); CheckCompileErrors ( vertex , \"VERTEX\" ); // fragment fragment = glCreateShader ( GL_FRAGMENT_SHADER ); glShaderSource ( fragment , 1 , & fragmentSource , nullptr ); glCompileShader ( fragment ); CheckCompileErrors ( fragment , \"FRAGMENT\" ); // shader ID = glCreateProgram (); glAttachShader ( ID , vertex ); glAttachShader ( ID , fragment ); glLinkProgram ( ID ); CheckCompileErrors ( ID , \"PROGRAM\" ); glDeleteShader ( vertex ); glDeleteShader ( fragment ); } void Shader :: Use () { glUseProgram ( ID ); } void Shader :: SetBool ( const std :: string & name , bool value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), ( int ) value ); } void Shader :: SetInt ( const std :: string & name , int value ) const { glUniform1i ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetFloat ( const std :: string & name , float value ) const { glUniform1f ( glGetUniformLocation ( ID , name . c_str ()), value ); } void Shader :: SetVec2Float ( const std :: string & name , float v1 , float v2 ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 ); } void Shader :: SetVec2Float ( const std :: string & name , const Vector2 & value ) const { glUniform2f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y ); } void Shader :: SetVec3Float ( const std :: string & name , float v1 , float v2 , float v3 ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 ); } void Shader :: SetVec3Float ( const std :: string & name , const Color & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b ); } void Shader :: SetVec3Float ( const std :: string & name , const Vector3 & value ) const { glUniform3f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . x , value . y , value . z ); } void Shader :: SetVec4Float ( const std :: string & name , float v1 , float v2 , float v3 , float v4 ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), v1 , v2 , v3 , v4 ); } void Shader :: SetVec4Float ( const std :: string & name , const Color & value ) const { glUniform4f ( glGetUniformLocation ( this -> ID , name . c_str ()), value . r , value . g , value . b , value . a ); } void Shader :: SetMatrix4Float ( const std :: string & name , const Matrix4 & mat ) const { glUniformMatrix4fv ( glGetUniformLocation ( this -> ID , name . c_str ()), 1 , GL_FALSE , glm :: value_ptr ( mat )); } bool Shader :: IsShaderFilesValid ( const std :: string & vertexPath , const std :: string & fragmentPath ) { bool isValid = true ; if ( ! FileHelper :: DoesFileExist ( vertexPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } if ( ! FileHelper :: DoesFileExist ( fragmentPath )) { isValid = false ; logger -> Error ( \"Vertex file: %s doesn't exist!\" , vertexPath . c_str ()); } return isValid ; } void Shader :: CheckCompileErrors ( unsigned int shader , const std :: string & type ) { int success ; char infoLog [ 1024 ]; if ( type == \"PROGRAM\" ) { glGetProgramiv ( shader , GL_LINK_STATUS , & success ); if ( ! success ) { glGetProgramInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' linking failed! \\n %s\" , type . c_str (), infoLog ); } } else { glGetShaderiv ( shader , GL_COMPILE_STATUS , & success ); if ( ! success ) { glGetShaderInfoLog ( shader , 1024 , nullptr , infoLog ); logger -> Error ( \"Shader type '%s' compilation failed! \\n %s\" , type . c_str (), infoLog ); } } } First, the OpenGLShaderSourceCode struct is used to hold a string representation of the shader code. The Shader class has two constructors, one that accepts OpenGLShaderSourceCode and another that accepts the file paths of the vertex and fragment shaders file paths as parameters which we won't use for this tutorial series. The Compile function compiles the vertex and fragment shaders, attaches the shader objects to the shader program, and links the shader program. We will call the Use function whenever we need to install a shader for use which we'll see an example of later. Other than that, the last thing to mention is the multiple Set$TYPE functions. These are used to set uniform variables within the shaders and we will see how they are used in the next section.","title":"Shaders"},{"location":"opengl_rendering/rendering_sprites/#spriterenderer","text":"#ifndef SPRITE_RENDERER_H #define SPRITE_RENDERER_H #include <glad/glad.h> #include \"./re/rendering/shader.h\" #include \"./re/rendering/texture.h\" #include \"./re/rendering/color.h\" #include \"./re/math/math.h\" #include \"project_properties.h\" static const std :: string & OPENGL_SHADER_SOURCE_VERTEX_SPRITE = \"#version 330 core \\n \" \" \\n \" \"layout (location = 0) in vec4 vertex; \\n \" \" \\n \" \"out vec2 texCoord; \\n \" \" \\n \" \"uniform mat4 projection; \\n \" \"uniform mat4 model; \\n \" \" \\n \" \"void main() { \\n \" \" texCoord = vertex.zw; \\n \" \" gl_Position = projection * model * vec4(vertex.xy, 0.0f, 1.0f); \\n \" \"} \\n \" \"\" ; static const std :: string & OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE = \"#version 330 core \\n \" \" \\n \" \"in vec2 texCoord; \\n \" \"out vec4 color; \\n \" \" \\n \" \"uniform sampler2D sprite; \\n \" \"uniform vec4 spriteColor; \\n \" \" \\n \" \"void main() { \\n \" \" color = spriteColor * texture(sprite, texCoord); \\n \" \"} \\n \" \"\" ; static const OpenGLShaderSourceCode OPENGL_SHADER_SOURCE_SPRITE = OpenGLShaderSourceCode { . vertex = OPENGL_SHADER_SOURCE_VERTEX_SPRITE , . fragment = OPENGL_SHADER_SOURCE_FRAGMENT_SPRITE }; class SpriteRenderer { public : SpriteRenderer (); void Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ); private : Shader shader ; GLuint quadVAO ; GLuint quadVBO ; ProjectProperties * projectProperties = nullptr ; }; #endif //SPRITE_RENDERER_H #include \"sprite_renderer.h\" #include <glm/gtc/matrix_transform.hpp> SpriteRenderer :: SpriteRenderer () : projectProperties ( ProjectProperties :: GetInstance ()) { GLfloat vertices [] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; glGenVertexArrays ( 1 , & quadVAO ); glGenBuffers ( 1 , & quadVBO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( vertices ), vertices , GL_STATIC_DRAW ); glBindVertexArray ( quadVAO ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), ( void * ) nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); shader = Shader ( OPENGL_SHADER_SOURCE_SPRITE ); shader . Use (); shader . SetInt ( \"sprite\" , 0 ); Matrix4 projection = glm :: ortho ( 0.0f , static_cast < float > ( projectProperties -> GetWindowWidth ()), static_cast < float > ( projectProperties -> GetWindowHeight ()), 0.0f , -1.0f , 1.0f ); shader . SetMatrix4Float ( \"projection\" , projection ); } void SpriteRenderer :: Draw ( Texture * texture2D , const Rect2 & sourceRectangle , const Rect2 & destinationRectangle , float rotation , const Color & color , bool flipX , bool flipY ) { // 1. Translation Matrix4 model = glm :: mat4 ( 1.0f ); model = glm :: translate ( model , glm :: vec3 ( destinationRectangle . x , destinationRectangle . y , 0.0f )); // first translate (transformations are: scale happens first, then rotation, and then final translation happens; reversed order) // 2. Rotation model = glm :: translate ( model , Vector3 ( 0.5f * destinationRectangle . w , 0.5f * destinationRectangle . h , 0.0f )); // move origin of rotation to center of quad model = glm :: rotate ( model , glm :: radians ( rotation ), Vector3 ( 0.0f , 0.0f , 1.0f )); // then rotate model = glm :: translate ( model , Vector3 ( -0.5f * destinationRectangle . w , -0.5f * destinationRectangle . h , 0.0f )); // move origin back // 3. Scaling model = glm :: scale ( model , Vector3 ( destinationRectangle . w , destinationRectangle . h , 1.0f )); // last scale glBindVertexArray ( quadVAO ); glBindBuffer ( GL_ARRAY_BUFFER , quadVBO ); shader . Use (); shader . SetMatrix4Float ( \"model\" , model ); shader . SetVec4Float ( \"spriteColor\" , color . r , color . g , color . b , color . a ); glActiveTexture ( GL_TEXTURE0 ); texture2D -> Bind (); // render subimage based on source rectangle glPixelStorei ( GL_UNPACK_ROW_LENGTH , texture2D -> GetWidth ()); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , sourceRectangle . x ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , sourceRectangle . y ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RGBA , sourceRectangle . w , sourceRectangle . h , 0 , texture2D -> GetImageFormat (), GL_UNSIGNED_BYTE , texture2D -> GetData ()); glPixelStorei ( GL_UNPACK_ROW_LENGTH , 0 ); glPixelStorei ( GL_UNPACK_SKIP_PIXELS , 0 ); glPixelStorei ( GL_UNPACK_SKIP_ROWS , 0 ); // Render Container GLfloat vertices [ 6 ][ 4 ] = { // positions // texture coordinates 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 1.0f , 0.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 1.0f , 0.0f , 1.0f , 0.0f }; static const int VERT_X = 2 ; static const int VERT_Y = 3 ; if ( flipX ) { vertices [ 0 ][ VERT_X ] = 1.0f ; vertices [ 1 ][ VERT_X ] = 0.0f ; vertices [ 2 ][ VERT_X ] = 1.0f ; vertices [ 3 ][ VERT_X ] = 1.0f ; vertices [ 4 ][ VERT_X ] = 0.0f ; vertices [ 5 ][ VERT_X ] = 0.0f ; } if ( flipY ) { vertices [ 0 ][ VERT_Y ] = 0.0f ; vertices [ 1 ][ VERT_Y ] = 1.0f ; vertices [ 2 ][ VERT_Y ] = 1.0f ; vertices [ 3 ][ VERT_Y ] = 0.0f ; vertices [ 4 ][ VERT_Y ] = 0.0f ; vertices [ 5 ][ VERT_Y ] = 1.0f ; } glBufferSubData ( GL_ARRAY_BUFFER , 0 , sizeof ( vertices ), vertices ); glDrawArrays ( GL_TRIANGLES , 0 , 6 ); glBindVertexArray ( 0 ); }","title":"SpriteRenderer"},{"location":"opengl_rendering/rendering_sprites/#shader-code","text":"Vertex #version 330 core layout ( location = 0 ) in vec4 vertex ; out vec2 texCoord uniform mat4 projection ; uniform mat4 model ; void main () { texCoord = vertex . zw ; gl_Position = projection * model * vec4 ( vertex . xy , 0.0 f , 1.0 f ); } Fragment #version 330 core in vec2 texCoord ; out vec4 color ; uniform sampler2D sprite ; uniform vec4 spriteColor ; void main () { color = spriteColor * texture ( sprite , texCoord ); }","title":"Shader Code"},{"location":"opengl_rendering/rendering_sprites/#spriterenderer-class","text":"Explanation coming soon...","title":"SpriteRenderer Class"},{"location":"opengl_rendering/rendering_sprites/#renderer2d","text":"#ifndef RENDERER_2D_H #define RENDERER_2D_H #include \"renderer_batcher.h\" #include \"sprite_renderer.h\" class Renderer2D { public : Renderer2D () = default ; ~ Renderer2D (); void Initialize (); void SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation = 0.0f , Color color = Color ( 1.0f , 1.0f , 1.0f ), bool flipX = false , bool flipY = false ); void FlushBatches (); private : RendererBatcher rendererBatcher ; SpriteRenderer * spriteRenderer = nullptr ; }; #endif //RENDERER_2D_H #include \"renderer_2d.h\" #include <cassert> #include <glad/glad.h> Renderer2D ::~ Renderer2D () { if ( spriteRenderer != nullptr ) { delete spriteRenderer ; } } void Renderer2D :: Initialize () { glEnable ( GL_BLEND ); glBlendFunc ( GL_SRC_ALPHA , GL_ONE_MINUS_SRC_ALPHA ); spriteRenderer = new SpriteRenderer (); } void Renderer2D :: SubmitSpriteBatchItem ( Texture * texture2D , Rect2 sourceRectangle , Rect2 destinationRectangle , int zIndex , float rotation , Color color , bool flipX , bool flipY ) { SpriteBatchItem spriteBatchItem = { texture2D , sourceRectangle , destinationRectangle , rotation , color , flipX , flipY }; rendererBatcher . BatchDrawSprite ( spriteBatchItem , zIndex ); } void Renderer2D :: FlushBatches () { assert ( spriteRenderer != nullptr && \"SpriteRenderer is NULL, initialize the Renderer2D before using!\" ); const RenderFlushFunction & renderFlushFunction = [ this ] ( const int zIndex , const ZIndexDrawBatch & zIndexDrawBatch ) { for ( const SpriteBatchItem & spriteBatchItem : zIndexDrawBatch . spriteDrawBatches ) { spriteRenderer -> Draw ( spriteBatchItem . texture2D , spriteBatchItem . sourceRectangle , spriteBatchItem . destinationRectangle , spriteBatchItem . rotation , spriteBatchItem . color , spriteBatchItem . flipX , spriteBatchItem . flipY ); } }; rendererBatcher . Flush ( renderFlushFunction ); } Explanation coming soon...","title":"Renderer2D"},{"location":"opengl_rendering/rendering_sprites/#render-sprites","text":"Updating constructor to initialize member pointer variables. GameEngine :: GameEngine () : projectProperties ( ProjectProperties :: GetInstance ()), engineContext ( GameEngineContext :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()), assetManager ( AssetManager :: GetInstance ()), fpsCounter ( FPSCounter :: GetInstance ()), logger ( Logger :: GetInstance ()) { Initialize (); } Implementing the private InitializeRendering function. void GameEngine::InitializeRendering () { // OpenGL attributes SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); renderContext -> window = SDL_CreateWindow ( projectProperties -> GetGameTitle (). c_str (), SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , projectProperties -> GetWindowWidth (), projectProperties -> GetWindowHeight (), renderContext -> windowFlags ); renderContext -> glContext = SDL_GL_CreateContext ( renderContext -> window ); renderContext -> currentWindowWidth = projectProperties -> GetWindowWidth (); renderContext -> currentWindowHeight = projectProperties -> GetWindowHeight (); if ( ! gladLoadGLLoader (( GLADloadproc ) SDL_GL_GetProcAddress )) { logger -> Error ( \"Couldn't initialize glad\" ); } renderer2D . Initialize (); // Temp Load Assets assetManager -> LoadTexture ( \"assets/images/melissa_walk_animation.png\" , \"assets/images/melissa_walk_animation.png\" ); } Now we will implement the Render function. void GameEngine::Render () { glClearColor ( projectProperties -> backgroundClearColor . r , projectProperties -> backgroundClearColor . g , projectProperties -> backgroundClearColor . b , projectProperties -> backgroundClearColor . a ); glClear ( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT ); // Render Sprites static Texture * mellisaWalkTexture = assetManager -> GetTexture ( \"assets/images/melissa_walk_animation.png\" ); static Rect2 drawSourceRect = Rect2 ( 0 , 0 , 32 , 32 ); static Rect2 drawDestinationRect = Rect2 ( windowCenter . x , windowCenter . y , drawSourceRect . w , drawSourceRect . h ); renderer2D . SubmitSpriteBatchItem ( mellisaWalkTexture , drawSourceRect , drawDestinationRect , 0 ); // Flush renderer2D . FlushBatches (); SDL_GL_SwapWindow ( renderContext -> window ); } Lastly we are going to process input by checking if an SDL_QUIT event type was triggered. If we click the 'X' in the top right part of the window, we will now close the window and shutdown the engine. void GameEngine::ProcessInput () { SDL_Event event ; while ( SDL_PollEvent ( & event )) { switch ( event . type ) { case SDL_QUIT : engineContext -> SetRunning ( false ); break ; case SDL_WINDOWEVENT : switch ( event . window . event ) { case SDL_WINDOWEVENT_RESIZED : renderContext -> currentWindowWidth = event . window . data1 ; renderContext -> currentWindowHeight = event . window . data2 ; glViewport ( 0 , 0 , renderContext -> currentWindowWidth , renderContext -> currentWindowHeight ); break ; } break ; } } } After executing the code, this will be rendered to the screen: The source code for this section can be found here . Now that we have rendered a sprite it's now time to render font.","title":"Render Sprites"},{"location":"opengl_rendering/rendering_text/","text":"Rendering Text Font Freetype Library Red Engine uses the FreeType to help render font. Font Class #ifndef FONT_H #define FONT_H #include <iostream> #include <string> #include <map> #include <ft2build.h> #include FT_FREETYPE_H #include <glad/glad.h> #include \"../math/math.h\" #include \"../utils/file_helper.h\" #include \"../utils/logger.h\" struct Character { GLuint textureID ; Vector2 size ; Vector2 bearing ; unsigned int advance ; }; class Font { public : std :: map < GLchar , Character > characters ; GLuint VAO ; GLuint VBO ; Font ( FT_Library freeTypeLibrary , const char * fileName , int size ) : filePath ( std :: string ( fileName )), size ( size ) { LoadFont ( freeTypeLibrary , fileName , size ); ConfigureVertex (); } std :: string GetFilePath () const { return filePath ; } int GetSize () const { return size ; } bool IsValid () const { return valid ; } private : std :: string filePath ; int size ; bool valid = false ; void LoadFont ( FT_Library freeTypeLibrary , const char * fileName , int size ) { static Logger * logger = Logger :: GetInstance (); if ( ! FileHelper :: DoesFileExist ( fileName )) { logger -> Error ( \"Font doesn't exist at path: %s\" , fileName ); } FT_Face face ; if ( FT_New_Face ( freeTypeLibrary , fileName , 0 , & face )) { logger -> Error ( \"Freetype failed to load font!\" ); } else { // set size to load glyphs. width set to 0 to dynamically adjust FT_Set_Pixel_Sizes ( face , 0 , size ); // disable byte-alignment restriction glPixelStorei ( GL_UNPACK_ALIGNMENT , 1 ); // load first 128 characters of ASCII set for ( unsigned char c = 0 ; c < 128 ; c ++ ) { // load character glyph if ( FT_Load_Char ( face , c , FT_LOAD_RENDER )) { logger -> Error ( \"Freetype Failed to load Glyph\" ); continue ; } // generate texture unsigned int textTexture ; glGenTextures ( 1 , & textTexture ); glBindTexture ( GL_TEXTURE_2D , textTexture ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RED , face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows , 0 , GL_RED , GL_UNSIGNED_BYTE , face -> glyph -> bitmap . buffer ); // set texture options glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); // store character for later use Character character = { . textureID = textTexture , . size = Vector2 ( face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows ), . bearing = Vector2 ( face -> glyph -> bitmap_left , face -> glyph -> bitmap_top ), . advance = static_cast < unsigned int > ( face -> glyph -> advance . x ) }; characters . insert ( std :: pair < char , Character > ( c , character )); } glBindTexture ( GL_TEXTURE_2D , 0 ); valid = true ; } FT_Done_Face ( face ); } void ConfigureVertex () { // configure VAO & VBO texture quads glGenVertexArrays ( 1 , & VAO ); glGenBuffers ( 1 , & VBO ); glBindVertexArray ( VAO ); glBindBuffer ( GL_ARRAY_BUFFER , VBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( GLfloat ) * 6 * 4 , NULL , GL_DYNAMIC_DRAW ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); } }; #endif //FONT_H Update Rendering Renderer Batcher Adding FontBatchItem struct. Also adding vector for font draw batches. struct FontBatchItem { Font * font = nullptr ; std :: string text ; float x = 0.0f ; float y = 0.0f ; float scale = 1.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; std :: vector < FontBatchItem > fontDrawBatches ; }; Adding function to batch draw font. void RendererBatcher::BatchDrawFont ( FontBatchItem fontBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. fontDrawBatches . emplace_back ( fontBatchItem ); } Renderer2D Function to submit font draw batch item. void Renderer2D::SubmitFontBatchItem ( Font * font , const std :: string & text , float x , float y , int zIndex , float scale , Color color ) { FontBatchItem fontBatchItem = { font , text , x , y , scale , color }; rendererBatcher . BatchDrawFont ( fontBatchItem , zIndex ); } Next is a function to draw font. void Renderer2D::DrawFont ( Font * font , const std :: string & text , float x , float y , float scale , Color color ) {} Render Context FT_Library freeTypeLibrary ; void InitializeFont () { if ( FT_Init_FreeType ( & freeTypeLibrary )) { Logger :: GetInstance () -> Error ( \"Could not initialize FreeType Library!\" ); } } Asset Manager Be sure to add RenderContext to AssetManager . AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()) {} Also add functions for fonts. void AssetManager::LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ) { Font * font = new Font ( fontId , renderContext -> freeTypeLibrary , fontPath . c_str (), size ); fonts . emplace ( fontId , font ); } Font * AssetManager::GetFont ( const std :: string & fontId ) { assert ( fonts . count ( fontId ) > 0 && \"Font hasn't been loaded!\" ); return fonts [ fontId ]; } bool AssetManager::HasFont ( const std :: string & fontId ) const { return fonts . count ( fontId ) > 0 ; } Render Text In InitializeRendering we are adding: renderContext -> InitializeFont (); We will also load a font into asset manager with: assetManager -> LoadFont ( \"assets/fonts/verdana.ttf\" , \"assets/fonts/verdana.ttf\" , 20 ); Next to render text, we call this within our Render function: static Font * textFont = assetManager -> GetFont ( \"assets/fonts/verdana.ttf\" ); static const std :: string & text = \"Hello World!\" ; static Vector2 fontPosition = Vector2 ( windowCenter . x - 35.0f , windowCenter . y - 20.0f ); static Color fontColor = Color ( 1.0f , 1.0f , 1.0f ); renderer2D . SubmitFontBatchItem ( textFont , text , fontPosition . x , fontPosition . y , 0 , 1.0f , fontColor ); Once we run the engine, the following will be rendered to the screen: We have finally rendered text to the screen! All source code for this section can be found here . Now that we have a way to render sprites and text to the screen it's now time to start adding implementing audio to play music and sound effects!","title":"Rendering Text"},{"location":"opengl_rendering/rendering_text/#rendering-text","text":"","title":"Rendering Text"},{"location":"opengl_rendering/rendering_text/#font","text":"","title":"Font"},{"location":"opengl_rendering/rendering_text/#freetype-library","text":"Red Engine uses the FreeType to help render font.","title":"Freetype Library"},{"location":"opengl_rendering/rendering_text/#font-class","text":"#ifndef FONT_H #define FONT_H #include <iostream> #include <string> #include <map> #include <ft2build.h> #include FT_FREETYPE_H #include <glad/glad.h> #include \"../math/math.h\" #include \"../utils/file_helper.h\" #include \"../utils/logger.h\" struct Character { GLuint textureID ; Vector2 size ; Vector2 bearing ; unsigned int advance ; }; class Font { public : std :: map < GLchar , Character > characters ; GLuint VAO ; GLuint VBO ; Font ( FT_Library freeTypeLibrary , const char * fileName , int size ) : filePath ( std :: string ( fileName )), size ( size ) { LoadFont ( freeTypeLibrary , fileName , size ); ConfigureVertex (); } std :: string GetFilePath () const { return filePath ; } int GetSize () const { return size ; } bool IsValid () const { return valid ; } private : std :: string filePath ; int size ; bool valid = false ; void LoadFont ( FT_Library freeTypeLibrary , const char * fileName , int size ) { static Logger * logger = Logger :: GetInstance (); if ( ! FileHelper :: DoesFileExist ( fileName )) { logger -> Error ( \"Font doesn't exist at path: %s\" , fileName ); } FT_Face face ; if ( FT_New_Face ( freeTypeLibrary , fileName , 0 , & face )) { logger -> Error ( \"Freetype failed to load font!\" ); } else { // set size to load glyphs. width set to 0 to dynamically adjust FT_Set_Pixel_Sizes ( face , 0 , size ); // disable byte-alignment restriction glPixelStorei ( GL_UNPACK_ALIGNMENT , 1 ); // load first 128 characters of ASCII set for ( unsigned char c = 0 ; c < 128 ; c ++ ) { // load character glyph if ( FT_Load_Char ( face , c , FT_LOAD_RENDER )) { logger -> Error ( \"Freetype Failed to load Glyph\" ); continue ; } // generate texture unsigned int textTexture ; glGenTextures ( 1 , & textTexture ); glBindTexture ( GL_TEXTURE_2D , textTexture ); glTexImage2D ( GL_TEXTURE_2D , 0 , GL_RED , face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows , 0 , GL_RED , GL_UNSIGNED_BYTE , face -> glyph -> bitmap . buffer ); // set texture options glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); // store character for later use Character character = { . textureID = textTexture , . size = Vector2 ( face -> glyph -> bitmap . width , face -> glyph -> bitmap . rows ), . bearing = Vector2 ( face -> glyph -> bitmap_left , face -> glyph -> bitmap_top ), . advance = static_cast < unsigned int > ( face -> glyph -> advance . x ) }; characters . insert ( std :: pair < char , Character > ( c , character )); } glBindTexture ( GL_TEXTURE_2D , 0 ); valid = true ; } FT_Done_Face ( face ); } void ConfigureVertex () { // configure VAO & VBO texture quads glGenVertexArrays ( 1 , & VAO ); glGenBuffers ( 1 , & VBO ); glBindVertexArray ( VAO ); glBindBuffer ( GL_ARRAY_BUFFER , VBO ); glBufferData ( GL_ARRAY_BUFFER , sizeof ( GLfloat ) * 6 * 4 , NULL , GL_DYNAMIC_DRAW ); glEnableVertexAttribArray ( 0 ); glVertexAttribPointer ( 0 , 4 , GL_FLOAT , GL_FALSE , 4 * sizeof ( GLfloat ), nullptr ); glBindBuffer ( GL_ARRAY_BUFFER , 0 ); glBindVertexArray ( 0 ); } }; #endif //FONT_H","title":"Font Class"},{"location":"opengl_rendering/rendering_text/#update-rendering","text":"","title":"Update Rendering"},{"location":"opengl_rendering/rendering_text/#renderer-batcher","text":"Adding FontBatchItem struct. Also adding vector for font draw batches. struct FontBatchItem { Font * font = nullptr ; std :: string text ; float x = 0.0f ; float y = 0.0f ; float scale = 1.0f ; Color color = Color ( 1.0f , 1.0f , 1.0f , 1.0f ); }; struct ZIndexDrawBatch { std :: vector < SpriteBatchItem > spriteDrawBatches ; std :: vector < FontBatchItem > fontDrawBatches ; }; Adding function to batch draw font. void RendererBatcher::BatchDrawFont ( FontBatchItem fontBatchItem , int zIndex ) { if ( drawBatches . find ( zIndex ) == drawBatches . end ()) { drawBatches . emplace ( zIndex , ZIndexDrawBatch {}); } drawBatches [ zIndex ]. fontDrawBatches . emplace_back ( fontBatchItem ); }","title":"Renderer Batcher"},{"location":"opengl_rendering/rendering_text/#renderer2d","text":"Function to submit font draw batch item. void Renderer2D::SubmitFontBatchItem ( Font * font , const std :: string & text , float x , float y , int zIndex , float scale , Color color ) { FontBatchItem fontBatchItem = { font , text , x , y , scale , color }; rendererBatcher . BatchDrawFont ( fontBatchItem , zIndex ); } Next is a function to draw font. void Renderer2D::DrawFont ( Font * font , const std :: string & text , float x , float y , float scale , Color color ) {}","title":"Renderer2D"},{"location":"opengl_rendering/rendering_text/#render-context","text":"FT_Library freeTypeLibrary ; void InitializeFont () { if ( FT_Init_FreeType ( & freeTypeLibrary )) { Logger :: GetInstance () -> Error ( \"Could not initialize FreeType Library!\" ); } }","title":"Render Context"},{"location":"opengl_rendering/rendering_text/#asset-manager","text":"Be sure to add RenderContext to AssetManager . AssetManager :: AssetManager () : logger ( Logger :: GetInstance ()), renderContext ( RenderContext :: GetInstance ()) {} Also add functions for fonts. void AssetManager::LoadFont ( const std :: string & fontId , const std :: string & fontPath , int size ) { Font * font = new Font ( fontId , renderContext -> freeTypeLibrary , fontPath . c_str (), size ); fonts . emplace ( fontId , font ); } Font * AssetManager::GetFont ( const std :: string & fontId ) { assert ( fonts . count ( fontId ) > 0 && \"Font hasn't been loaded!\" ); return fonts [ fontId ]; } bool AssetManager::HasFont ( const std :: string & fontId ) const { return fonts . count ( fontId ) > 0 ; }","title":"Asset Manager"},{"location":"opengl_rendering/rendering_text/#render-text","text":"In InitializeRendering we are adding: renderContext -> InitializeFont (); We will also load a font into asset manager with: assetManager -> LoadFont ( \"assets/fonts/verdana.ttf\" , \"assets/fonts/verdana.ttf\" , 20 ); Next to render text, we call this within our Render function: static Font * textFont = assetManager -> GetFont ( \"assets/fonts/verdana.ttf\" ); static const std :: string & text = \"Hello World!\" ; static Vector2 fontPosition = Vector2 ( windowCenter . x - 35.0f , windowCenter . y - 20.0f ); static Color fontColor = Color ( 1.0f , 1.0f , 1.0f ); renderer2D . SubmitFontBatchItem ( textFont , text , fontPosition . x , fontPosition . y , 0 , 1.0f , fontColor ); Once we run the engine, the following will be rendered to the screen: We have finally rendered text to the screen! All source code for this section can be found here . Now that we have a way to render sprites and text to the screen it's now time to start adding implementing audio to play music and sound effects!","title":"Render Text"},{"location":"serializing_with_json/parsing_json/","text":"Parsing JSON Coming soon.","title":"Parsing JSON"},{"location":"serializing_with_json/parsing_json/#parsing-json","text":"Coming soon.","title":"Parsing JSON"},{"location":"source_code/source_code/","text":"Source Code The full source code of the tutorials are on github and can be found here .","title":"Source Code"},{"location":"source_code/source_code/#source-code","text":"The full source code of the tutorials are on github and can be found here .","title":"Source Code"}]}